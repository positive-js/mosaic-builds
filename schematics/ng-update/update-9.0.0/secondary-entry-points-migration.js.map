{"version":3,"file":"secondary-entry-points-migration.js","sourceRoot":"","sources":["../../../../../packages/mosaic/schematics/ng-update/update-9.0.0/secondary-entry-points-migration.ts"],"names":[],"mappings":"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","sourcesContent":["import { Migration, TargetVersion } from '@angular/cdk/schematics';\nimport * as ts from 'typescript';\n\n\nconst ONLY_SUBPACKAGE_FAILURE_STR = `Importing from \"@ptsecurity/mosaic\" is deprecated. ` +\n    `Instead import from the entry-point the symbol belongs to.`;\n\nconst NO_IMPORT_NAMED_SYMBOLS_FAILURE_STR = `Imports from Mosaic should import ` +\n    `specific symbols rather than importing the entire library.`;\n\n\nconst legacyMosaicModuleSpecifier = '@ptsecurity/mosaic';\nconst currentMosaicModuleSpecifier = '@ptsecurity/mosaic';\n\nconst MOSAIC_AC_FILEPATH_REGEX = new RegExp(\n    `${legacyMosaicModuleSpecifier}/(.*?)/`\n);\n\n// tslint:disable-next-line:no-var-requires\nconst ENTRY_POINT_MAPPINGS: {[name: string]: string} = require('./mosaic-symbols.json');\n\n\nexport class SecondaryEntryPointsMigration extends Migration<null> {\n\n    printer = ts.createPrinter();\n\n    // Only enable this rule if the migration targets version 8.\n    enabled = this.targetVersion === TargetVersion.V8 || this.targetVersion === TargetVersion.V9;\n\n    // tslint:disable-next-line:max-func-body-length\n    visitNode(declaration: ts.Node): void {\n\n        if (\n            !ts.isImportDeclaration(declaration) ||\n            !ts.isStringLiteralLike(declaration.moduleSpecifier)\n        ) {\n            return;\n        }\n\n        const importLocation = declaration.moduleSpecifier.text;\n        // skip check - if the import module is not @ptsecurity/mosaic\n        if (importLocation !== legacyMosaicModuleSpecifier) {\n            return;\n        }\n\n        // If no import clause is found, or nothing is named as a binding in the\n        // import, add failure saying to import symbols in clause.\n        if (!declaration.importClause || !declaration.importClause.namedBindings) {\n            this.createFailureAtNode(declaration, NO_IMPORT_NAMED_SYMBOLS_FAILURE_STR);\n\n            return;\n        }\n\n        // All named bindings in import clauses must be named symbols, otherwise add\n        // failure saying to import symbols in clause.\n        if (!ts.isNamedImports(declaration.importClause.namedBindings)) {\n            this.createFailureAtNode(declaration, NO_IMPORT_NAMED_SYMBOLS_FAILURE_STR);\n\n            return;\n        }\n\n        // If no symbols are in the named bindings then add failure saying to\n        // import symbols in clause.\n        if (!declaration.importClause.namedBindings.elements.length) {\n            this.createFailureAtNode(declaration, NO_IMPORT_NAMED_SYMBOLS_FAILURE_STR);\n\n            return;\n        }\n\n        // Map which consists of secondary entry-points and import specifiers which are used\n        // within the current import declaration.\n        const importMap = new Map<string, ts.ImportSpecifier[]>();\n\n        // Determine the subpackage each symbol in the namedBinding comes from.\n        for (const element of declaration.importClause.namedBindings.elements) {\n\n            const elementName = element.propertyName ? element.propertyName : element.name;\n\n            const moduleName = resolveModuleName(elementName, this.typeChecker) ||\n                ENTRY_POINT_MAPPINGS[elementName.text] || null;\n\n            if (!moduleName) {\n\n                this.createFailureAtNode(\n                    element, `\"${element.getText()}\" was not found in the Mosaic library.`);\n\n                return;\n            }\n\n            // The module name where the symbol is defined e.g. card, dialog. The\n            // first capture group is contains the module name.\n            if (importMap.has(moduleName)) {\n                importMap.get(moduleName)!.push(element);\n            } else {\n                importMap.set(moduleName, [element]);\n            }\n        }\n\n        const singleQuoteImport = declaration.moduleSpecifier.getText()[0] === `'`;\n\n        // Transforms the import declaration into multiple import declarations that import\n        // the given symbols from the individual secondary entry-points. For example:\n        // import { McCardModule } from '@ptsecurity/mosaic/card';\n        // import { McRadioModule } from '@ptsecurity/mosaic/radio';\n        const newImportStatements =\n            Array.from(importMap.entries())\n                .sort()\n                .map(([name, elements]) => {\n                    const newImport = ts.createImportDeclaration(\n                        undefined, undefined,\n                        ts.createImportClause(undefined, ts.createNamedImports(elements)),\n                        createStringLiteral(`${currentMosaicModuleSpecifier}/${name}`, singleQuoteImport));\n\n                    return this.printer.printNode(\n                        ts.EmitHint.Unspecified, newImport, declaration.getSourceFile());\n                })\n                .join('\\n');\n\n        // Without any import statements that were generated, we can assume that this was an empty\n        // import declaration. We still want to add a failure in order to make developers aware that\n        // importing from \"@ptsecurity/mosaic\" is deprecated.\n        if (!newImportStatements) {\n            this.createFailureAtNode(declaration.moduleSpecifier, ONLY_SUBPACKAGE_FAILURE_STR);\n\n            return;\n        }\n\n        const recorder = this.fileSystem.edit(declaration.moduleSpecifier.getSourceFile().fileName);\n\n        // Perform the replacement that switches the primary entry-point import to\n        // the individual secondary entry-point imports.\n        recorder.remove(declaration.getStart(), declaration.getWidth());\n        recorder.insertRight(declaration.getStart(), newImportStatements);\n    }\n}\n\n/**\n * Creates a string literal from the specified text.\n * @param text Text of the string literal.\n * @param singleQuotes Whether single quotes should be used when printing the literal node.\n */\nfunction createStringLiteral(text: string, singleQuotes: boolean): ts.StringLiteral {\n    const literal = ts.createStringLiteral(text);\n    // See: https://github.com/microsoft/TypeScript/blob/master/src/compiler/utilities.ts#L584-L590\n    // tslint:disable-next-line: no-string-literal\n    literal['singleQuote'] = singleQuotes;\n\n    return literal;\n}\n\nfunction getDeclarationSymbolOfNode(node: ts.Node, checker: ts.TypeChecker): ts.Symbol | undefined {\n    // tslint:disable-next-line:no-reserved-keywords\n    const symbol = checker.getSymbolAtLocation(node);\n\n    // Symbols can be aliases of the declaration symbol. e.g. in named import specifiers.\n    // We need to resolve the aliased symbol back to the declaration symbol.\n    // tslint:disable-next-line:no-bitwise\n    if (symbol && (symbol.flags & ts.SymbolFlags.Alias) !== 0) {\n        return checker.getAliasedSymbol(symbol);\n    }\n\n    return symbol;\n}\n\nfunction resolveModuleName(node: ts.Identifier, typeChecker: ts.TypeChecker) {\n    // Get the symbol for the named binding element. Note that we cannot determine the\n    // value declaration based on the type of the element as types are not necessarily\n    // specific to a given secondary entry-point (e.g. exports with the type of \"string\")\n    // would resolve to the module types provided by TypeScript itself.\n    // tslint:disable-next-line:no-reserved-keywords\n    const symbol = getDeclarationSymbolOfNode(node, typeChecker);\n\n    // If the symbol can't be found, or no declaration could be found within\n    // the symbol, add failure to report that the given symbol can't be found.\n    if (!symbol ||\n        !(symbol.valueDeclaration || (symbol.declarations && symbol.declarations.length !== 0))) {\n        return null;\n    }\n\n    // The filename for the source file of the node that contains the\n    // first declaration of the symbol. All symbol declarations must be\n    // part of a defining node, so parent can be asserted to be defined.\n    const resolvedNode = symbol.valueDeclaration || symbol.declarations[0];\n    const sourceFile = resolvedNode.getSourceFile().fileName;\n\n    // File the module the symbol belongs to from a regex match of the\n    // filename. This will always match since only \"@ptsecurity/mosaic\"\n    // elements are analyzed.\n    const matches = sourceFile.match(MOSAIC_AC_FILEPATH_REGEX);\n\n    return matches ? matches[1] : null;\n}\n"]}
{"version":3,"sources":["../../../packages/mosaic/tags/tag-default-options.ts","../../../node_modules/tslib/tslib.es6.js","../../../packages/mosaic/tags/tag-input.ts","../../../packages/mosaic/tags/tag.component.ts","../../../packages/mosaic/tags/tag-list.component.ts","../../../packages/mosaic/tags/tag.module.ts"],"names":["MC_TAGS_DEFAULT_OPTIONS","InjectionToken","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","__read","n","r","e","ar","push","error","__spread","arguments","concat","nextUniqueId","McTagInput","elementRef","renderer","defaultOptions","ngControl","focused","separatorKeyCodes","tagEnd","EventEmitter","placeholder","id","_addOnBlur","_disabled","countOfSymbolsForUpdateWidth","inputElement","nativeElement","setDefaultInputWidth","defineProperty","_tagList","registerInput","coerceBooleanProperty","disabled","ngOnChanges","stateChanges","onKeydown","event","keydown","isSeparatorKey","emitTagEnd","preventDefault","blur","triggerValidation","addOnBlur","hasControl","statusChanges","emit","status","invalid","input","updateInputWidth","onInput","onPaste","$event","_this","clipboardData","data","getData","items","_b","_c","key","separator","separatorKeyToSymbol","search","apply","split","forEach","item","stopPropagation","setStyle","oneSymbolWidth","scrollWidth","onFocus","focus","k","sep","_a","ENTER","TAB","SPACE","COMMA","hasModifierKey","indexOf","keyCode","Directive","args","selector","exportAs","host","class","[id]","[attr.disabled]","[attr.placeholder]","(keydown)","(blur)","(focus)","(input)","(paste)","ElementRef","Renderer2","Inject","NgControl","decorators","type","Optional","Self","Input","Output","source","selected","isUserInput","TAG_ATTRIBUTE_NAMES","_elementRef","McTagMixinBase","mixinColor","mixinDisabled","McTagBase","McTag","changeDetectorRef","_ngZone","_super","Subject","onBlur","hasFocus","tagListSelectable","selectionChange","destroyed","removed","_selected","_selectable","_removable","addHostClassName","coercedValue","dispatchSelectionChange","undefined","_value","textContent","selectable","ngAfterContentInit","addClassModificatorForIcons","icons","contentChildren","map","iconElement","previousElementSibling","nextElementSibling","nextSibling","classList","add","previousSibling","firstIconElement","secondIconElement","TAG_ATTRIBUTE_NAMES_1","TAG_ATTRIBUTE_NAMES_1_1","attr","hasAttribute","tagName","toLowerCase","ngOnDestroy","tag","select","deselect","selectViaInteraction","toggleSelected","Promise","resolve","then","markForCheck","remove","removable","handleClick","handleKeydown","DELETE","BACKSPACE","onStable","asObservable","pipe","take","subscribe","run","Component","template","inputs","[attr.tabindex]","[class.mc-selected]","[class.mc-focused]","[class.mc-tag-with-avatar]","[class.mc-tag-with-trailing-icon]","[class.mc-disabled]","(click)","changeDetection","ChangeDetectionStrategy","OnPush","encapsulation","ViewEncapsulation","None","ChangeDetectorRef","NgZone","ContentChildren","McIcon","ContentChild","McTagAvatar","static","McTagTrailingIcon","forwardRef","McTagRemove","parentTag","defaultErrorStateMatcher","parentForm","parentFormGroup","McTagListMixinBase","mixinErrorState","McTagListBase","McTagList","rawValidators","mcValidation","dir","ngModel","formControlName","controlType","_tabIndex","valueChange","uid","userTabIndex","tagChanges","orientation","change","_required","_multiple","lastDestroyedTagIndex","onTouched","onChange","_compareWith","o1","o2","valueAccessor","merge","tags","multiple","selectionModel","cleaner","fn","initializeSelection","writeValue","tagInput","_placeholder","hasFocusedTag","empty","syncTagsDisabledState","useValidation","setMosaicValidation","keyManager","FocusKeyManager","withVerticalOrientation","withHorizontalOrientation","takeUntil","tabOut","setTimeout","changes","startWith","resetTags","updateTabIndex","updateFocusForDestroyedTags","toArray","propagateTagsChanges","ngOnInit","SelectionModel","ngDoCheck","updateErrorState","complete","dropSubscriptions","control","setErrors","errors","setSelectionByValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","onContainerClick","originatesFromTag","setFirstItemActive","focusInput","target","isInputEmpty","setLastItemActive","contains","HOME","END","clearSelection","isArray","currentValue","selectValue","sortValues","correspondingTag","setActiveItem","markAsTouched","newTagIndex","Math","min","isValidIndex","index","element","nodeName","find","skip","clear","propagateChanges","fallbackValue","valueToEmit","McTagListChange","listenToTagsFocus","listenToTagsSelection","listenToTagsRemoved","tagFocusSubscription","unsubscribe","tagBlurSubscription","tagSelectionSubscription","tagRemoveSubscription","tagSelectionChanges","isSelected","tagFocusChanges","tagIndex","updateActiveItem","tagBlurChanges","tagRemoveChanges","currentElement","parentElement","some","[class.mc-invalid]","providers","provide","McFormFieldControl","useExisting","ErrorStateMatcher","NG_VALIDATORS","MC_VALIDATION","Directionality","NgForm","FormGroupDirective","NgModel","FormControlName","descendants","NgModule","imports","CommonModule","PlatformModule","exports","declarations","useValue","Éµ0"],"mappings":"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","sourcesContent":["import { InjectionToken } from '@angular/core';\n\n\n/** Default options, for the chips module, that can be overridden. */\n// tslint:disable-next-line: naming-convention\nexport interface McTagsDefaultOptions {\n    /** The list of key codes that will trigger a chipEnd event. */\n    separatorKeyCodes: number[];\n}\n\n/** Injection token to be used to override the default options for the chips module. */\nexport const MC_TAGS_DEFAULT_OPTIONS = new InjectionToken<McTagsDefaultOptions>('mc-tags-default-options');\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    Directive,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    Input,\n    OnChanges,\n    Optional,\n    Output,\n    Renderer2,\n    Self\n} from '@angular/core';\nimport { NgControl } from '@angular/forms';\nimport { hasModifierKey, ENTER, TAB, SPACE, COMMA } from '@ptsecurity/cdk/keycodes';\n\nimport { MC_TAGS_DEFAULT_OPTIONS, McTagsDefaultOptions } from './tag-default-options';\nimport { McTagList } from './tag-list.component';\nimport { McTagTextControl } from './tag-text-control';\n\n\n/** Represents an input event on a `mcTagInput`. */\n// tslint:disable-next-line: naming-convention\nexport interface McTagInputEvent {\n    /** The native `<input>` element that the event is being fired for. */\n    input: HTMLInputElement;\n\n    /** The value of the input. */\n    value: string;\n}\n\n// Increasing integer for generating unique ids.\nlet nextUniqueId = 0;\n\n/**\n * Directive that adds tag-specific behaviors to an input element inside `<mc-form-field>`.\n * May be placed inside or outside of an `<mc-tag-list>`.\n */\n@Directive({\n    selector: 'input[mcTagInputFor]',\n    exportAs: 'mcTagInput, mcTagInputFor',\n    host: {\n        class: 'mc-tag-input',\n\n        '[id]': 'id',\n        '[attr.disabled]': 'disabled || null',\n        '[attr.placeholder]': 'placeholder || null',\n\n        '(keydown)': 'onKeydown($event)',\n        '(blur)': 'blur()',\n        '(focus)': 'onFocus()',\n        '(input)': 'onInput()',\n        '(paste)': 'onPaste($event)'\n    }\n})\nexport class McTagInput implements McTagTextControl, OnChanges {\n    /** Whether the control is focused. */\n    focused: boolean = false;\n\n    /**\n     * The list of key codes that will trigger a tagEnd event.\n     *\n     * Defaults to `[ENTER]`.\n     */\n    @Input('mcTagInputSeparatorKeyCodes')\n    separatorKeyCodes: number[] = this.defaultOptions.separatorKeyCodes;\n\n    /** Emitted when a tag is to be added. */\n    @Output('mcTagInputTokenEnd')\n    tagEnd: EventEmitter<McTagInputEvent> = new EventEmitter<McTagInputEvent>();\n\n    /** The input's placeholder text. */\n    @Input() placeholder: string = '';\n\n    /** Unique id for the input. */\n    @Input() id: string = `mc-tag-list-input-${nextUniqueId++}`;\n\n    /** Register input for tag list */\n    @Input('mcTagInputFor')\n    set tagList(value: McTagList) {\n        if (value) {\n            this._tagList = value;\n            this._tagList.registerInput(this);\n        }\n    }\n\n    // tslint:disable-next-line: naming-convention\n    private _tagList: McTagList;\n\n    /**\n     * Whether or not the tagEnd event will be emitted when the input is blurred.\n     */\n    @Input('mcTagInputAddOnBlur')\n    get addOnBlur(): boolean {\n        return this._addOnBlur;\n    }\n\n    set addOnBlur(value: boolean) {\n        this._addOnBlur = coerceBooleanProperty(value);\n    }\n\n    private _addOnBlur: boolean = true;\n\n    /** Whether the input is disabled. */\n    @Input()\n    get disabled(): boolean {\n        return this._disabled || (this._tagList && this._tagList.disabled);\n    }\n\n    set disabled(value: boolean) {\n        this._disabled = coerceBooleanProperty(value);\n    }\n\n    private _disabled: boolean = false;\n\n    /** Whether the input is empty. */\n    get empty(): boolean {\n        return !this.inputElement.value;\n    }\n\n    countOfSymbolsForUpdateWidth: number = 3;\n\n    private oneSymbolWidth: number;\n\n    /** The native input element to which this directive is attached. */\n    private inputElement: HTMLInputElement;\n\n    constructor(\n        private elementRef: ElementRef<HTMLInputElement>,\n        private renderer: Renderer2,\n        @Inject(MC_TAGS_DEFAULT_OPTIONS) private defaultOptions: McTagsDefaultOptions,\n        @Optional() @Self() public ngControl: NgControl\n    ) {\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        this.inputElement = this.elementRef.nativeElement as HTMLInputElement;\n\n        this.setDefaultInputWidth();\n    }\n\n    ngOnChanges() {\n        this._tagList.stateChanges.next();\n    }\n\n    onKeydown(event: KeyboardEvent) {\n        if (!this.inputElement.value) {\n            this._tagList.keydown(event);\n        }\n\n        if (this.isSeparatorKey(event)) {\n            this.emitTagEnd();\n\n            event.preventDefault();\n        }\n    }\n\n    /** Checks to see if the blur should emit the (tagEnd) event. */\n    blur() {\n        this.focused = false;\n        // Blur the tag list if it is not focused\n        if (!this._tagList.focused) {\n            this.triggerValidation();\n\n            this._tagList.blur();\n        }\n\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        if (this.addOnBlur) {\n            this.emitTagEnd();\n        }\n\n        this._tagList.stateChanges.next();\n    }\n\n    triggerValidation() {\n        if (!this.hasControl()) { return; }\n\n        (this.ngControl.statusChanges as EventEmitter<string | null>).emit(this.ngControl.status);\n    }\n\n    /** Checks to see if the (tagEnd) event needs to be emitted. */\n    emitTagEnd() {\n        if (!this.hasControl() || (this.hasControl() && !this.ngControl.invalid)) {\n            this.tagEnd.emit({ input: this.inputElement, value: this.inputElement.value });\n            this.updateInputWidth();\n        }\n    }\n\n    onInput() {\n        this.updateInputWidth();\n        // Let tag list know whenever the value changes.\n        this._tagList.stateChanges.next();\n    }\n\n    onPaste($event: ClipboardEvent) {\n        if (!$event.clipboardData) { return; }\n\n        const data = $event.clipboardData.getData('text');\n\n        if (data && data.length === 0) { return; }\n\n        const items: string[] = [];\n\n        for (const key of this.separatorKeyCodes) {\n            const separator = this.separatorKeyToSymbol(key);\n\n            if (data.search(separator) > -1) {\n                items.push(...data.split(separator));\n\n                break;\n            }\n        }\n\n        if (items.length === 0) {\n            items.push(data);\n        }\n\n        items.forEach((item) => this.tagEnd.emit({ input: this.inputElement, value: item }));\n\n        this.updateInputWidth();\n\n        $event.preventDefault();\n        $event.stopPropagation();\n    }\n\n    updateInputWidth(): void {\n        const length = this.inputElement.value.length;\n\n        this.renderer.setStyle(this.inputElement, 'max-width', 0);\n        this.oneSymbolWidth = this.inputElement.scrollWidth / length;\n        this.renderer.setStyle(this.inputElement, 'max-width', '');\n\n        if (length > this.countOfSymbolsForUpdateWidth) {\n            this.renderer.setStyle(this.inputElement, 'width', `${length * this.oneSymbolWidth}px`);\n        } else {\n            this.setDefaultInputWidth();\n        }\n    }\n\n    onFocus() {\n        this.focused = true;\n        this._tagList.stateChanges.next();\n    }\n\n    /** Focuses the input. */\n    focus(): void {\n        this.inputElement.focus();\n    }\n\n    private separatorKeyToSymbol(k): RegExp | string {\n        const sep = {\n            [ENTER]: /\\r?\\n/,\n            [TAB]: /\\t/,\n            [SPACE]: / /,\n            [COMMA]: /,/\n        }[k];\n\n        if (sep) { return sep; }\n\n        return k;\n    }\n\n    private hasControl(): boolean {\n        return !!this.ngControl;\n    }\n\n    private setDefaultInputWidth() {\n        this.renderer.setStyle(this.inputElement, 'width', '30px');\n    }\n\n    /** Checks whether a keycode is one of the configured separators. */\n    private isSeparatorKey(event: KeyboardEvent) {\n        if (hasModifierKey(event)) { return false; }\n\n        // tslint:disable-next-line: deprecation\n        return this.separatorKeyCodes.indexOf(event.keyCode) > -1;\n    }\n}\n","import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChild,\n    ContentChildren,\n    Directive,\n    ElementRef,\n    EventEmitter,\n    forwardRef,\n    Input,\n    NgZone,\n    OnDestroy,\n    Output,\n    QueryList,\n    ViewEncapsulation\n} from '@angular/core';\nimport { IFocusableOption } from '@ptsecurity/cdk/a11y';\nimport { BACKSPACE, DELETE, SPACE } from '@ptsecurity/cdk/keycodes';\nimport {\n    CanColor,\n    CanColorCtor,\n    CanDisable,\n    CanDisableCtor,\n    mixinColor,\n    mixinDisabled\n} from '@ptsecurity/mosaic/core';\nimport { McIcon } from '@ptsecurity/mosaic/icon';\nimport { Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\n\n// tslint:disable-next-line:naming-convention\nexport interface McTagEvent {\n    tag: McTag;\n}\n\n/** Event object emitted by McTag when selected or deselected. */\nexport class McTagSelectionChange {\n    constructor(public source: McTag, public selected: boolean, public isUserInput = false) {}\n}\n\n\nconst TAG_ATTRIBUTE_NAMES = ['mc-basic-tag'];\n\n/**\n * Dummy directive to add CSS class to tag avatar.\n * @docs-private\n */\n@Directive({\n    selector: 'mc-tag-avatar, [mcTagAvatar]',\n    host: { class: 'mc-tag-avatar' }\n})\nexport class McTagAvatar {}\n\n/**\n * Dummy directive to add CSS class to tag trailing icon.\n * @docs-private\n */\n@Directive({\n    selector: 'mc-tag-trailing-icon, [mcTagTrailingIcon]',\n    host: { class: 'mc-tag-trailing-icon' }\n})\nexport class McTagTrailingIcon {}\n\nexport class McTagBase {\n    // tslint:disable-next-line:naming-convention\n    constructor(public _elementRef: ElementRef) {}\n}\n\n// tslint:disable-next-line:naming-convention\nexport const McTagMixinBase: CanColorCtor & CanDisableCtor & typeof McTagBase = mixinColor(mixinDisabled(McTagBase));\n\n\n@Component({\n    selector: 'mc-tag, [mc-tag], mc-basic-tag, [mc-basic-tag]',\n    exportAs: 'mcTag',\n    templateUrl: 'tag.partial.html',\n    styleUrls: ['./tag.scss'],\n    inputs: ['color'],\n    host: {\n        class: 'mc-tag',\n\n        '[attr.tabindex]': 'tabindex',\n        '[attr.disabled]': 'disabled || null',\n\n        '[class.mc-selected]': 'selected',\n        '[class.mc-focused]': 'hasFocus',\n        '[class.mc-tag-with-avatar]': 'avatar',\n        '[class.mc-tag-with-trailing-icon]': 'trailingIcon || removeIcon',\n        '[class.mc-disabled]': 'disabled',\n\n        '(click)': 'handleClick($event)',\n        '(keydown)': 'handleKeydown($event)',\n        '(focus)': 'focus()',\n        '(blur)': 'blur()'\n    },\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None\n})\nexport class McTag extends McTagMixinBase implements IFocusableOption, OnDestroy, CanColor, CanDisable {\n    /** Emits when the tag is focused. */\n    readonly onFocus = new Subject<McTagEvent>();\n\n    /** Emits when the tag is blured. */\n    readonly onBlur = new Subject<McTagEvent>();\n\n    nativeElement: HTMLElement;\n\n    /** Whether the tag has focus. */\n    hasFocus: boolean = false;\n\n    /** Whether the tag list is selectable */\n    tagListSelectable: boolean = true;\n\n    @ContentChildren(McIcon) contentChildren: QueryList<McIcon>;\n\n    /** The tag avatar */\n    @ContentChild(McTagAvatar, {static: false}) avatar: McTagAvatar;\n\n    /** The tag's trailing icon. */\n    @ContentChild(McTagTrailingIcon, {static: false}) trailingIcon: McTagTrailingIcon;\n\n    /** The tag's remove toggler. */\n    @ContentChild(forwardRef(() => McTagRemove), {static: false}) removeIcon: McTagRemove;\n\n    /** Emitted when the tag is selected or deselected. */\n    @Output() readonly selectionChange: EventEmitter<McTagSelectionChange> =\n        new EventEmitter<McTagSelectionChange>();\n\n    /** Emitted when the tag is destroyed. */\n    @Output() readonly destroyed: EventEmitter<McTagEvent> = new EventEmitter<McTagEvent>();\n\n    /** Emitted when a tag is to be removed. */\n    @Output() readonly removed: EventEmitter<McTagEvent> = new EventEmitter<McTagEvent>();\n\n    /** Whether the tag is selected. */\n    @Input()\n    get selected(): boolean {\n        return this._selected;\n    }\n\n    set selected(value: boolean) {\n        const coercedValue = coerceBooleanProperty(value);\n\n        if (coercedValue !== this._selected) {\n            this._selected = coercedValue;\n            this.dispatchSelectionChange();\n        }\n    }\n\n    private _selected: boolean = false;\n\n    /** The value of the tag. Defaults to the content inside `<mc-tag>` tags. */\n    @Input()\n    get value(): any {\n        return this._value !== undefined\n            ? this._value\n            : this.elementRef.nativeElement.textContent;\n    }\n\n    set value(value: any) {\n        this._value = value;\n    }\n\n    private _value: any;\n\n    /**\n     * Whether or not the tag is selectable. When a tag is not selectable,\n     * changes to its selected state are always ignored. By default a tag is\n     * selectable, and it becomes non-selectable if its parent tag list is\n     * not selectable.\n     */\n    @Input()\n    get selectable(): boolean {\n        return this._selectable && this.tagListSelectable;\n    }\n\n    set selectable(value: boolean) {\n        this._selectable = coerceBooleanProperty(value);\n    }\n\n    private _selectable: boolean = true;\n\n    /**\n     * Determines whether or not the tag displays the remove styling and emits (removed) events.\n     */\n    @Input()\n    get removable(): boolean {\n        return this._removable;\n    }\n\n    set removable(value: boolean) {\n        this._removable = coerceBooleanProperty(value);\n    }\n\n    private _removable: boolean = true;\n\n    get tabindex(): any {\n        if (!this.selectable) { return null; }\n\n        return this.disabled ? null : -1;\n    }\n\n    @Input()\n    get disabled() {\n        return this._disabled;\n    }\n\n    set disabled(value: any) {\n        if (value !== this.disabled) {\n            this._disabled = value;\n        }\n    }\n\n    private _disabled: boolean = false;\n\n    constructor(\n        public elementRef: ElementRef,\n        public changeDetectorRef: ChangeDetectorRef,\n        private _ngZone: NgZone\n    ) {\n        super(elementRef);\n\n        this.addHostClassName();\n\n        this.nativeElement = elementRef.nativeElement;\n    }\n\n    ngAfterContentInit() {\n        this.addClassModificatorForIcons();\n    }\n\n    addClassModificatorForIcons() {\n        const icons = this.contentChildren.map((item) => item._elementRef.nativeElement);\n\n        if (icons.length === 1) {\n            const iconElement = icons[0];\n\n            if (!iconElement.previousElementSibling && !iconElement.nextElementSibling) {\n                if (iconElement.nextSibling) {\n                    iconElement.classList.add('mc-icon_left');\n                    this.nativeElement.classList.add('mc-left-icon');\n                }\n\n                if (iconElement.previousSibling) {\n                    iconElement.classList.add('mc-icon_right');\n                    this.nativeElement.classList.add('mc-right-icon');\n                }\n            }\n        } else if (icons.length > 1) {\n            const firstIconElement = icons[0];\n            const secondIconElement = icons[1];\n\n            firstIconElement.classList.add('mc-icon_left');\n            secondIconElement.classList.add('mc-icon_right');\n        }\n    }\n\n    addHostClassName() {\n        // Add class for the different tags\n        for (const attr of TAG_ATTRIBUTE_NAMES) {\n            if (\n                this.elementRef.nativeElement.hasAttribute(attr) ||\n                this.elementRef.nativeElement.tagName.toLowerCase() === attr\n            ) {\n                    (this.elementRef.nativeElement as HTMLElement).classList.add(attr);\n\n                    return;\n            }\n        }\n        (this.elementRef.nativeElement as HTMLElement).classList.add('mc-standard-tag');\n    }\n\n    ngOnDestroy() {\n        this.destroyed.emit({ tag: this });\n    }\n\n    select(): void {\n        if (!this._selected) {\n            this._selected = true;\n            this.dispatchSelectionChange();\n        }\n    }\n\n    deselect(): void {\n        if (this._selected) {\n            this._selected = false;\n            this.dispatchSelectionChange();\n        }\n    }\n\n    selectViaInteraction(): void {\n        if (!this._selected) {\n            this._selected = true;\n            this.dispatchSelectionChange(true);\n        }\n    }\n\n    toggleSelected(isUserInput: boolean = false): boolean {\n        this._selected = !this.selected;\n        this.dispatchSelectionChange(isUserInput);\n\n        return this.selected;\n    }\n\n    /** Allows for programmatic focusing of the tag. */\n    focus(): void {\n        if (!this.selectable) { return; }\n\n        if (!this.hasFocus) {\n            this.elementRef.nativeElement.focus();\n\n            this.onFocus.next({ tag: this });\n\n            Promise.resolve().then(() => {\n                this.hasFocus = true;\n                this.changeDetectorRef.markForCheck();\n            });\n        }\n    }\n\n    /**\n     * Allows for programmatic removal of the tag. Called by the McTagList when the DELETE or\n     * BACKSPACE keys are pressed.\n     *\n     * Informs any listeners of the removal request. Does not remove the tag from the DOM.\n     */\n    remove(): void {\n        if (this.removable) {\n            this.removed.emit({ tag: this });\n        }\n    }\n\n    handleClick(event: Event) {\n        if (this.disabled) {\n            event.preventDefault();\n        } else {\n            event.stopPropagation();\n        }\n    }\n\n    handleKeydown(event: KeyboardEvent): void {\n        if (this.disabled) { return; }\n\n        // tslint:disable-next-line: deprecation\n        switch (event.keyCode) {\n            case DELETE:\n            case BACKSPACE:\n                // If we are removable, remove the focused tag\n                this.remove();\n                // Always prevent so page navigation does not occur\n                event.preventDefault();\n                break;\n            case SPACE:\n                // If we are selectable, toggle the focused tag\n                if (this.selectable) {\n                    this.toggleSelected(true);\n                }\n\n                // Always prevent space from scrolling the page since the list has focus\n                event.preventDefault();\n                break;\n            default:\n        }\n    }\n\n    blur(): void {\n        // When animations are enabled, Angular may end up removing the tag from the DOM a little\n        // earlier than usual, causing it to be blurred and throwing off the logic in the tag list\n        // that moves focus not the next item. To work around the issue, we defer marking the tag\n        // as not focused until the next time the zone stabilizes.\n        this._ngZone.onStable\n            .asObservable()\n            .pipe(take(1))\n            .subscribe(() => {\n                this._ngZone.run(() => {\n                    this.hasFocus = false;\n                    this.onBlur.next({ tag: this });\n                });\n            });\n    }\n\n    private dispatchSelectionChange(isUserInput = false) {\n        this.selectionChange.emit({\n            source: this,\n            isUserInput,\n            selected: this._selected\n        });\n    }\n}\n\n\n/**\n *\n * Example:\n *\n *     `<mc-tag>\n *       <mc-icon mcTagRemove>cancel</mc-icon>\n *     </mc-tag>`\n *\n * You *may* use a custom icon, but you may need to override the `mc-tag-remove` positioning\n * styles to properly center the icon within the tag.\n */\n@Directive({\n    selector: '[mcTagRemove]',\n    host: {\n        class: 'mc-tag-remove mc-tag-trailing-icon',\n        '[attr.tabindex]': '-1',\n        '(click)': 'handleClick($event)',\n        '(focus)': 'focus($event)'\n    }\n})\nexport class McTagRemove {\n    constructor(protected parentTag: McTag) {}\n\n    focus($event): void {\n        $event.stopPropagation();\n    }\n\n    /** Calls the parent tag's public `remove()` method if applicable. */\n    handleClick(event: Event): void {\n        if (this.parentTag.removable) {\n            this.parentTag.remove();\n        }\n\n        // We need to stop event propagation because otherwise the event will bubble up to the\n        // form field and cause the `onContainerClick` method to be invoked. This method would then\n        // reset the focused tag that has been focused after tag removal. Usually the parent\n        // the parent click listener of the `McTag` would prevent propagation, but it can happen\n        // that the tag is being removed before the event bubbles up.\n        event.stopPropagation();\n    }\n}\n","import { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport {\n    AfterContentInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChild,\n    ContentChildren,\n    DoCheck,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    Input,\n    OnDestroy,\n    OnInit,\n    Optional,\n    Output,\n    QueryList,\n    Self,\n    ViewEncapsulation\n} from '@angular/core';\nimport {\n    ControlValueAccessor,\n    FormControlName,\n    FormGroupDirective,\n    NG_VALIDATORS,\n    NgControl,\n    NgForm,\n    NgModel,\n    Validator\n} from '@angular/forms';\nimport { FocusKeyManager } from '@ptsecurity/cdk/a11y';\nimport { BACKSPACE, END, HOME } from '@ptsecurity/cdk/keycodes';\nimport {\n    CanUpdateErrorState,\n    CanUpdateErrorStateCtor,\n    ErrorStateMatcher,\n    MC_VALIDATION,\n    McValidationOptions,\n    mixinErrorState,\n    setMosaicValidation\n} from '@ptsecurity/mosaic/core';\nimport { McCleaner, McFormFieldControl } from '@ptsecurity/mosaic/form-field';\nimport { merge, Observable, Subject, Subscription } from 'rxjs';\nimport { startWith, takeUntil } from 'rxjs/operators';\n\nimport { McTagTextControl } from './tag-text-control';\nimport { McTag, McTagEvent, McTagSelectionChange } from './tag.component';\n\n\nexport class McTagListBase {\n    constructor(\n        public defaultErrorStateMatcher: ErrorStateMatcher,\n        public parentForm: NgForm,\n        public parentFormGroup: FormGroupDirective,\n        public ngControl: NgControl\n    ) {}\n}\n\n// tslint:disable-next-line:naming-convention\nexport const McTagListMixinBase: CanUpdateErrorStateCtor & typeof McTagListBase = mixinErrorState(McTagListBase);\n\n\n// Increasing integer for generating unique ids for tag-list components.\nlet nextUniqueId = 0;\n\n/** Change event object that is emitted when the tag list value has changed. */\nexport class McTagListChange {\n    constructor(public source: McTagList, public value: any) {}\n}\n\n\n@Component({\n    selector: 'mc-tag-list',\n    exportAs: 'mcTagList',\n    templateUrl: 'tag-list.partial.html',\n    styleUrls: ['tag-list.scss'],\n    host: {\n        class: 'mc-tag-list',\n        '[class.mc-disabled]': 'disabled',\n        '[class.mc-invalid]': 'errorState',\n\n        '[attr.tabindex]': 'disabled ? null : tabIndex',\n        '[id]': 'uid',\n\n        '(focus)': 'focus()',\n        '(blur)': 'blur()',\n        '(keydown)': 'keydown($event)'\n    },\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [{ provide: McFormFieldControl, useExisting: McTagList }]\n})\nexport class McTagList extends McTagListMixinBase implements McFormFieldControl<any>,\n    ControlValueAccessor, AfterContentInit, DoCheck, OnInit, OnDestroy, CanUpdateErrorState {\n\n    readonly controlType: string = 'tag-list';\n\n    /** Combined stream of all of the child tags' selection change events. */\n    get tagSelectionChanges(): Observable<McTagSelectionChange> {\n        return merge(...this.tags.map((tag) => tag.selectionChange));\n    }\n\n    /** Combined stream of all of the child tags' focus change events. */\n    get tagFocusChanges(): Observable<McTagEvent> {\n        return merge(...this.tags.map((tag) => tag.onFocus));\n    }\n\n    /** Combined stream of all of the child tags' blur change events. */\n    get tagBlurChanges(): Observable<McTagEvent> {\n        return merge(...this.tags.map((tag) => tag.onBlur));\n    }\n\n    /** Combined stream of all of the child tags' remove change events. */\n    get tagRemoveChanges(): Observable<McTagEvent> {\n        return merge(...this.tags.map((tag) => tag.destroyed));\n    }\n\n    /** The array of selected tags inside tag list. */\n    get selected(): McTag[] | McTag {\n        return this.multiple ? this.selectionModel.selected : this.selectionModel.selected[0];\n    }\n\n    get canShowCleaner(): boolean {\n        return this.cleaner && this.tags.length > 0;\n    }\n\n    /** Whether the user should be allowed to select multiple tags. */\n    @Input()\n    get multiple(): boolean {\n        return this._multiple;\n    }\n\n    set multiple(value: boolean) {\n        this._multiple = coerceBooleanProperty(value);\n    }\n\n    /**\n     * A function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     */\n    @Input()\n    get compareWith(): (o1: any, o2: any) => boolean {\n        return this._compareWith;\n    }\n\n    set compareWith(fn: (o1: any, o2: any) => boolean) {\n        this._compareWith = fn;\n\n        if (this.selectionModel) {\n            // A different comparator means the selection could change.\n            this.initializeSelection();\n        }\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    @Input()\n    get value(): any {\n        return this._value;\n    }\n\n    set value(value: any) {\n        this.writeValue(value);\n        this._value = value;\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    get id(): string {\n        return this.tagInput ? this.tagInput.id : this.uid;\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    @Input()\n    get required(): boolean {\n        return this._required;\n    }\n\n    set required(value: boolean) {\n        this._required = coerceBooleanProperty(value);\n\n        this.stateChanges.next();\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    @Input()\n    get placeholder(): string {\n        return this.tagInput ? this.tagInput.placeholder : this._placeholder;\n    }\n\n    set placeholder(value: string) {\n        this._placeholder = value;\n        this.stateChanges.next();\n    }\n\n    /** Whether any tags or the mcTagInput inside of this tag-list has focus. */\n    get focused(): boolean {\n        return (this.tagInput && this.tagInput.focused) || this.hasFocusedTag();\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    get empty(): boolean {\n        return (!this.tagInput || this.tagInput.empty) && this.tags.length === 0;\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    get shouldLabelFloat(): boolean {\n        return !this.empty || this.focused;\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    @Input()\n    get disabled(): boolean {\n        return this.ngControl ? !!this.ngControl.disabled : this._disabled;\n    }\n\n    set disabled(value: boolean) {\n        this._disabled = coerceBooleanProperty(value);\n        this.syncTagsDisabledState();\n    }\n\n    /**\n     * Whether or not this tag list is selectable. When a tag list is not selectable,\n     * the selected states for all the tags inside the tag list are always ignored.\n     */\n    @Input()\n    get selectable(): boolean {\n        return this._selectable;\n    }\n\n    set selectable(value: boolean) {\n        this._selectable = coerceBooleanProperty(value);\n\n        if (this.tags) {\n            this.tags.forEach((tag) => tag.tagListSelectable = this._selectable);\n        }\n    }\n\n    @Input()\n    get tabIndex(): number {\n        return this._tabIndex;\n    }\n\n    set tabIndex(value: number) {\n        this.userTabIndex = value;\n        this._tabIndex = value;\n    }\n\n    private _tabIndex = 0;\n\n    /**\n     * Event that emits whenever the raw value of the tag-list changes. This is here primarily\n     * to facilitate the two-way binding for the `value` input.\n     * @docs-private\n     */\n    @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n\n    uid: string = `mc-tag-list-${nextUniqueId++}`;\n\n    /**\n     * User defined tab index.\n     * When it is not null, use user defined tab index. Otherwise use tabIndex\n     */\n    userTabIndex: number | null = null;\n\n    keyManager: FocusKeyManager<McTag>;\n\n    selectionModel: SelectionModel<McTag>;\n\n    tagChanges = new EventEmitter<any>();\n\n    /** An object used to control when error messages are shown. */\n    @Input() errorStateMatcher: ErrorStateMatcher;\n\n    /** Orientation of the tag list. */\n    @Input('orientation') orientation: 'horizontal' | 'vertical' = 'horizontal';\n\n    /** Event emitted when the selected tag list value has been changed by the user. */\n    @Output() readonly change: EventEmitter<McTagListChange> = new EventEmitter<McTagListChange>();\n\n    @ContentChild('mcTagListCleaner', { static: true }) cleaner: McCleaner;\n\n    /** The tag components contained within this tag list. */\n    @ContentChildren(McTag, {\n        // Need to use `descendants: true`,\n        // Ivy will no longer match indirect descendants if it's left as false.\n        descendants: true\n    }) tags: QueryList<McTag>;\n\n    private _value: any;\n\n    private _required: boolean = false;\n\n    private _placeholder: string;\n\n    private _disabled: boolean = false;\n\n    private _selectable: boolean = true;\n\n    /** The tag input to add more tags */\n    private tagInput: McTagTextControl;\n\n    private _multiple: boolean = false;\n\n    /**\n     * When a tag is destroyed, we store the index of the destroyed tag until the tags\n     * query list notifies about the update. This is necessary because we cannot determine an\n     * appropriate tag that should receive focus until the array of tags updated completely.\n     */\n    private lastDestroyedTagIndex: number | null = null;\n\n    /** Subject that emits when the component has been destroyed. */\n    private destroyed = new Subject<void>();\n\n    /** Subscription to focus changes in the tags. */\n    private tagFocusSubscription: Subscription | null;\n\n    /** Subscription to blur changes in the tags. */\n    private tagBlurSubscription: Subscription | null;\n\n    /** Subscription to selection changes in tags. */\n    private tagSelectionSubscription: Subscription | null;\n\n    /** Subscription to remove changes in tags. */\n    private tagRemoveSubscription: Subscription | null;\n\n    constructor(\n        protected elementRef: ElementRef<HTMLElement>,\n        private changeDetectorRef: ChangeDetectorRef,\n        defaultErrorStateMatcher: ErrorStateMatcher,\n        @Optional() @Inject(NG_VALIDATORS) public rawValidators: Validator[],\n        @Optional() @Inject(MC_VALIDATION) private mcValidation: McValidationOptions,\n        @Optional() private dir: Directionality,\n        @Optional() parentForm: NgForm,\n        @Optional() parentFormGroup: FormGroupDirective,\n        @Optional() @Self() ngControl: NgControl,\n        @Optional() @Self() public ngModel: NgModel,\n        @Optional() @Self() public formControlName: FormControlName\n    ) {\n        super(defaultErrorStateMatcher, parentForm, parentFormGroup, ngControl);\n\n        if (this.ngControl) {\n            this.ngControl.valueAccessor = this;\n        }\n    }\n\n    ngAfterContentInit() {\n        if (this.mcValidation.useValidation) {\n            setMosaicValidation(this);\n        }\n\n        this.keyManager = new FocusKeyManager<McTag>(this.tags)\n            .withVerticalOrientation()\n            .withHorizontalOrientation(this.dir ? this.dir.value : 'ltr');\n\n        if (this.dir) {\n            this.dir.change\n                .pipe(takeUntil(this.destroyed))\n                .subscribe((dir) => this.keyManager.withHorizontalOrientation(dir));\n        }\n\n        // Prevents the tag list from capturing focus and redirecting\n        // it back to the first tag when the user tabs out.\n        this.keyManager.tabOut\n            .pipe(takeUntil(this.destroyed))\n            .subscribe(() => {\n                this._tabIndex = -1;\n\n                setTimeout(() => {\n                    this._tabIndex = this.userTabIndex || 0;\n                    this.changeDetectorRef.markForCheck();\n                });\n            });\n\n        // When the list changes, re-subscribe\n        this.tags.changes\n            .pipe(startWith(null), takeUntil(this.destroyed))\n            .subscribe(() => {\n                if (this.disabled) {\n                    // Since this happens after the content has been\n                    // checked, we need to defer it to the next tick.\n                    Promise.resolve().then(() => { this.syncTagsDisabledState(); });\n                }\n\n                this.resetTags();\n\n                // Reset tags selected/deselected status\n                this.initializeSelection();\n\n                // Check to see if we need to update our tab index\n                this.updateTabIndex();\n\n                // Check to see if we have a destroyed tag and need to refocus\n                this.updateFocusForDestroyedTags();\n\n                // Defer setting the value in order to avoid the \"Expression\n                // has changed after it was checked\" errors from Angular.\n                Promise.resolve().then(() => {\n                    this.tagChanges.emit(this.tags.toArray());\n                    this.stateChanges.next();\n                    this.propagateTagsChanges();\n                });\n            });\n    }\n\n    ngOnInit() {\n        this.selectionModel = new SelectionModel<McTag>(this.multiple, undefined, false);\n        this.stateChanges.next();\n    }\n\n    ngDoCheck() {\n        if (this.ngControl) {\n            // We need to re-evaluate this on every change detection cycle, because there are some\n            // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n            // that whatever logic is in here has to be super lean or we risk destroying the performance.\n            this.updateErrorState();\n        }\n    }\n\n    ngOnDestroy() {\n        this.destroyed.next();\n        this.destroyed.complete();\n        this.stateChanges.complete();\n\n        this.dropSubscriptions();\n    }\n\n    // tslint:disable-next-line:no-empty\n    onTouched = () => {};\n\n    // tslint:disable-next-line:no-empty\n    onChange: (value: any) => void = () => {};\n\n    /** Associates an HTML input element with this tag list. */\n    registerInput(inputElement: McTagTextControl): void {\n        this.tagInput = inputElement;\n\n        // todo need rethink about it\n        if (this.ngControl && inputElement.ngControl?.statusChanges) {\n            inputElement.ngControl.statusChanges\n                .subscribe(() => this.ngControl.control!.setErrors(inputElement.ngControl!.errors));\n        }\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value: any): void {\n        if (this.tags) {\n            this.setSelectionByValue(value, false);\n        }\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn: (value: any) => void): void {\n        this.onChange = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn: () => void): void {\n        this.onTouched = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled: boolean): void {\n        this.disabled = isDisabled;\n        this.stateChanges.next();\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick(event: MouseEvent) {\n        if (!this.originatesFromTag(event)) {\n            this.focus();\n        }\n    }\n\n    /**\n     * Focuses the first non-disabled tag in this tag list, or the associated input when there\n     * are no eligible tags.\n     */\n    focus(): void {\n        if (this.disabled) { return; }\n\n        // TODO: ARIA says this should focus the first `selected` tag if any are selected.\n        // Focus on first element if there's no tagInput inside tag-list\n        if (this.tagInput && this.tagInput.focused) {\n            // do nothing\n        } else if (this.tags.length > 0) {\n            this.keyManager.setFirstItemActive();\n            this.stateChanges.next();\n        } else {\n            this.focusInput();\n            this.stateChanges.next();\n        }\n    }\n\n    /** Attempt to focus an input if we have one. */\n    focusInput() {\n        if (this.tagInput) {\n            this.tagInput.focus();\n        }\n    }\n\n    /**\n     * Pass events to the keyboard manager. Available here for tests.\n     */\n    keydown(event: KeyboardEvent) {\n        const target = event.target as HTMLElement;\n\n        // If they are on an empty input and hit backspace, focus the last tag\n        // tslint:disable-next-line: deprecation\n        if (event.keyCode === BACKSPACE && this.isInputEmpty(target)) {\n            this.keyManager.setLastItemActive();\n            event.preventDefault();\n        } else if (target && target.classList.contains('mc-tag')) {\n            // tslint:disable-next-line: deprecation\n            if (event.keyCode === HOME) {\n                this.keyManager.setFirstItemActive();\n                event.preventDefault();\n            // tslint:disable-next-line: deprecation\n            } else if (event.keyCode === END) {\n                this.keyManager.setLastItemActive();\n                event.preventDefault();\n            } else {\n                this.keyManager.onKeydown(event);\n            }\n\n            this.stateChanges.next();\n        }\n    }\n\n    setSelectionByValue(value: any, isUserInput: boolean = true) {\n        this.clearSelection();\n        this.tags.forEach((tag) => tag.deselect());\n\n        if (Array.isArray(value)) {\n            value.forEach((currentValue) => this.selectValue(currentValue, isUserInput));\n            this.sortValues();\n        } else {\n            const correspondingTag = this.selectValue(value, isUserInput);\n\n            // Shift focus to the active item. Note that we shouldn't do this in multiple\n            // mode, because we don't know what tag the user interacted with last.\n            if (correspondingTag && isUserInput) {\n                this.keyManager.setActiveItem(correspondingTag);\n            }\n        }\n    }\n\n    /** When blurred, mark the field as touched when focus moved outside the tag list. */\n    blur() {\n        if (!this.hasFocusedTag()) {\n            this.keyManager.setActiveItem(-1);\n        }\n\n        if (!this.disabled) {\n            if (this.tagInput) {\n                // If there's a tag input, we should check whether the focus moved to tag input.\n                // If the focus is not moved to tag input, mark the field as touched. If the focus moved\n                // to tag input, do nothing.\n                // Timeout is needed to wait for the focus() event trigger on tag input.\n                setTimeout(() => {\n                    if (!this.focused) {\n                        this.markAsTouched();\n                    }\n                });\n            } else {\n                // If there's no tag input, then mark the field as touched.\n                this.markAsTouched();\n            }\n        }\n    }\n\n    /** Mark the field as touched */\n    markAsTouched() {\n        this.onTouched();\n        this.changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    }\n\n    /**\n     * Check the tab index as you should not be allowed to focus an empty list.\n     */\n    protected updateTabIndex(): void {\n        // If we have 0 tags, we should not allow keyboard focus\n        this._tabIndex = this.userTabIndex || (this.tags.length === 0 ? -1 : 0);\n    }\n\n    /**\n     * If the amount of tags changed, we need to update the\n     * key manager state and focus the next closest tag.\n     */\n    protected updateFocusForDestroyedTags() {\n        if (this.lastDestroyedTagIndex != null) {\n            if (this.tags.length) {\n                const newTagIndex = Math.min(this.lastDestroyedTagIndex, this.tags.length - 1);\n                this.keyManager.setActiveItem(newTagIndex);\n            } else {\n                this.focusInput();\n            }\n        }\n\n        this.lastDestroyedTagIndex = null;\n    }\n\n    private _compareWith = (o1: any, o2: any) => o1 === o2;\n\n    /**\n     * Utility to ensure all indexes are valid.\n     *\n     * @param index The index to be checked.\n     * @returns True if the index is valid for our list of tags.\n     */\n    private isValidIndex(index: number): boolean {\n        return index >= 0 && index < this.tags.length;\n    }\n\n    private isInputEmpty(element: HTMLElement): boolean {\n        if (element && element.nodeName.toLowerCase() === 'input') {\n            const input = element as HTMLInputElement;\n\n            return !input.value;\n        }\n\n        return false;\n    }\n\n    /**\n     * Finds and selects the tag based on its value.\n     * @returns Tag that has the corresponding value.\n     */\n    private selectValue(value: any, isUserInput: boolean = true): McTag | undefined {\n\n        const correspondingTag = this.tags.find((tag) => {\n            return tag.value != null && this._compareWith(tag.value, value);\n        });\n\n        if (correspondingTag) {\n            if (isUserInput) {\n                correspondingTag.selectViaInteraction();\n            } else {\n                correspondingTag.select();\n            }\n\n            this.selectionModel.select(correspondingTag);\n        }\n\n        return correspondingTag;\n    }\n\n    private initializeSelection(): void {\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(() => {\n            if (this.ngControl || this._value) {\n                this.setSelectionByValue(this.ngControl ? this.ngControl.value : this._value, false);\n                this.stateChanges.next();\n            }\n        });\n    }\n\n    /**\n     * Deselects every tag in the list.\n     * @param skip Tag that should not be deselected.\n     */\n    private clearSelection(skip?: McTag): void {\n        this.selectionModel.clear();\n        this.tags.forEach((tag) => {\n            if (tag !== skip) {\n                tag.deselect();\n            }\n        });\n        this.stateChanges.next();\n    }\n\n    /**\n     * Sorts the model values, ensuring that they keep the same\n     * order that they have in the panel.\n     */\n    private sortValues(): void {\n        if (this._multiple) {\n            this.selectionModel.clear();\n\n            this.tags.forEach((tag) => {\n                if (tag.selected) {\n                    this.selectionModel.select(tag);\n                }\n            });\n            this.stateChanges.next();\n        }\n    }\n\n    /** Emits change event to set the model value. */\n    // todo need rethink this method and selection logic\n    private propagateChanges(fallbackValue?: any): void {\n        let valueToEmit: any = null;\n\n        if (Array.isArray(this.selected)) {\n            valueToEmit = this.selected.map((tag) => tag.value);\n        } else {\n            valueToEmit = this.selected ? this.selected.value : fallbackValue;\n        }\n        this._value = valueToEmit;\n        this.change.emit(new McTagListChange(this, valueToEmit));\n        this.valueChange.emit(valueToEmit);\n        this.onChange(valueToEmit);\n        this.changeDetectorRef.markForCheck();\n    }\n\n    private propagateTagsChanges(): void {\n        const valueToEmit: any = this.tags.map((tag) => tag.value);\n\n        this._value = valueToEmit;\n        this.change.emit(new McTagListChange(this, valueToEmit));\n        this.valueChange.emit(valueToEmit);\n        this.onChange(valueToEmit);\n        this.changeDetectorRef.markForCheck();\n    }\n\n    private resetTags() {\n        this.dropSubscriptions();\n        this.listenToTagsFocus();\n        this.listenToTagsSelection();\n        this.listenToTagsRemoved();\n    }\n\n    private dropSubscriptions() {\n        if (this.tagFocusSubscription) {\n            this.tagFocusSubscription.unsubscribe();\n            this.tagFocusSubscription = null;\n        }\n\n        if (this.tagBlurSubscription) {\n            this.tagBlurSubscription.unsubscribe();\n            this.tagBlurSubscription = null;\n        }\n\n        if (this.tagSelectionSubscription) {\n            this.tagSelectionSubscription.unsubscribe();\n            this.tagSelectionSubscription = null;\n        }\n\n        if (this.tagRemoveSubscription) {\n            this.tagRemoveSubscription.unsubscribe();\n            this.tagRemoveSubscription = null;\n        }\n    }\n\n    /** Listens to user-generated selection events on each tag. */\n    private listenToTagsSelection(): void {\n        this.tagSelectionSubscription = this.tagSelectionChanges.subscribe((event) => {\n            if (event.source.selected) {\n                this.selectionModel.select(event.source);\n            } else {\n                this.selectionModel.deselect(event.source);\n            }\n\n            // For single selection tag list, make sure the deselected value is unselected.\n            if (!this.multiple) {\n                this.tags.forEach((tag) => {\n                    if (!this.selectionModel.isSelected(tag) && tag.selected) {\n                        tag.deselect();\n                    }\n                });\n            }\n\n            if (event.isUserInput) {\n                this.propagateChanges();\n            }\n        });\n    }\n\n    /** Listens to user-generated selection events on each tag. */\n    private listenToTagsFocus(): void {\n        this.tagFocusSubscription = this.tagFocusChanges.subscribe((event) => {\n            const tagIndex: number = this.tags.toArray().indexOf(event.tag);\n\n            if (this.isValidIndex(tagIndex)) {\n                this.keyManager.updateActiveItem(tagIndex);\n            }\n\n            this.stateChanges.next();\n        });\n\n        this.tagBlurSubscription = this.tagBlurChanges.subscribe(() => {\n            this.blur();\n            this.stateChanges.next();\n        });\n    }\n\n    private listenToTagsRemoved(): void {\n        this.tagRemoveSubscription = this.tagRemoveChanges.subscribe((event) => {\n            const tag = event.tag;\n            const tagIndex = this.tags.toArray().indexOf(event.tag);\n\n            // In case the tag that will be removed is currently focused, we temporarily store\n            // the index in order to be able to determine an appropriate sibling tag that will\n            // receive focus.\n            if (this.isValidIndex(tagIndex) && tag.hasFocus) {\n                this.lastDestroyedTagIndex = tagIndex;\n            } else if (this.isValidIndex(tagIndex) && !tag.hasFocus) {\n                this.focusInput();\n            }\n        });\n    }\n\n    /** Checks whether an event comes from inside a tag element. */\n    private originatesFromTag(event: Event): boolean {\n        let currentElement = event.target as HTMLElement | null;\n\n        while (currentElement && currentElement !== this.elementRef.nativeElement) {\n            if (currentElement.classList.contains('mc-tag')) { return true; }\n\n            currentElement = currentElement.parentElement;\n        }\n\n        return false;\n    }\n\n    /** Checks whether any of the tags is focused. */\n    private hasFocusedTag() {\n        return this.tags.some((tag) => tag.hasFocus);\n    }\n\n    /** Syncs the list's disabled state with the individual tags. */\n    private syncTagsDisabledState() {\n        if (this.tags) {\n            this.tags.forEach((tag) => {\n                tag.disabled = this._disabled;\n            });\n        }\n    }\n}\n\n","import { PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { ENTER } from '@ptsecurity/cdk/keycodes';\n\nimport { MC_TAGS_DEFAULT_OPTIONS, McTagsDefaultOptions } from './tag-default-options';\nimport { McTagInput } from './tag-input';\nimport { McTagList } from './tag-list.component';\nimport { McTag, McTagAvatar, McTagRemove, McTagTrailingIcon } from './tag.component';\n\n\n@NgModule({\n    imports: [CommonModule, PlatformModule],\n    exports: [\n        McTagList,\n        McTag,\n        McTagInput,\n        McTagTrailingIcon,\n        McTagAvatar,\n        McTagRemove\n    ],\n    declarations: [\n        McTagList,\n        McTag,\n        McTagInput,\n        McTagTrailingIcon,\n        McTagAvatar,\n        McTagRemove\n    ],\n    providers: [{\n        provide: MC_TAGS_DEFAULT_OPTIONS,\n        // tslint:disable-next-line: no-object-literal-type-assertion\n        useValue: { separatorKeyCodes: [ENTER] } as McTagsDefaultOptions\n    }]\n})\nexport class McTagsModule {}\n"]}
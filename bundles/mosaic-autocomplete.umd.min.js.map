{"version":3,"file":"mosaic-autocomplete.umd.min.js","sources":["../../src/lib/autocomplete/autocomplete.component.ts","../../src/lib/autocomplete/autocomplete-trigger.directive.ts","../../src/lib/autocomplete/autocomplete-origin.directive.ts","../../src/lib/autocomplete/autocomplete.module.ts"],"sourcesContent":["import {\n    AfterContentInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    InjectionToken,\n    Input,\n    Output,\n    QueryList,\n    TemplateRef,\n    ViewChild,\n    ViewEncapsulation\n} from '@angular/core';\nimport { ActiveDescendantKeyManager } from '@ptsecurity/cdk/a11y';\nimport { coerceBooleanProperty } from '@ptsecurity/cdk/coercion';\nimport { MC_OPTION_PARENT_COMPONENT, McOptgroup, McOption } from '@ptsecurity/mosaic/core';\n\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet uniqueAutocompleteIdCounter = 0;\n\nexport class McAutocompleteSelectedEvent {\n    constructor(public source: McAutocomplete, public option: McOption) {}\n}\n\n/** Default `mc-autocomplete` options that can be overridden. */\n// tslint:disable-next-line naming-convention\nexport interface McAutocompleteDefaultOptions {\n    /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n    autoActiveFirstOption?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mc-autocomplete`. */\nexport const MC_AUTOCOMPLETE_DEFAULT_OPTIONS =\n    new InjectionToken<McAutocompleteDefaultOptions>('mc-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n    });\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY(): McAutocompleteDefaultOptions {\n    return { autoActiveFirstOption: true };\n}\n\n@Component({\n    selector: 'mc-autocomplete',\n    exportAs: 'mcAutocomplete',\n    templateUrl: 'autocomplete.html',\n    styleUrls: ['autocomplete.css'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    host: { class: 'mc-autocomplete' },\n    providers: [\n        { provide: MC_OPTION_PARENT_COMPONENT, useExisting: McAutocomplete }\n    ]\n})\nexport class McAutocomplete implements AfterContentInit {\n    /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n    id: string = `mc-autocomplete-${uniqueAutocompleteIdCounter++}`;\n\n    /** Manages active item in option list based on key events. */\n    keyManager: ActiveDescendantKeyManager<McOption>;\n\n    /** Whether the autocomplete panel should be visible, depending on option length. */\n    showPanel: boolean = false;\n\n    @ViewChild(TemplateRef) template: TemplateRef<any>;\n\n    @ViewChild('panel') panel: ElementRef;\n\n    @ContentChildren(McOption, { descendants: true }) options: QueryList<McOption>;\n\n    @ContentChildren(McOptgroup) optionGroups: QueryList<McOptgroup>;\n\n    /** Function that maps an option's control value to its display value in the trigger. */\n    @Input() displayWith: ((value: any) => string) | null = null;\n\n    /**\n     * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n     * match the width of its host.\n     */\n    @Input() panelWidth: string | number;\n\n    /** Event that is emitted whenever an option from the list is selected. */\n    @Output() readonly optionSelected: EventEmitter<McAutocompleteSelectedEvent> =\n        new EventEmitter<McAutocompleteSelectedEvent>();\n\n    /** Event that is emitted when the autocomplete panel is opened. */\n    @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n    /** Event that is emitted when the autocomplete panel is closed. */\n    @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n    /**\n     * Takes classes set on the host mc-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    get classList() {\n        return this._classList;\n    }\n\n    @Input('class')\n    set classList(value: string) {\n        if (value && value.length) {\n            value.split(' ')\n                .forEach((className) => this._classList[className.trim()] = true);\n\n            this.elementRef.nativeElement.className = '';\n        }\n    }\n\n    private _classList: any = {};\n\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MC_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    @Input()\n    get autoActiveFirstOption(): boolean {\n        return this._autoActiveFirstOption;\n    }\n\n    set autoActiveFirstOption(value: boolean) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n\n    private _autoActiveFirstOption: boolean;\n\n    get isOpen(): boolean {\n        return this._isOpen && this.showPanel;\n    }\n\n    set isOpen(value: boolean) {\n        this._isOpen = value;\n    }\n\n    private _isOpen: boolean = false;\n\n    constructor(\n        private changeDetectorRef: ChangeDetectorRef,\n        private elementRef: ElementRef<HTMLElement>,\n        @Inject(MC_AUTOCOMPLETE_DEFAULT_OPTIONS) defaults: McAutocompleteDefaultOptions\n    ) {\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n    }\n\n    ngAfterContentInit() {\n        this.keyManager = new ActiveDescendantKeyManager<McOption>(this.options);\n        this.setVisibility();\n    }\n\n    setScrollTop(scrollTop: number): void {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n\n    getScrollTop(): number {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n\n    setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._classList['mc-autocomplete_visible'] = this.showPanel;\n        this._classList['mc-autocomplete_hidden'] = !this.showPanel;\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    emitSelectEvent(option: McOption): void {\n        const event = new McAutocompleteSelectedEvent(this, option);\n\n        this.optionSelected.emit(event);\n    }\n\n    onKeydown(event: KeyboardEvent): any {\n        this.keyManager.onKeydown(event);\n    }\n}\n\n","import { DOCUMENT } from '@angular/common';\nimport {\n    ChangeDetectorRef,\n    Directive,\n    ElementRef,\n    forwardRef,\n    Host,\n    Inject,\n    InjectionToken,\n    Input,\n    NgZone,\n    OnDestroy,\n    Optional,\n    ViewContainerRef\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Directionality } from '@ptsecurity/cdk/bidi';\nimport { coerceBooleanProperty } from '@ptsecurity/cdk/coercion';\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@ptsecurity/cdk/keycodes';\nimport {\n    FlexibleConnectedPositionStrategy,\n    Overlay,\n    OverlayConfig,\n    OverlayRef,\n    IPositionStrategy,\n    IScrollStrategy, IConnectedPosition\n} from '@ptsecurity/cdk/overlay';\nimport { TemplatePortal } from '@ptsecurity/cdk/portal';\nimport { ViewportRuler } from '@ptsecurity/cdk/scrolling';\nimport {\n    countGroupLabelsBeforeOption,\n    getOptionScrollPosition,\n    McOption,\n    McOptionSelectionChange\n} from '@ptsecurity/mosaic/core';\nimport { McFormField } from '@ptsecurity/mosaic/form-field';\nimport { Subscription, defer, fromEvent, merge, of as observableOf, Subject, Observable } from 'rxjs';\nimport { filter, take, switchMap, delay, tap, map } from 'rxjs/operators';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n\n/** The height of each autocomplete option. */\nexport const AUTOCOMPLETE_OPTION_HEIGHT = 32;\n\n/** The total height of the autocomplete panel. */\nexport const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n\nexport const AUTOCOMPLETE_BORDER_WIDTH: number = 2;\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY =\n    new InjectionToken<() => IScrollStrategy>('mc-autocomplete-scroll-strategy');\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => IScrollStrategy {\n    return () => overlay.scrollStrategies.reposition();\n}\n\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MC_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McAutocompleteTrigger),\n    multi: true\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMcAutocompleteMissingPanelError(): Error {\n    return Error('Attempting to open an undefined instance of `mc-autocomplete`. ' +\n        'Make sure that the id passed to the `mcAutocomplete` is correct and that ' +\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\n\n\n@Directive({\n    selector: `input[mcAutocomplete], textarea[mcAutocomplete]`,\n    host: {\n        class: 'mc-autocomplete-trigger',\n        '[attr.autocomplete]': 'autocompleteAttribute',\n        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n        // a little earlier. This avoids issues where IE delays the focusing of the input.\n        '(focusin)': 'handleFocus()',\n        '(blur)': 'onTouched()',\n        '(input)': 'handleInput($event)',\n        '(keydown)': 'handleKeydown($event)',\n        '(click)': 'handleClick($event)'\n    },\n    exportAs: 'mcAutocompleteTrigger',\n    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n})\nexport class McAutocompleteTrigger implements ControlValueAccessor, OnDestroy {\n    // @ts-ignore\n    readonly optionSelections: Observable<McOptionSelectionChange> = defer(() => {\n        if (this.autocomplete && this.autocomplete.options) {\n            return merge(...this.autocomplete.options.map((option) => option.onSelectionChange));\n        }\n\n        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n        return this.zone.onStable\n            .asObservable()\n            .pipe(take(1), switchMap(() => this.optionSelections));\n    });\n\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption(): McOption | null {\n        if (this.autocomplete && this.autocomplete.keyManager) {\n            return this.autocomplete.keyManager.activeItem;\n        }\n\n        return null;\n    }\n\n    get panelOpen(): boolean {\n        return this.overlayAttached && this.autocomplete.showPanel;\n    }\n\n    /** The autocomplete panel to be attached to this trigger. */\n    @Input('mcAutocomplete') autocomplete: McAutocomplete;\n\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     */\n    @Input('mcAutocompleteConnectedTo') connectedTo: McAutocompleteOrigin;\n\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * @docs-private\n     */\n    @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    @Input('mcAutocompleteDisabled')\n    get autocompleteDisabled(): boolean {\n        return this._autocompleteDisabled;\n    }\n\n    set autocompleteDisabled(value: boolean) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n\n    private _autocompleteDisabled = false;\n\n    private overlayAttached: boolean = false;\n\n    private overlayRef: OverlayRef | null;\n\n    private portal: TemplatePortal;\n\n    private componentDestroyed = false;\n\n    private scrollStrategy: () => IScrollStrategy;\n\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n    private previousValue: string | number | null;\n\n    /** Strategy that is used to position the panel. */\n    private positionStrategy: FlexibleConnectedPositionStrategy;\n\n    /** The subscription for closing actions (some are bound to document). */\n    private closingActionsSubscription: Subscription;\n\n    /** Subscription to viewport size changes. */\n    private viewportSubscription = Subscription.EMPTY;\n\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     */\n    private canOpenOnNextFocus = true;\n\n    /** Stream of keyboard events that can close the panel. */\n    private readonly closeKeyEventStream = new Subject<void>();\n\n    constructor(\n        private elementRef: ElementRef<HTMLInputElement>,\n        private viewContainerRef: ViewContainerRef,\n        private changeDetectorRef: ChangeDetectorRef,\n        private overlay: Overlay,\n        private zone: NgZone,\n        @Inject(MC_AUTOCOMPLETE_SCROLL_STRATEGY) scrollStrategy: any,\n        @Optional() private dir: Directionality,\n        @Optional() @Host() private formField: McFormField,\n        @Optional() @Inject(DOCUMENT) private document: any,\n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        private viewportRuler?: ViewportRuler\n    ) {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            zone.runOutsideAngular(() => {\n                window.addEventListener('blur', this.windowBlurHandler);\n            });\n        }\n\n        this.scrollStrategy = scrollStrategy;\n    }\n\n    ngOnDestroy() {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this.windowBlurHandler);\n        }\n\n        this.viewportSubscription.unsubscribe();\n        this.componentDestroyed = true;\n        this.destroyPanel();\n        this.closeKeyEventStream.complete();\n    }\n\n    /** `View -> model callback called when value changes` */\n    // tslint:disable-next-line no-empty\n    onChange: (value: any) => void = () => {};\n\n    /** `View -> model callback called when autocomplete has been touched` */\n    // tslint:disable-next-line no-empty\n    onTouched: () => void = () => {};\n\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void {\n        this.attachOverlay();\n    }\n\n    closePanel(): void {\n        if (!this.overlayAttached) { return; }\n\n        if (this.panelOpen) {\n            this.autocomplete.closed.emit();\n        }\n\n        this.autocomplete.isOpen = this.overlayAttached = false;\n\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n            this.overlayRef.detach();\n            this.closingActionsSubscription.unsubscribe();\n        }\n\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this.componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this.changeDetectorRef.detectChanges();\n        }\n    }\n\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition(): void {\n        if (this.overlayAttached) {\n            this.overlayRef!.updatePosition();\n        }\n    }\n\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions(): Observable<McOptionSelectionChange | null> {\n        return merge(\n            this.optionSelections,\n            this.autocomplete.keyManager.tabOut.pipe(filter(() => this.overlayAttached)),\n            this.closeKeyEventStream,\n            this.getOutsideClickStream(),\n            this.overlayRef ?\n                this.overlayRef.detachments().pipe(filter(() => this.overlayAttached)) :\n                observableOf()\n        ).pipe(\n            // Normalize the output so we return a consistent type.\n            map((event) => event instanceof McOptionSelectionChange ? event : null)\n        );\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value: any): void {\n        Promise.resolve(null).then(() => this.setTriggerValue(value));\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn: (value: any) => {}): void {\n        this.onChange = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn: () => {}) {\n        this.onTouched = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled: boolean) {\n        this.elementRef.nativeElement.disabled = isDisabled;\n    }\n\n    handleKeydown(event: KeyboardEvent): void {\n        // tslint:disable-next-line deprecation\n        const keyCode = event.keyCode;\n\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE) {\n            event.preventDefault();\n        }\n\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n            this.activeOption.selectViaInteraction();\n            this.resetActiveItem();\n            event.preventDefault();\n        } else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete.keyManager.activeItem;\n\n            if (this.panelOpen || keyCode === TAB) {\n                this.autocomplete.onKeydown(event);\n            } else if (keyCode === DOWN_ARROW && this.canOpen()) {\n                this.openPanel();\n            }\n\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n            if (isArrowKey || this.autocomplete.keyManager.activeItem !== prevActiveItem) {\n                this.scrollToOption();\n            }\n        }\n    }\n\n    handleInput(event: KeyboardEvent): void {\n        const target = event.target as HTMLInputElement;\n        let value: number | string | null = target.value;\n\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value === '' ? null : parseFloat(value);\n        }\n\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this.previousValue !== value) {\n            this.previousValue = value;\n            this.onChange(value);\n\n            if (this.canOpen() && this.document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n\n    handleFocus(): void {\n        if (!this.canOpenOnNextFocus) {\n            this.canOpenOnNextFocus = true;\n        } else if (this.canOpen()) {\n            this.previousValue = this.elementRef.nativeElement.value;\n            this.attachOverlay();\n        }\n    }\n\n    handleClick($event: MouseEvent) {\n        if (this.canOpen() && this.document.activeElement === $event.target) {\n            this.openPanel();\n        }\n    }\n\n    /** Stream of clicks outside of the autocomplete panel. */\n    private getOutsideClickStream(): Observable<any> {\n        if (!this.document) { return observableOf(null); }\n\n        return fromEvent<MouseEvent>(this.document, 'click')\n            .pipe(filter((event) => {\n                const clickTarget = event.target as HTMLElement;\n                const formField = this.formField ?\n                    this.formField._elementRef.nativeElement : null;\n\n                return this.overlayAttached &&\n                    clickTarget !== this.elementRef.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!!this.overlayRef && !this.overlayRef.overlayElement.contains(clickTarget));\n            }));\n    }\n\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     */\n    private windowBlurHandler = () => {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        this.canOpenOnNextFocus = this.document.activeElement !== this.elementRef.nativeElement || this.panelOpen;\n    }\n\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     */\n    private scrollToOption(): void {\n        const index = this.autocomplete.keyManager.activeItemIndex || 0;\n        const labelCount = countGroupLabelsBeforeOption(index,\n            this.autocomplete.options, this.autocomplete.optionGroups);\n\n        const newScrollPosition = getOptionScrollPosition(\n            index + labelCount,\n            AUTOCOMPLETE_OPTION_HEIGHT,\n            this.autocomplete.getScrollTop(),\n            AUTOCOMPLETE_PANEL_HEIGHT\n        );\n\n        this.autocomplete.setScrollTop(newScrollPosition);\n    }\n\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private subscribeToClosingActions(): Subscription {\n        const firstStable = this.zone.onStable.asObservable()\n            .pipe(take(1));\n        const optionChanges = this.autocomplete.options.changes\n            .pipe(\n                tap(() => this.positionStrategy.reapplyLastPosition()),\n                // Defer emitting to the stream until the next tick, because changing\n                // bindings in here will cause \"changed after checked\" errors.\n                delay(0)\n            );\n\n        // When the zone is stable initially, and when the option list changes...\n        return merge(firstStable, optionChanges)\n            .pipe(\n                // create a new stream of panelClosingActions, replacing any previous streams\n                // that were created, and flatten it so our stream only emits closing events...\n                switchMap(() => {\n                    this.resetActiveItem();\n                    this.autocomplete.setVisibility();\n\n                    if (this.panelOpen) {\n                        this.overlayRef!.updatePosition();\n                    }\n\n                    return this.panelClosingActions;\n                }),\n                // when the first closing event occurs...\n                take(1)\n            )\n            // set the value, close the panel, and complete.\n            .subscribe((event) => this.setValueAndClose(event));\n    }\n\n    /** Destroys the autocomplete suggestion panel. */\n    private destroyPanel(): void {\n        if (this.overlayRef) {\n            this.closePanel();\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n\n    private setTriggerValue(value: any): void {\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n            this.autocomplete.displayWith(value) :\n            value;\n\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        const inputValue = toDisplay != null ? toDisplay : '';\n\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this.formField) {\n            this.formField._control.value = inputValue;\n        } else {\n            this.elementRef.nativeElement.value = inputValue;\n        }\n\n        this.previousValue = inputValue;\n    }\n\n    /** This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    private setValueAndClose(event: McOptionSelectionChange | null): void {\n        if (event && event.source) {\n            this.clearPreviousSelectedOption(event.source);\n            this.setTriggerValue(event.source.value);\n            this.onChange(event.source.value);\n            this.elementRef.nativeElement.focus();\n\n            this.autocomplete.emitSelectEvent(event.source);\n        }\n\n        this.closePanel();\n    }\n\n    /** Clear any previous selected option and emit a selection change event for this option */\n    private clearPreviousSelectedOption(skip: McOption) {\n        this.autocomplete.options.forEach((option) => {\n            if (option !== skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n\n    private attachOverlay(): void {\n        if (!this.autocomplete) {\n            throw getMcAutocompleteMissingPanelError();\n        }\n\n        let overlayRef = this.overlayRef;\n\n        if (!overlayRef) {\n            this.portal = new TemplatePortal(this.autocomplete.template, this.viewContainerRef);\n            overlayRef = this.overlay.create(this.getOverlayConfig());\n            this.overlayRef = overlayRef;\n\n            // Use the `keydownEvents` in order to take advantage of\n            // the overlay event targeting provided by the CDK overlay.\n            overlayRef.keydownEvents().subscribe((event) => {\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                // tslint:disable-next-line deprecation\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\n                    this.resetActiveItem();\n                    this.closeKeyEventStream.next();\n                }\n            });\n\n            if (this.viewportRuler) {\n                this.viewportSubscription = this.viewportRuler.change().subscribe(() => {\n                    if (this.panelOpen && overlayRef) {\n                        overlayRef.updateSize({ width: this.getPanelWidth() });\n                    }\n                });\n            }\n        } else {\n            const position = overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;\n\n            // Update the trigger, panel width and direction, in case anything has changed.\n            position.setOrigin(this.getConnectedElement());\n            overlayRef.updateSize({ width: this.getPanelWidth() });\n        }\n\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this.portal);\n            this.closingActionsSubscription = this.subscribeToClosingActions();\n        }\n\n        const wasOpen = this.panelOpen;\n\n        this.autocomplete.setVisibility();\n        this.autocomplete.isOpen = this.overlayAttached = true;\n\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n\n    private getOverlayConfig(): OverlayConfig {\n        return new OverlayConfig({\n            positionStrategy: this.getOverlayPosition(),\n            scrollStrategy: this.scrollStrategy(),\n            width: this.getPanelWidth(),\n            direction: this.dir\n        });\n    }\n\n    private getOverlayPosition(): IPositionStrategy {\n        this.positionStrategy = this.overlay.position()\n            .flexibleConnectedTo(this.getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withPositions([\n                {\n                    originX: 'start',\n                    originY: 'bottom',\n                    overlayX: 'start',\n                    overlayY: 'top'\n                },\n                {\n                    originX: 'start',\n                    originY: 'top',\n                    overlayX: 'start',\n                    overlayY: 'bottom',\n\n                    // The overlay edge connected to the trigger should have squared corners, while\n                    // the opposite end has rounded corners. We apply a CSS class to swap the\n                    // border-radius based on the overlay position.\n                    panelClass: 'mc-autocomplete-panel-above'\n                }\n            ] as IConnectedPosition[]);\n\n        return this.positionStrategy;\n    }\n\n    private getConnectedElement(): ElementRef {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n\n        return this.formField ? this.formField.getConnectedOverlayOrigin() : this.elementRef;\n    }\n\n    private getPanelWidth(): number | string {\n        return this.autocomplete.panelWidth || this.getHostWidth() - AUTOCOMPLETE_BORDER_WIDTH;\n    }\n\n    private getHostWidth(): number {\n        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     */\n    private resetActiveItem(): void {\n        this.autocomplete.keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n    }\n\n    private canOpen(): boolean {\n        const element = this.elementRef.nativeElement;\n\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n}\n","import { Directive, ElementRef } from '@angular/core';\n\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n    selector: '[mcAutocompleteOrigin]',\n    exportAs: 'mcAutocompleteOrigin'\n})\nexport class McAutocompleteOrigin {\n    constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { OverlayModule } from '@ptsecurity/cdk/overlay';\nimport { McOptionModule, McCommonModule } from '@ptsecurity/mosaic/core';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport {\n    McAutocompleteTrigger,\n    MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER\n} from './autocomplete-trigger.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n@NgModule({\n    imports: [McOptionModule, OverlayModule, McCommonModule, CommonModule],\n    exports: [\n        McAutocomplete,\n        McOptionModule,\n        McAutocompleteTrigger,\n        McAutocompleteOrigin,\n        McCommonModule\n    ],\n    declarations: [McAutocomplete, McAutocompleteTrigger, McAutocompleteOrigin],\n    providers: [MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]\n})\nexport class McAutocompleteModule {}\n"],"names":["MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","getMcAutocompleteMissingPanelError","Error","uniqueAutocompleteIdCounter","McAutocompleteSelectedEvent","source","option","this","MC_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","McAutocomplete","changeDetectorRef","elementRef","defaults","id","showPanel","displayWith","optionSelected","EventEmitter","opened","closed","_classList","_isOpen","_autoActiveFirstOption","Object","defineProperty","prototype","value","_this","length","split","forEach","className","trim","nativeElement","coerceBooleanProperty","ngAfterContentInit","keyManager","ActiveDescendantKeyManager","options","setVisibility","setScrollTop","scrollTop","panel","getScrollTop","markForCheck","emitSelectEvent","event","emit","onKeydown","type","Component","args","selector","exportAs","template","styles","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","host","class","providers","provide","MC_OPTION_PARENT_COMPONENT","useExisting","ChangeDetectorRef","ElementRef","undefined","decorators","Inject","ViewChild","TemplateRef","ContentChildren","McOption","descendants","optionGroups","McOptgroup","Input","panelWidth","Output","classList","McAutocompleteOrigin","Directive","MC_AUTOCOMPLETE_SCROLL_STRATEGY","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","McAutocompleteTrigger","multi","viewContainerRef","zone","scrollStrategy","dir","formField","document","viewportRuler","optionSelections","defer","autocomplete","merge","apply","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","autocompleteAttribute","_autocompleteDisabled","overlayAttached","componentDestroyed","viewportSubscription","Subscription","EMPTY","canOpenOnNextFocus","closeKeyEventStream","Subject","onChange","onTouched","windowBlurHandler","activeElement","panelOpen","window","runOutsideAngular","addEventListener","activeItem","ngOnDestroy","removeEventListener","unsubscribe","destroyPanel","complete","openPanel","attachOverlay","closePanel","isOpen","overlayRef","hasAttached","detach","closingActionsSubscription","detectChanges","updatePosition","tabOut","filter","getOutsideClickStream","detachments","observableOf","McOptionSelectionChange","writeValue","Promise","resolve","then","setTriggerValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","selectViaInteraction","resetActiveItem","prevActiveItem","TAB","DOWN_ARROW","canOpen","isArrowKey","UP_ARROW","scrollToOption","handleInput","target","parseFloat","previousValue","handleFocus","handleClick","$event","fromEvent","clickTarget","_elementRef","contains","overlayElement","index","activeItemIndex","labelCount","countGroupLabelsBeforeOption","newScrollPosition","getOptionScrollPosition","subscribeToClosingActions","firstStable","optionChanges","changes","tap","positionStrategy","reapplyLastPosition","delay","panelClosingActions","subscribe","setValueAndClose","dispose","toDisplay","inputValue","_control","clearPreviousSelectedOption","focus","skip","selected","deselect","getConfig","setOrigin","getConnectedElement","updateSize","width","getPanelWidth","portal","TemplatePortal","create","getOverlayConfig","keydownEvents","altKey","next","change","attach","wasOpen","OverlayConfig","getOverlayPosition","direction","position","flexibleConnectedTo","withFlexibleDimensions","withPush","withPositions","originX","originY","overlayX","overlayY","panelClass","connectedTo","getConnectedOverlayOrigin","getHostWidth","getBoundingClientRect","setActiveItem","element","readOnly","[attr.autocomplete]","(focusin)","(blur)","(input)","(keydown)","(click)","ViewContainerRef","NgZone","Directionality","Optional","McFormField","Host","DOCUMENT","ViewportRuler","autocompleteDisabled","McAutocompleteModule","NgModule","imports","McOptionModule","OverlayModule","McCommonModule","CommonModule","exports","declarations"],"mappings":"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"}
{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@ptsecurity/mosaic/radio/radio.component.ts","ng://@ptsecurity/mosaic/radio/radio.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","nextUniqueId","source","value","_elementRef","McRadioGroupMixinBase","mixinDisabled","McRadioGroupBase","MC_RADIO_GROUP_CONTROL_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","McRadioGroup","multi","elementRef","_changeDetector","_this","_super","call","change","EventEmitter","_value","_name","_selected","isInitialized","_labelPosition","_disabled","_required","controlValueAccessorChangeFn","onTouched","defineProperty","updateRadioButtonNames","v","markRadiosForCheck","newValue","updateSelectedRadioFromValue","checkSelectedRadioButton","selected","toBoolean","checked","ngAfterContentInit","touch","emitChangeEvent","emit","McRadioChange","radios","forEach","radio","markForCheck","writeValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","name","isAlreadySelected","Directive","args","selector","exportAs","host","role","class","providers","ElementRef","ChangeDetectorRef","Input","Output","ContentChildren","McRadioButton","descendants","McRadioButtonMixinBase","mixinColor","mixinTabIndex","McRadioButtonBase","radioGroup","focusMonitor","_radioDispatcher","isFocused","uniqueId","_checked","removeUniqueSelectionListener","id","listen","newCheckedState","notify","newDisabledState","required","labelPosition","ngOnInit","ngAfterViewInit","monitor","subscribe","focusOrigin","ngOnDestroy","stopMonitoring","focus","inputElement","nativeElement","onInputClick","event","stopPropagation","onInputChange","groupValueChanged","Component","template","inputs","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","[attr.id]","[class.mc-selected]","[class.mc-disabled]","decorators","type","Optional","FocusMonitor","UniqueSelectionDispatcher","ViewChild","static","McRadioModule","NgModule","imports","CommonModule","A11yModule","McCommonModule","exports","declarations"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { FocusMonitor } from '@angular/cdk/a11y';\nimport { UniqueSelectionDispatcher } from '@angular/cdk/collections';\nimport {\n    AfterContentInit,\n    AfterViewInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    Directive,\n    ElementRef,\n    EventEmitter,\n    forwardRef,\n    Input,\n    OnDestroy,\n    OnInit,\n    Optional,\n    Output,\n    QueryList,\n    ViewChild,\n    ViewEncapsulation\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport {\n    CanColor,\n    CanColorCtor,\n    CanDisable,\n    CanDisableCtor,\n    HasTabIndex,\n    HasTabIndexCtor,\n    mixinColor,\n    mixinDisabled,\n    mixinTabIndex,\n    toBoolean\n} from '@ptsecurity/mosaic/core';\n\n\n// Increasing integer for generating unique ids for radio components.\nlet nextUniqueId = 0;\n\n/** Change event object emitted by McRadio. */\nexport class McRadioChange {\n    constructor(\n        /** The McRadioButton that emits the change event. */\n        public source: McRadioButton,\n        /** The value of the McRadioButton. */\n        public value: any) {}\n}\n\n// Boilerplate for applying mixins to McRadioGroup.\n/** @docs-private */\nexport class McRadioGroupBase {\n    // tslint:disable-next-line:naming-convention\n    constructor(public _elementRef: ElementRef) {}\n}\n// tslint:disable-next-line:naming-convention\nexport const McRadioGroupMixinBase: CanDisableCtor & typeof McRadioGroupBase = mixinDisabled(McRadioGroupBase);\n\n/**\n * Provider Expression that allows mc-radio-group to register as a ControlValueAccessor. This\n * allows it to support [(ngModel)] and ngControl.\n * @docs-private\n */\nexport const MC_RADIO_GROUP_CONTROL_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McRadioGroup),\n    multi: true\n};\n\n@Directive({\n    selector: 'mc-radio-group',\n    exportAs: 'mcRadioGroup',\n    host: {\n        role: 'radiogroup',\n        class: 'mc-radio-group'\n    },\n    providers: [MC_RADIO_GROUP_CONTROL_VALUE_ACCESSOR]\n})\nexport class McRadioGroup extends McRadioGroupMixinBase\n    implements AfterContentInit, ControlValueAccessor, CanDisable {\n\n    /** Name of the radio button group. All radio buttons inside this group will use this name. */\n    @Input()\n    get name(): string { return this._name; }\n    set name(value: string) {\n        this._name = value;\n        this.updateRadioButtonNames();\n    }\n\n    /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n    @Input()\n    get labelPosition(): 'before' | 'after' {\n        return this._labelPosition;\n    }\n    set labelPosition(v) {\n        this._labelPosition = v === 'before' ? 'before' : 'after';\n        this.markRadiosForCheck();\n    }\n\n    /** Value of the radio button. */\n    @Input()\n    get value(): any { return this._value; }\n    set value(newValue: any) {\n        if (this._value !== newValue) {\n            // Set this before proceeding to ensure no circular loop occurs with selection.\n            this._value = newValue;\n\n            this.updateSelectedRadioFromValue();\n            this.checkSelectedRadioButton();\n        }\n    }\n\n    /** Whether the radio button is selected. */\n    @Input()\n    get selected() { return this._selected; }\n    set selected(selected: McRadioButton | null) {\n        this._selected = selected;\n        this.value = selected ? selected.value : null;\n        this.checkSelectedRadioButton();\n    }\n\n    /** Whether the radio group is disabled */\n    @Input()\n    get disabled(): boolean { return this._disabled; }\n    set disabled(value) {\n        this._disabled = toBoolean(value);\n        this.markRadiosForCheck();\n    }\n\n    /** Whether the radio group is required */\n    @Input()\n    get required(): boolean { return this._required; }\n    set required(value: boolean) {\n        this._required = toBoolean(value);\n        this.markRadiosForCheck();\n    }\n\n    /**\n     * Event emitted when the group value changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * a radio button (the same behavior as `<input type-\"radio\">`).\n     */\n    @Output() readonly change: EventEmitter<McRadioChange> = new EventEmitter<McRadioChange>();\n\n    /** Child radio buttons. */\n    @ContentChildren(forwardRef(() => McRadioButton), { descendants: true })\n    radios: QueryList<McRadioButton>;\n\n    /**\n     * Selected value for group. Should equal the value of the selected radio button if there *is*\n     * a corresponding radio button with a matching value. If there is *not* such a corresponding\n     * radio button, this value persists to be applied in case a new radio button is added with a\n     * matching value.\n     */\n    private _value: any = null;\n\n    /** The HTML name attribute applied to radio buttons in this group. */\n    private _name: string = `mc-radio-group-${nextUniqueId++}`;\n\n    /** The currently selected radio button. Should match value. */\n    private _selected: McRadioButton | null = null;\n\n    /** Whether the `value` has been set to its initial value. */\n    private isInitialized: boolean = false;\n\n    /** Whether the labels should appear after or before the radio-buttons. Defaults to 'after' */\n    private _labelPosition: 'before' | 'after' = 'after';\n\n    /** Whether the radio group is disabled. */\n    private _disabled: boolean = false;\n\n    /** Whether the radio group is required. */\n    private _required: boolean = false;\n\n    constructor(elementRef: ElementRef, private readonly _changeDetector: ChangeDetectorRef) {\n        super(elementRef);\n    }\n\n    /** The method to be called in order to update ngModel */\n    // tslint:disable-next-line\n    controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n    /**\n     * onTouch function registered via registerOnTouch (ControlValueAccessor).\n     * @docs-private\n     */\n    // tslint:disable-next-line\n    onTouched: () => any = () => {};\n\n    checkSelectedRadioButton() {\n        if (this._selected && !this._selected.checked) {\n            this._selected.checked = true;\n        }\n    }\n\n    /**\n     * Initialize properties once content children are available.\n     * This allows us to propagate relevant attributes to associated buttons.\n     */\n    ngAfterContentInit() {\n        // Mark this component as initialized in AfterContentInit because the initial value can\n        // possibly be set by NgModel on McRadioGroup, and it is possible that the OnInit of the\n        // NgModel occurs *after* the OnInit of the McRadioGroup.\n        this.isInitialized = true;\n    }\n\n    /**\n     * Mark this group as being \"touched\" (for ngModel). Meant to be called by the contained\n     * radio buttons upon their blur.\n     */\n    touch() {\n        if (this.onTouched) {\n            this.onTouched();\n        }\n    }\n\n    /** Dispatch change event with current selection and group value. */\n    emitChangeEvent(): void {\n        if (this.isInitialized) {\n            this.change.emit(new McRadioChange(this._selected!, this._value));\n        }\n    }\n\n    markRadiosForCheck() {\n        if (this.radios) {\n            this.radios.forEach((radio) => radio.markForCheck());\n        }\n    }\n\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     */\n    writeValue(value: any) {\n        this.value = value;\n        this._changeDetector.markForCheck();\n    }\n\n    /**\n     * Registers a callback to be triggered when the model value changes.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    registerOnChange(fn: (value: any) => void) {\n        this.controlValueAccessorChangeFn = fn;\n    }\n\n    /**\n     * Registers a callback to be triggered when the control is touched.\n     * Implemented as part of ControlValueAccessor.\n     * @param fn Callback to be registered.\n     */\n    registerOnTouched(fn: any) {\n        this.onTouched = fn;\n    }\n\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     * @param isDisabled Whether the control should be disabled.\n     */\n    setDisabledState(isDisabled: boolean) {\n        this.disabled = isDisabled;\n        this._changeDetector.markForCheck();\n    }\n\n    private updateRadioButtonNames(): void {\n        if (this.radios) {\n            this.radios.forEach((radio) => {\n                radio.name = this.name;\n            });\n        }\n    }\n\n    /** Updates the `selected` radio button from the internal _value state. */\n    private updateSelectedRadioFromValue(): void {\n        // If the value already matches the selected radio, do nothing.\n        const isAlreadySelected = this._selected !== null && this._selected.value === this._value;\n\n        if (this.radios != null && !isAlreadySelected) {\n            this._selected = null;\n            this.radios.forEach((radio) => {\n                radio.checked = this.value === radio.value;\n                if (radio.checked) {\n                    this._selected = radio;\n                }\n            });\n        }\n    }\n}\n\n\n// Boilerplate for applying mixins to McRadioButton.\n/** @docs-private */\nexport class McRadioButtonBase {\n    // Since the disabled property is manually defined for the McRadioButton and isn't set up in\n    // the mixin base class. To be able to use the tabindex mixin, a disabled property must be\n    // defined to properly work.\n    disabled: boolean;\n\n    // tslint:disable-next-line:naming-convention\n    constructor(public _elementRef: ElementRef) {}\n}\n\n// tslint:disable-next-line:naming-convention\nexport const McRadioButtonMixinBase:\n    CanColorCtor & HasTabIndexCtor & typeof McRadioButtonBase = mixinColor(mixinTabIndex(McRadioButtonBase));\n\n\n@Component({\n    selector: 'mc-radio-button',\n    templateUrl: 'radio.component.html',\n    styleUrls: ['radio.scss'],\n    inputs: ['color', 'tabIndex'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    exportAs: 'mcRadioButton',\n    host: {\n        class: 'mc-radio-button',\n        '[attr.id]': 'id',\n        '[class.mc-selected]': 'checked',\n        '[class.mc-disabled]': 'disabled'\n    }\n})\nexport class McRadioButton extends McRadioButtonMixinBase\n    implements OnInit, AfterViewInit, OnDestroy, CanColor, HasTabIndex {\n\n    /** Whether this radio button is checked. */\n    @Input()\n    get checked(): boolean { return this._checked; }\n    set checked(value: boolean) {\n        const newCheckedState = toBoolean(value);\n\n        if (this._checked !== newCheckedState) {\n            this._checked = newCheckedState;\n\n            if (newCheckedState && this.radioGroup && this.radioGroup.value !== this.value) {\n                this.radioGroup.selected = this;\n            } else if (!newCheckedState && this.radioGroup && this.radioGroup.value === this.value) {\n                // When unchecking the selected radio button, update the selected radio\n                // property on the group.\n                this.radioGroup.selected = null;\n            }\n\n            if (newCheckedState) {\n                // Notify all radio buttons with the same name to un-check.\n                this._radioDispatcher.notify(this.id, this.name);\n            }\n            this._changeDetector.markForCheck();\n        }\n    }\n\n    /** The value of this radio button. */\n    @Input()\n    get value(): any { return this._value; }\n    set value(value: any) {\n        if (this._value !== value) {\n            this._value = value;\n            if (this.radioGroup != null) {\n                if (!this.checked) {\n                    // Update checked when the value changed to match the radio group's value\n                    this.checked = this.radioGroup.value === value;\n                }\n                if (this.checked) {\n                    this.radioGroup.selected = this;\n                }\n            }\n        }\n    }\n\n    /** Whether the radio button is disabled. */\n    @Input()\n    get disabled(): boolean {\n        return this._disabled || (this.radioGroup != null && this.radioGroup.disabled);\n    }\n    set disabled(value: boolean) {\n        const newDisabledState = toBoolean(value);\n\n        if (this._disabled !== newDisabledState) {\n\n            this._disabled = newDisabledState;\n            this._changeDetector.markForCheck();\n        }\n    }\n\n    /** Whether the radio button is required. */\n    @Input()\n    get required(): boolean {\n        return this._required || (this.radioGroup && this.radioGroup.required);\n    }\n    set required(value: boolean) {\n        this._required = toBoolean(value);\n    }\n\n    /** Whether the label should appear after or before the radio button. Defaults to 'after' */\n    @Input()\n    get labelPosition(): 'before' | 'after' {\n        return this._labelPosition || (this.radioGroup && this.radioGroup.labelPosition) || 'after';\n    }\n    set labelPosition(value) {\n        this._labelPosition = value;\n    }\n\n    /** Analog to HTML 'name' attribute used to group radios for unique selection. */\n    @Input() name: string;\n\n    /** Used to set the 'aria-label' attribute on the underlying input element. */\n    @Input('aria-label') ariaLabel: string;\n\n    /** The 'aria-labelledby' attribute takes precedence as the element's text alternative. */\n    @Input('aria-labelledby') ariaLabelledby: string;\n\n    /** The 'aria-describedby' attribute is read after the element's label and field type. */\n    @Input('aria-describedby') ariaDescribedby: string;\n\n    /** The native `<input type=radio>` element */\n    @ViewChild('input', {static: false}) inputElement: ElementRef;\n\n    /**\n     * Event emitted when the checked state of this radio button changes.\n     * Change events are only emitted when the value changes due to user interaction with\n     * the radio button (the same behavior as `<input type-\"radio\">`).\n     */\n    @Output() readonly change: EventEmitter<McRadioChange> = new EventEmitter<McRadioChange>();\n\n    /** The parent radio group. May or may not be present. */\n    radioGroup: McRadioGroup;\n\n    @Input()\n    isFocused: boolean = false;\n\n    /** The unique ID for the radio button. */\n    @Input() id: string;\n\n    /** ID of the native input element inside `<mc-radio-button>` */\n    get inputId(): string { return `${this.id || this.uniqueId}-input`; }\n\n    private _labelPosition: 'before' | 'after';\n\n    /* tslint:disable:member-ordering */\n    private readonly uniqueId: string = `mc-radio-${++nextUniqueId}`;\n\n    /** Whether this radio is checked. */\n    private _checked: boolean = false;\n\n    /** Whether this radio is disabled. */\n    private _disabled: boolean;\n\n    /** Whether this radio is required. */\n    private _required: boolean;\n\n    /** Value assigned to this radio. */\n    private _value: any = null;\n\n    constructor(\n        @Optional() radioGroup: McRadioGroup,\n        elementRef: ElementRef,\n        private readonly _changeDetector: ChangeDetectorRef,\n        private focusMonitor: FocusMonitor,\n        private readonly _radioDispatcher: UniqueSelectionDispatcher\n    ) {\n        super(elementRef);\n\n        this.id = this.uniqueId;\n\n        this.radioGroup = radioGroup;\n\n        this.removeUniqueSelectionListener =\n            _radioDispatcher.listen((id: string, name: string) => {\n                if (id !== this.id && name === this.name) {\n                    this.checked = false;\n                }\n            });\n    }\n\n    ngOnInit() {\n        if (this.radioGroup) {\n            // If the radio is inside a radio group, determine if it should be checked\n            this.checked = this.radioGroup.value === this._value;\n            // Copy name from parent radio group\n            this.name = this.radioGroup.name;\n        }\n    }\n\n    ngAfterViewInit() {\n        this.focusMonitor\n            .monitor(this._elementRef, true)\n            .subscribe((focusOrigin) => {\n                if (!focusOrigin && this.radioGroup) {\n                    this.radioGroup.touch();\n                }\n            });\n    }\n\n    ngOnDestroy() {\n        this.focusMonitor.stopMonitoring(this._elementRef);\n        this.removeUniqueSelectionListener();\n    }\n\n    /** Focuses the radio button. */\n    focus(): void {\n        this.inputElement.nativeElement.focus();\n    }\n\n    /**\n     * Marks the radio button as needing checking for change detection.\n     * This method is exposed because the parent radio group will directly\n     * update bound properties of the radio button.\n     */\n    markForCheck() {\n        // When group value changes, the button will not be notified. Use `markForCheck` to explicit\n        // update radio button's status\n        this._changeDetector.markForCheck();\n    }\n\n    onInputClick(event: Event) {\n        // We have to stop propagation for click events on the visual hidden input element.\n        // By default, when a user clicks on a label element, a generated click event will be\n        // dispatched on the associated input element. Since we are using a label element as our\n        // root container, the click event on the `radio-button` will be executed twice.\n        // The real click event will bubble up, and the generated click event also tries to bubble up.\n        // This will lead to multiple click events.\n        // Preventing bubbling for the second event will solve that issue.\n        event.stopPropagation();\n    }\n\n    onInputChange(event: Event) {\n        // We always have to stop propagation on the change event.\n        // Otherwise the change event, from the input element, will bubble up and\n        // emit its event object to the `change` output.\n        event.stopPropagation();\n\n        const groupValueChanged = this.radioGroup && this.value !== this.radioGroup.value;\n        this.checked = true;\n        this.emitChangeEvent();\n\n        if (this.radioGroup) {\n            this.radioGroup.controlValueAccessorChangeFn(this.value);\n            this.radioGroup.touch();\n            if (groupValueChanged) {\n                this.radioGroup.emitChangeEvent();\n            }\n        }\n    }\n\n    /** Unregister function for _radioDispatcher */\n    // tslint:disable-next-line\n    private readonly removeUniqueSelectionListener: () => void = () => {};\n\n    /** Dispatch change event with current value. */\n    private emitChangeEvent(): void {\n        this.change.emit(new McRadioChange(this, this._value));\n    }\n}\n","import { A11yModule } from '@angular/cdk/a11y';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { McCommonModule } from '@ptsecurity/mosaic/core';\n\nimport { McRadioButton, McRadioGroup } from './radio.component';\n\n\n@NgModule({\n    imports: [CommonModule, A11yModule, McCommonModule],\n    exports: [McRadioGroup, McRadioButton],\n    declarations: [McRadioGroup, McRadioButton]\n})\nexport class McRadioModule {\n}\n"]}
{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../packages/mosaic/tree-select/tree-select.component.ts","../../../packages/mosaic/tree-select/tree-select.module.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","create","__read","o","n","m","Symbol","iterator","r","e","i","ar","next","done","push","value","error","nextUniqueId","source","isUserInput","this","Directive","args","selector","McTreeSelectBase","elementRef","defaultErrorStateMatcher","parentForm","parentFormGroup","ngControl","McTreeSelect","changeDetectorRef","viewportRuler","ngZone","renderer","scrollStrategyFactory","rawValidators","mcValidation","dir","parentFormField","ngModel","formControlName","_this","_super","controlType","hiddenItems","triggerFontSize","transformOrigin","panelDoneAnimatingStream","Subject","scrollStrategy","offsetY","positions","originX","originY","overlayX","overlayY","hiddenItemsText","openedChange","EventEmitter","openedStream","pipe","filter","map","closedStream","selectionChange","valueChange","optionSelectionChanges","defer","options","changes","startWith","switchMap","merge","apply","arguments","length","concat","__spread","option","onSelectionChange","onStable","asObservable","take","_required","_multiple","_autoSelect","_value","_focused","_panelOpen","scrollTop","uid","destroy","onChange","onTouched","_compareWith","o1","o2","valueAccessor","id","__","constructor","__extends","defineProperty","_placeholder","stateChanges","coerceBooleanProperty","selectionModel","getMcSelectDynamicMultipleError","multiple","fn","getMcSelectNonFunctionValueError","initializeSelection","tree","getSelectedValues","_id","cleaner","hasValue","ngOnInit","distinctUntilChanged","takeUntil","subscribe","panelOpen","emit","overlayDir","offsetX","markForCheck","ngAfterContentInit","useValidation","setMosaicValidation","resetFocusedItemOnBlur","SelectionModel","initKeyManager","renderedOptions","autoSelect","multipleMode","MultipleMode","CHECKBOX","noUnselectLast","tempValues","setSelectionByValue","event","close","selectedValues","McTreeSelectChange","changed","added","keyManager","setFocusOrigin","setActiveItem","find","data","ngAfterViewInit","tags","setTimeout","calculateHiddenItems","ngDoCheck","updateErrorState","ngOnChanges","disabled","ngOnDestroy","complete","hiddenItemsTextFormatter","clearValue","$event","stopPropagation","clear","toggle","open","triggerRect","trigger","nativeElement","getBoundingClientRect","parseInt","getComputedStyle","highlightCorrectOption","overlayRef","overlayElement","style","fontSize","focus","writeValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","selected","treeControl","getValue","empty","getViewValue","isEmpty","isRtl","handleKeydown","handleOpenKeydown","handleClosedKeydown","onFocus","onBlur","onAttached","positionChange","detectChanges","calculateOverlayOffsetX","panel","updateScrollSize","getPanelTheme","color","onContainerClick","onRemoveSelectedOption","selectedOption","deselect","customTrigger","visibleItems","totalItemsWidth","getTotalItemsWidthInMatcher","totalVisibleItemsWidth","forEach","tag","offsetTop","offsetHeight","getItemWidth","itemsCounter","querySelector","matcherList","itemsCounterShowed","matcherListWidth","width","matcherWidth","triggerClone","cloneNode","remove","setStyle","appendChild","querySelectorAll","item","element","computedStyle","window","keyCode","isArrowKey","DOWN_ARROW","UP_ARROW","LEFT_ARROW","RIGHT_ARROW","ENTER","SPACE","altKey","preventDefault","onKeydown","originalOnKeyDown","HOME","setFirstItemActive","END","setLastItemActive","PAGE_UP","setPreviousPageItemActive","PAGE_DOWN","setNextPageItemActive","activeItem","A","ctrlKey","hasDeselectedOptions_1","some","select","previouslyFocusedIndex","activeItemIndex","shiftKey","selectViaInteraction","setSelectedOptionsByKey","hasModifierKey","Promise","resolve","then","isArray","getMcSelectNonArrayValueError","setOptionsFromValues","sortValues","onKeyDown","tabOut","change","scrollActiveOptionIntoView","options_1","toArray","sort","a","sortComparator","indexOf","firstSelectedValue","activeOptionIndex","getOptionScrollPosition","getItemHeight","SELECT_PANEL_MAX_HEIGHT","overlayRect","viewportSize","getViewportSize","paddingWidth","SELECT_PANEL_PADDING_X","leftOverflow","left","rightOverflow","right","SELECT_PANEL_VIEWPORT_PADDING","Math","round","updatePosition","mixinTabIndex","mixinDisabled","mixinErrorState","Component","exportAs","template","inputs","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","host","class","[class.mc-disabled]","[class.mc-invalid]","[attr.id]","[attr.tabindex]","[attr.disabled]","(click)","(keydown)","(focus)","(blur)","(window:resize)","animations","mcSelectAnimations","transformPanel","fadeInContent","providers","provide","McFormFieldControl","useExisting","CdkTree","ElementRef","ChangeDetectorRef","ViewportRuler","NgZone","Renderer2","ErrorStateMatcher","Inject","MC_SELECT_SCROLL_STRATEGY","Optional","type","NG_VALIDATORS","MC_VALIDATION","Directionality","decorators","NgForm","FormGroupDirective","McFormField","NgControl","Self","NgModel","FormControlName","ViewChild","static","CdkConnectedOverlay","ViewChildren","McTag","ContentChild","McTreeSelectTrigger","McTreeSelection","Input","Output","NgModule","imports","CommonModule","OverlayModule","CdkTreeModule","McTreeModule","McIconModule","McTagsModule","McPseudoCheckboxModule","exports","declarations","MC_SELECT_SCROLL_STRATEGY_PROVIDER"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/* tslint:disable:no-empty */\n\nimport { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport {\n    CdkConnectedOverlay,\n    ViewportRuler\n} from '@angular/cdk/overlay';\nimport {\n    AfterContentInit,\n    AfterViewInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChild,\n    Directive,\n    DoCheck,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    Input,\n    NgZone,\n    OnChanges,\n    OnDestroy,\n    OnInit,\n    Optional,\n    Output,\n    QueryList,\n    Renderer2,\n    Self,\n    SimpleChanges,\n    ViewChild,\n    ViewChildren,\n    ViewEncapsulation\n} from '@angular/core';\nimport {\n    ControlValueAccessor,\n    FormControlName,\n    FormGroupDirective,\n    NG_VALIDATORS,\n    NgControl,\n    NgForm,\n    NgModel,\n    Validator\n} from '@angular/forms';\nimport {\n    DOWN_ARROW,\n    END,\n    ENTER,\n    HOME,\n    LEFT_ARROW,\n    RIGHT_ARROW,\n    SPACE,\n    UP_ARROW,\n    A,\n    PAGE_UP,\n    PAGE_DOWN,\n    hasModifierKey\n} from '@ptsecurity/cdk/keycodes';\nimport { CdkTree } from '@ptsecurity/cdk/tree';\nimport {\n    getOptionScrollPosition,\n    CanDisable,\n    CanUpdateErrorState,\n    ErrorStateMatcher,\n    HasTabIndex,\n    CanDisableCtor,\n    HasTabIndexCtor,\n    CanUpdateErrorStateCtor,\n    mixinTabIndex,\n    mixinDisabled,\n    mixinErrorState,\n    mcSelectAnimations,\n\n    SELECT_PANEL_MAX_HEIGHT,\n    SELECT_PANEL_PADDING_X,\n    SELECT_PANEL_VIEWPORT_PADDING,\n    MC_SELECT_SCROLL_STRATEGY,\n\n    getMcSelectDynamicMultipleError,\n    getMcSelectNonFunctionValueError,\n    getMcSelectNonArrayValueError,\n    MultipleMode,\n\n    MC_VALIDATION,\n    setMosaicValidation,\n    McValidationOptions\n} from '@ptsecurity/mosaic/core';\nimport { McCleaner, McFormField, McFormFieldControl } from '@ptsecurity/mosaic/form-field';\nimport { McTag } from '@ptsecurity/mosaic/tags';\nimport { McTreeSelection, McTreeOption } from '@ptsecurity/mosaic/tree';\nimport { defer, merge, Observable, Subject } from 'rxjs';\nimport {\n    filter,\n    map,\n    switchMap,\n    take,\n    takeUntil,\n    distinctUntilChanged,\n    startWith\n} from 'rxjs/operators';\n\n\nlet nextUniqueId = 0;\n\n/** Change event object that is emitted when the select value has changed. */\nexport class McTreeSelectChange {\n    constructor(public source: McTreeSelect, public value: any, public isUserInput = false) {}\n}\n\n\n@Directive({ selector: 'mc-tree-select-trigger' })\nexport class McTreeSelectTrigger {}\n\n\nclass McTreeSelectBase {\n    constructor(\n        public elementRef: ElementRef,\n        public defaultErrorStateMatcher: ErrorStateMatcher,\n        public parentForm: NgForm,\n        public parentFormGroup: FormGroupDirective,\n        public ngControl: NgControl\n    ) {}\n}\n\n// tslint:disable-next-line:naming-convention\nconst McTreeSelectMixinBase: CanDisableCtor & HasTabIndexCtor & CanUpdateErrorStateCtor &\n    typeof McTreeSelectBase = mixinTabIndex(mixinDisabled(mixinErrorState(McTreeSelectBase)));\n\n\n@Component({\n    selector: 'mc-tree-select',\n    exportAs: 'mcTreeSelect',\n    templateUrl: 'tree-select.html',\n    styleUrls: ['./tree-select.scss'],\n    inputs: ['disabled', 'tabIndex'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    host: {\n        class: 'mc-tree-select',\n        '[class.mc-disabled]': 'disabled',\n        '[class.mc-invalid]': 'errorState',\n\n        '[attr.id]': 'id',\n        '[attr.tabindex]': 'tabIndex',\n        '[attr.disabled]': 'disabled || null',\n\n        '(click)': 'toggle()',\n        '(keydown)': 'handleKeydown($event)',\n        '(focus)': 'onFocus()',\n        '(blur)': 'onBlur()',\n        '(window:resize)': 'calculateHiddenItems()'\n    },\n    animations: [\n        mcSelectAnimations.transformPanel,\n        mcSelectAnimations.fadeInContent\n    ],\n    providers: [\n        { provide: McFormFieldControl, useExisting: McTreeSelect },\n        { provide: CdkTree, useExisting: McTreeSelect }\n    ]\n})\nexport class McTreeSelect extends McTreeSelectMixinBase implements\n    AfterContentInit, AfterViewInit, OnChanges, OnDestroy, OnInit, DoCheck, ControlValueAccessor,\n    CanDisable, HasTabIndex, McFormFieldControl<McTreeOption>, CanUpdateErrorState {\n\n    /** A name for this control that can be used by `mc-form-field`. */\n    controlType = 'mc-select';\n\n    hiddenItems: number = 0;\n\n    /** The last measured value for the trigger's client bounding rect. */\n    triggerRect: ClientRect;\n\n    /** The cached font-size of the trigger element. */\n    triggerFontSize = 0;\n\n    /** Deals with the selection logic. */\n    selectionModel: SelectionModel<any>;\n\n    /** The value of the select panel's transform-origin property. */\n    transformOrigin: string = 'top';\n\n    /** Emits when the panel element is finished transforming in. */\n    panelDoneAnimatingStream = new Subject<string>();\n\n    /** Strategy that will be used to handle scrolling while the select panel is open. */\n    scrollStrategy = this.scrollStrategyFactory();\n\n    /**\n     * The y-offset of the overlay panel in relation to the trigger's top start corner.\n     * This must be adjusted to align the selected option text over the trigger text.\n     * when the panel opens. Will change based on the y-position of the selected option.\n     */\n    offsetY = 0;\n\n    /**\n     * This position config ensures that the top \"start\" corner of the overlay\n     * is aligned with with the top \"start\" of the origin by default (overlapping\n     * the trigger completely). If the panel cannot fit below the trigger, it\n     * will fall back to a position above the trigger.\n     */\n    positions = [\n        {\n            originX: 'start',\n            originY: 'bottom',\n            overlayX: 'start',\n            overlayY: 'top'\n        },\n        {\n            originX: 'start',\n            originY: 'top',\n            overlayX: 'start',\n            overlayY: 'bottom'\n        }\n    ];\n\n    options: QueryList<McTreeOption>;\n\n    @ViewChild('trigger', { static: false }) trigger: ElementRef;\n\n    @ViewChild('panel', { static: false }) panel: ElementRef;\n\n    @ViewChild(CdkConnectedOverlay, { static: false }) overlayDir: CdkConnectedOverlay;\n\n    @ViewChild('hiddenItemsCounter', { static: false }) hiddenItemsCounter: ElementRef;\n\n    @ViewChildren(McTag) tags: QueryList<McTag>;\n\n    @ContentChild('mcSelectCleaner', { static: true }) cleaner: McCleaner;\n\n    /** User-supplied override of the trigger element. */\n    @ContentChild(McTreeSelectTrigger, { static: false }) customTrigger: McTreeSelectTrigger;\n\n    @ContentChild(McTreeSelection, { static: false }) tree: McTreeSelection<McTreeOption>;\n\n    @Input() hiddenItemsText: string = '...ещё';\n\n    /** Event emitted when the select panel has been toggled. */\n    @Output() readonly openedChange: EventEmitter<boolean> = new EventEmitter<boolean>();\n\n    /** Event emitted when the select has been opened. */\n    @Output('opened') readonly openedStream: Observable<void> =\n        this.openedChange.pipe(filter((o) => o), map(() => {}));\n\n    /** Event emitted when the select has been closed. */\n    @Output('closed') readonly closedStream: Observable<void> =\n        this.openedChange.pipe(filter((o) => !o), map(() => {}));\n\n    /** Event emitted when the selected value has been changed by the user. */\n    @Output() readonly selectionChange = new EventEmitter<McTreeSelectChange>();\n\n    /**\n     * Event that emits whenever the raw value of the select changes. This is here primarily\n     * to facilitate the two-way binding for the `value` input.\n     * @docs-private\n     */\n    @Output() readonly valueChange: EventEmitter<any> = new EventEmitter<any>();\n\n    /** Classes to be passed to the select panel. Supports the same syntax as `ngClass`. */\n    @Input() panelClass: string | string[] | Set<string> | { [key: string]: any };\n\n    /** Object used to control when error messages are shown. */\n    @Input() errorStateMatcher: ErrorStateMatcher;\n\n    /**\n     * Function used to sort the values in a select in multiple mode.\n     * Follows the same logic as `Array.prototype.sort`.\n     */\n    @Input() sortComparator: (a: McTreeOption, b: McTreeOption, options: McTreeOption[]) => number;\n\n    /** Combined stream of all of the child options' change events. */\n    readonly optionSelectionChanges: Observable<McTreeSelectChange> = defer(() => {\n        if (this.options) {\n            return this.options.changes.pipe(\n                startWith(this.options),\n                switchMap(() => merge(...this.options.map((option) => option.onSelectionChange)))\n            );\n        }\n\n        return this.ngZone.onStable\n            .asObservable()\n            .pipe(take(1), switchMap(() => this.optionSelectionChanges));\n    }) as Observable<McTreeSelectChange>;\n\n    @Input()\n    get placeholder(): string {\n        return this._placeholder;\n    }\n\n    set placeholder(value: string) {\n        this._placeholder = value;\n\n        this.stateChanges.next();\n    }\n\n    private _placeholder: string;\n\n    @Input()\n    get required(): boolean {\n        return this._required;\n    }\n\n    set required(value: boolean) {\n        this._required = coerceBooleanProperty(value);\n\n        this.stateChanges.next();\n    }\n\n    private _required: boolean = false;\n\n    @Input()\n    get multiple(): boolean {\n        return this._multiple;\n    }\n\n    set multiple(value: boolean) {\n        if (this.selectionModel) {\n            throw getMcSelectDynamicMultipleError();\n        }\n\n        this._multiple = coerceBooleanProperty(value);\n    }\n\n    private _multiple: boolean = false;\n\n    @Input()\n    get autoSelect(): boolean {\n        if (this.multiple) { return false; }\n\n        return this._autoSelect;\n    }\n\n    set autoSelect(value: boolean) {\n        this._autoSelect = coerceBooleanProperty(value);\n    }\n\n    private _autoSelect: boolean = true;\n\n    /**\n     * Function to compare the option values with the selected values. The first argument\n     * is a value from an option. The second is a value from the selection. A boolean\n     * should be returned.\n     */\n    @Input()\n    get compareWith() {\n        return this._compareWith;\n    }\n\n    set compareWith(fn: (o1: any, o2: any) => boolean) {\n        /* tslint:disable-next-line:strict-type-predicates */\n        if (typeof fn !== 'function') {\n            throw getMcSelectNonFunctionValueError();\n        }\n\n        this._compareWith = fn;\n\n        if (this.selectionModel) {\n            // A different comparator means the selection could change.\n            this.initializeSelection();\n        }\n    }\n\n    get value(): any {\n        return this.multiple ? this.tree.getSelectedValues() : this.tree.getSelectedValues()[0];\n    }\n\n    private _value: any = null;\n\n    @Input()\n    get id(): string {\n        return this._id;\n    }\n\n    set id(value: string) {\n        this._id = value || this.uid;\n        this.stateChanges.next();\n    }\n\n    private _id: string;\n\n    /** Whether the select is focused. */\n    get focused(): boolean {\n        return this._focused || this._panelOpen;\n    }\n\n    set focused(value: boolean) {\n        this._focused = value;\n    }\n\n    private _focused = false;\n\n    get panelOpen(): boolean {\n        return this._panelOpen;\n    }\n\n    get canShowCleaner(): boolean {\n        return this.cleaner && this.selectionModel.hasValue();\n    }\n\n    private _panelOpen = false;\n\n    private originalOnKeyDown: (event: KeyboardEvent) => void;\n\n    /** The scroll position of the overlay panel, calculated to center the selected option. */\n    private scrollTop = 0;\n\n    /** Unique id for this input. */\n    private readonly uid = `mc-select-${nextUniqueId++}`;\n\n    /** Emits whenever the component is destroyed. */\n    private readonly destroy = new Subject<void>();\n\n    // Used for storing the values that were assigned before the options were initialized.\n    private tempValues: string | string[] | null;\n\n    constructor(\n        elementRef: ElementRef,\n        readonly changeDetectorRef: ChangeDetectorRef,\n        private readonly viewportRuler: ViewportRuler,\n        private readonly ngZone: NgZone,\n        private readonly renderer: Renderer2,\n        defaultErrorStateMatcher: ErrorStateMatcher,\n        @Inject(MC_SELECT_SCROLL_STRATEGY) private readonly scrollStrategyFactory,\n        @Optional() @Inject(NG_VALIDATORS) public rawValidators: Validator[],\n        @Optional() @Inject(MC_VALIDATION) private mcValidation: McValidationOptions,\n        @Optional() private readonly dir: Directionality,\n        @Optional() parentForm: NgForm,\n        @Optional() parentFormGroup: FormGroupDirective,\n        @Optional() private readonly parentFormField: McFormField,\n        @Optional() @Self() ngControl: NgControl,\n        @Optional() @Self() public ngModel: NgModel,\n        @Optional() @Self() public formControlName: FormControlName\n    ) {\n        super(elementRef, defaultErrorStateMatcher, parentForm, parentFormGroup, ngControl);\n\n        if (this.ngControl) {\n            // Note: we provide the value accessor through here, instead of\n            // the `providers` to avoid running into a circular import.\n            this.ngControl.valueAccessor = this;\n        }\n\n        // Force setter to be called in case id was not specified.\n        this.id = this.id;\n    }\n\n    ngOnInit() {\n        this.stateChanges.next();\n\n        // We need `distinctUntilChanged` here, because some browsers will\n        // fire the animation end event twice for the same animation. See:\n        // https://github.com/angular/angular/issues/24084\n        this.panelDoneAnimatingStream\n            .pipe(distinctUntilChanged(), takeUntil(this.destroy))\n            .subscribe(() => {\n                if (this.panelOpen) {\n                    this.scrollTop = 0;\n                    this.openedChange.emit(true);\n                } else {\n                    this.openedChange.emit(false);\n                    this.overlayDir.offsetX = 0;\n                    this.changeDetectorRef.markForCheck();\n                }\n            });\n    }\n\n    ngAfterContentInit() {\n        if (!this.tree) { return; }\n\n        if (this.mcValidation.useValidation) {\n            setMosaicValidation(this);\n        }\n\n        this.tree.resetFocusedItemOnBlur = false;\n\n        this.selectionModel = this.tree.selectionModel = new SelectionModel<any>(this.multiple);\n        this.tree.ngAfterContentInit();\n\n        this.initKeyManager();\n\n        this.options = this.tree.renderedOptions;\n        this.tree.autoSelect = this.autoSelect;\n\n        if (this.tree.multipleMode === null) {\n            this.tree.multipleMode = this.multiple ? MultipleMode.CHECKBOX : null;\n        }\n\n        if (this.multiple) {\n            this.tree.noUnselectLast = false;\n        }\n\n        if (this.tempValues) {\n            this.setSelectionByValue(this.tempValues);\n            this.tempValues = null;\n        }\n\n        this.optionSelectionChanges\n            .pipe(takeUntil(this.destroy))\n            .subscribe((event) => {\n                if (!this.multiple && this.panelOpen && event.isUserInput) {\n                    this.close();\n                }\n            });\n\n        this.tree.selectionChange\n            .pipe(takeUntil(this.destroy))\n            .subscribe((event) => {\n                this.onChange(this.selectedValues);\n\n                this.selectionChange.emit(new McTreeSelectChange(this, event.option));\n            });\n\n        this.selectionModel.changed\n            .pipe(takeUntil(this.destroy))\n            .subscribe((event) => {\n                if (event.added.length) {\n                    this.tree.keyManager.setFocusOrigin('program');\n                    this.tree.keyManager.setActiveItem(\n                        this.options.find((option) => option.data === event.added[0]) as any\n                    );\n                }\n            });\n    }\n\n    ngAfterViewInit() {\n        if (!this.tree) { return; }\n\n        this.tags.changes\n            .subscribe(() => {\n                setTimeout(() => this.calculateHiddenItems(), 0);\n            });\n\n        setTimeout(() => this.calculateHiddenItems(), 0);\n    }\n\n    ngDoCheck() {\n        if (this.ngControl) { this.updateErrorState(); }\n    }\n\n    ngOnChanges(changes: SimpleChanges) {\n        // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let\n        // the parent form field know to run change detection when the disabled state changes.\n        if (changes.disabled) {\n            this.stateChanges.next();\n        }\n    }\n\n    ngOnDestroy() {\n        this.destroy.next();\n\n        this.destroy.complete();\n        this.stateChanges.complete();\n    }\n\n    @Input()\n    hiddenItemsTextFormatter(hiddenItemsText: string, hiddenItems: number): string {\n        return `${hiddenItemsText} ${hiddenItems}`;\n    }\n\n    clearValue($event): void {\n        $event.stopPropagation();\n\n        this.selectionModel.clear();\n        this.tree.keyManager.setActiveItem(-1);\n\n        this.setSelectionByValue([]);\n\n        this.onChange(this.selectedValues);\n    }\n\n    /** `View -> model callback called when value changes` */\n    onChange: (value: any) => void = () => {};\n\n    /** `View -> model callback called when select has been touched` */\n    onTouched = () => {};\n\n    toggle(): void {\n        if (this.panelOpen) {\n            this.close();\n        } else {\n            this.open();\n        }\n    }\n\n    open(): void {\n        if (this.disabled || !this.options || !this.options.length || this._panelOpen) { return; }\n\n        this.triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n        // Note: The computed font-size will be a string pixel value (e.g. \"16px\").\n        // `parseInt` ignores the trailing 'px' and converts this to a number.\n        this.triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement)['font-size']);\n\n        this._panelOpen = true;\n\n        setTimeout(() => this.highlightCorrectOption());\n\n        this.changeDetectorRef.markForCheck();\n\n        // Set the font size on the panel element once it exists.\n        this.ngZone.onStable.asObservable()\n            .pipe(take(1))\n            .subscribe(() => {\n                if (this.triggerFontSize && this.overlayDir.overlayRef && this.overlayDir.overlayRef.overlayElement) {\n                    this.overlayDir.overlayRef.overlayElement.style.fontSize = `${this.triggerFontSize}px`;\n                }\n            });\n    }\n\n    /** Closes the overlay panel and focuses the host element. */\n    close(): void {\n        if (!this._panelOpen) { return; }\n\n        this._panelOpen = false;\n\n        this.changeDetectorRef.markForCheck();\n        this.onTouched();\n\n        setTimeout(() => this.focus(), 0);\n    }\n\n    /**\n     * Sets the select's value. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param value New value to be written to the model.\n     */\n    writeValue(value: any): void {\n        if (this.tree) {\n            this.setSelectionByValue(value);\n        } else {\n            this.tempValues = value;\n        }\n    }\n\n    /**\n     * Saves a callback function to be invoked when the select's value\n     * changes from user input. Part of the ControlValueAccessor interface\n     * required to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the value changes.\n     */\n    registerOnChange(fn: (value: any) => void) {\n        this.onChange = fn;\n    }\n\n    /**\n     * Saves a callback function to be invoked when the select is blurred\n     * by the user. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param fn Callback to be triggered when the component has been touched.\n     */\n    registerOnTouched(fn: () => {}) {\n        this.onTouched = fn;\n    }\n\n    /**\n     * Disables the select. Part of the ControlValueAccessor interface required\n     * to integrate with Angular's core forms API.\n     *\n     * @param isDisabled Sets whether the component is disabled.\n     */\n    setDisabledState(isDisabled: boolean) {\n        this.disabled = isDisabled;\n        this.changeDetectorRef.markForCheck();\n        this.stateChanges.next();\n    }\n\n    get selected(): any {\n        return this.multiple ? this.selectionModel.selected : this.selectionModel.selected[0];\n    }\n\n    get selectedValues(): any {\n        const selectedValues = this.selectionModel.selected.map((value) => this.tree.treeControl.getValue(value));\n\n        return this.multiple ? selectedValues : selectedValues[0];\n    }\n\n    get triggerValue(): string {\n        if (this.empty) { return ''; }\n\n        return this.tree.treeControl.getViewValue(this.selected);\n    }\n\n    get triggerValues(): string[] {\n        if (this.empty) { return []; }\n\n        return this.selected;\n    }\n\n    get empty(): boolean {\n        return !this.selectionModel || this.selectionModel.isEmpty();\n    }\n\n    isRtl(): boolean {\n        return this.dir ? this.dir.value === 'rtl' : false;\n    }\n\n    handleKeydown(event: KeyboardEvent) {\n        if (!this.disabled) {\n            if (this.panelOpen) {\n                this.handleOpenKeydown(event);\n            } else {\n                this.handleClosedKeydown(event);\n            }\n        }\n    }\n\n    onFocus() {\n        if (!this.disabled) {\n            this._focused = true;\n\n            this.stateChanges.next();\n        }\n    }\n\n    /**\n     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n     * \"blur\" to the panel when it opens, causing a false positive.\n     */\n    onBlur() {\n        this._focused = false;\n\n        if (!this.disabled && !this.panelOpen) {\n            this.onTouched();\n            this.changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        }\n    }\n\n    /** Callback that is invoked when the overlay panel has been attached. */\n    onAttached() {\n        this.overlayDir.positionChange\n            .pipe(take(1))\n            .subscribe(() => {\n                this.changeDetectorRef.detectChanges();\n                this.calculateOverlayOffsetX();\n                this.panel.nativeElement.scrollTop = this.scrollTop;\n\n                this.tree.updateScrollSize();\n            });\n    }\n\n    /** Returns the theme to be used on the panel. */\n    getPanelTheme(): string {\n        return this.parentFormField ? `mc-${this.parentFormField.color}` : '';\n    }\n\n    focus() {\n        this.elementRef.nativeElement.focus();\n    }\n\n    /**\n     * Implemented as part of McFormFieldControl.\n     * @docs-private\n     */\n    onContainerClick() {\n        this.focus();\n    }\n\n    /** Invoked when an option is clicked. */\n    onRemoveSelectedOption(selectedOption: any, $event) {\n        $event.stopPropagation();\n\n        if (this.disabled) { return; }\n\n        this.selectionModel.deselect(selectedOption);\n\n        this.onChange(this.selectedValues);\n    }\n\n    calculateHiddenItems() {\n        if (this.customTrigger || this.empty || !this.multiple) { return; }\n\n        let visibleItems: number = 0;\n        const totalItemsWidth = this.getTotalItemsWidthInMatcher();\n        let totalVisibleItemsWidth: number = 0;\n\n        this.tags.forEach((tag) => {\n            if (tag.nativeElement.offsetTop < tag.nativeElement.offsetHeight) {\n                totalVisibleItemsWidth += this.getItemWidth(tag.nativeElement);\n                visibleItems++;\n            }\n        });\n\n        this.hiddenItems = this.selectionModel.selected.length - visibleItems;\n\n        if (this.hiddenItems) {\n            const itemsCounter = this.trigger.nativeElement.querySelector('.mc-tree-select__match-hidden-text');\n            const matcherList = this.trigger.nativeElement.querySelector('.mc-tree-select__match-list');\n\n            const itemsCounterShowed = itemsCounter.offsetTop < itemsCounter.offsetHeight;\n            // const itemsCounterWidth: number = itemsCounter.getBoundingClientRect().width;\n            const itemsCounterWidth: number = 86;\n\n            const matcherListWidth: number = matcherList.getBoundingClientRect().width;\n            const matcherWidth: number = matcherListWidth + itemsCounterWidth;\n\n            if (itemsCounterShowed && (totalItemsWidth < matcherWidth)) { this.hiddenItems = 0; }\n\n            if (\n                totalVisibleItemsWidth === matcherListWidth ||\n                (totalVisibleItemsWidth + itemsCounterWidth) < matcherListWidth\n            ) {\n                this.changeDetectorRef.markForCheck();\n\n                return ;\n            } else if (!itemsCounterShowed && (totalItemsWidth + itemsCounterWidth) > matcherWidth) {\n                this.hiddenItems++;\n            }\n        }\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    private getTotalItemsWidthInMatcher(): number {\n        const triggerClone = this.trigger.nativeElement.cloneNode(true);\n        triggerClone.querySelector('.mc-tree-select__match-hidden-text').remove();\n\n        this.renderer.setStyle(triggerClone, 'position', 'absolute');\n        this.renderer.setStyle(triggerClone, 'visibility', 'hidden');\n        this.renderer.setStyle(triggerClone, 'top', '-100%');\n        this.renderer.setStyle(triggerClone, 'left', '0');\n\n        this.renderer.appendChild(this.trigger.nativeElement, triggerClone);\n\n        let totalItemsWidth: number = 0;\n        triggerClone.querySelectorAll('mc-tag').forEach((item) => {\n            totalItemsWidth += this.getItemWidth(item);\n        });\n\n        triggerClone.remove();\n\n        return totalItemsWidth;\n    }\n\n    private getItemWidth(element: HTMLElement): number {\n        const computedStyle = window.getComputedStyle(element);\n\n        const width: number = parseInt(computedStyle.width as string);\n        const marginLeft: number = parseInt(computedStyle.marginLeft as string);\n        const marginRight: number = parseInt(computedStyle.marginRight as string);\n\n        return width + marginLeft + marginRight;\n    }\n\n    private handleClosedKeydown(event: KeyboardEvent) {\n        // tslint:disable-next-line: deprecation\n        const keyCode = event.keyCode;\n        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||\n            keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;\n        const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n\n        // Open the select on ALT + arrow key to match the native <select>\n        if (isOpenKey || ((this.multiple || event.altKey) && isArrowKey)) {\n            // prevents the page from scrolling down when pressing space\n            event.preventDefault();\n\n            this.open();\n        } else if (!this.multiple && this.tree.keyManager && this.tree.keyManager.onKeydown) {\n            this.tree.keyManager.onKeydown(event);\n        }\n    }\n\n    private handleOpenKeydown(event: KeyboardEvent) {\n        /* tslint:disable-next-line */\n        const keyCode = event.keyCode;\n        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n\n        if (isArrowKey && event.altKey) {\n            // Close the select on ALT + arrow key to match the native <select>\n            event.preventDefault();\n\n            this.close();\n        } else if (keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW) {\n            return this.originalOnKeyDown.call(this.tree, event);\n        } else if (keyCode === HOME) {\n            event.preventDefault();\n\n            this.tree.keyManager.setFirstItemActive();\n        } else if (keyCode === END) {\n            event.preventDefault();\n\n            this.tree.keyManager.setLastItemActive();\n        } else if (keyCode === PAGE_UP) {\n            event.preventDefault();\n\n            this.tree.keyManager.setPreviousPageItemActive();\n        } else if (keyCode === PAGE_DOWN) {\n            event.preventDefault();\n\n            this.tree.keyManager.setNextPageItemActive();\n        } else if ((keyCode === ENTER || keyCode === SPACE) && this.tree.keyManager.activeItem) {\n            event.preventDefault();\n\n            if (!this.autoSelect) {\n                this.selectionModel.toggle(this.tree.keyManager.activeItem.data);\n            } else {\n                this.close();\n            }\n        } else if (this.multiple && keyCode === A && event.ctrlKey) {\n            event.preventDefault();\n\n            const hasDeselectedOptions = this.options.some((option) => !option.selected);\n\n            this.options.forEach((option) => {\n                if (hasDeselectedOptions && !option.disabled) {\n                    option.select();\n                } else {\n                    option.deselect();\n                }\n            });\n        } else {\n            const previouslyFocusedIndex = this.tree.keyManager.activeItemIndex;\n\n            this.tree.keyManager.setFocusOrigin('keyboard');\n            this.tree.keyManager.onKeydown(event);\n\n            if (\n                this.multiple && isArrowKey && event.shiftKey && this.tree.keyManager.activeItem &&\n                this.tree.keyManager.activeItemIndex !== previouslyFocusedIndex\n            ) {\n                this.tree.keyManager.activeItem.selectViaInteraction(event);\n            }\n\n            if (this.autoSelect && this.tree.keyManager.activeItem) {\n                this.tree.setSelectedOptionsByKey(\n                    this.tree.keyManager.activeItem, hasModifierKey(event, 'shiftKey'), hasModifierKey(event, 'ctrlKey')\n                );\n            }\n        }\n    }\n\n    private initializeSelection() {\n        // Defer setting the value in order to avoid the \"Expression\n        // has changed after it was checked\" errors from Angular.\n        Promise.resolve().then(() => {\n            this.setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);\n        });\n    }\n\n    /**\n     * Sets the selected option based on a value. If no option can be\n     * found with the designated value, the select trigger is cleared.\n     */\n    private setSelectionByValue(value: any | any[]) {\n        if (this.multiple && value) {\n            if (!Array.isArray(value)) { throw getMcSelectNonArrayValueError(); }\n\n            this.tree.setOptionsFromValues(value);\n\n            this.sortValues();\n        } else {\n            this.tree.setOptionsFromValues([value]);\n        }\n\n        this.changeDetectorRef.detectChanges();\n    }\n\n    private initKeyManager() {\n        this.originalOnKeyDown = this.tree.onKeyDown;\n\n        this.tree.onKeyDown = () => {};\n\n        this.tree.keyManager.tabOut\n            .pipe(takeUntil(this.destroy))\n            .subscribe(() => {\n                // Restore focus to the trigger before closing. Ensures that the focus\n                // position won't be lost if the user got focus into the overlay.\n                this.focus();\n                this.close();\n            });\n\n        this.tree.keyManager.change\n            .pipe(takeUntil(this.destroy))\n            .subscribe(() => {\n                if (this._panelOpen && this.panel) {\n                    this.scrollActiveOptionIntoView();\n                } else if (!this._panelOpen && !this.multiple && this.tree.keyManager.activeItem) {\n                    this.tree.keyManager.activeItem.selectViaInteraction();\n                }\n            });\n    }\n\n    /** Sorts the selected values in the selected based on their order in the panel. */\n    private sortValues() {\n        if (this.multiple) {\n            const options = this.options.toArray();\n\n            this.selectionModel.sort((a, b) => {\n                return this.sortComparator ? this.sortComparator(a, b, options) :\n                    options.indexOf(a) - options.indexOf(b);\n            });\n\n            this.stateChanges.next();\n        }\n    }\n\n    /**\n     * Highlights the selected item. If no option is selected, it will highlight\n     * the first item instead.\n     */\n    private highlightCorrectOption() {\n        if (this.empty || !this.tree.keyManager) { return; }\n\n        const firstSelectedValue = this.multiple ? this.selectedValues[0] : this.selectedValues;\n\n        const selectedOption = this.options.find((option) => option.value === firstSelectedValue);\n\n        if (selectedOption) {\n            this.tree.keyManager.setActiveItem(selectedOption);\n        }\n    }\n\n    /** Scrolls the active option into view. */\n    private scrollActiveOptionIntoView() {\n        const activeOptionIndex = this.tree.keyManager.activeItemIndex || 0;\n\n        this.panel.nativeElement.scrollTop = getOptionScrollPosition(\n            activeOptionIndex,\n            this.tree.getItemHeight(),\n            this.panel.nativeElement.scrollTop,\n            SELECT_PANEL_MAX_HEIGHT\n        );\n    }\n\n    /**\n     * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.\n     * This must be adjusted to align the selected option text over the trigger text when\n     * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\n     * can't be calculated until the panel has been attached, because we need to know the\n     * content width in order to constrain the panel within the viewport.\n     */\n    private calculateOverlayOffsetX() {\n        const overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();\n        const viewportSize = this.viewportRuler.getViewportSize();\n        const isRtl = this.isRtl();\n        /* tslint:disable-next-line:no-magic-numbers */\n        const paddingWidth = SELECT_PANEL_PADDING_X * 2;\n        let offsetX: number = SELECT_PANEL_PADDING_X;\n\n        // Invert the offset in LTR.\n        if (!isRtl) { offsetX *= -1; }\n\n        // Determine how much the select overflows on each side.\n        const leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));\n        const rightOverflow = overlayRect.right + offsetX - viewportSize.width\n            + (isRtl ? 0 : paddingWidth);\n\n        // If the element overflows on either side, reduce the offset to allow it to fit.\n        if (leftOverflow > 0) {\n            offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n        } else if (rightOverflow > 0) {\n            offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n        }\n\n        // Set the offset directly in order to avoid having to go through change detection and\n        // potentially triggering \"changed after it was checked\" errors. Round the value to avoid\n        // blurry content in some browsers.\n        this.overlayDir.offsetX = Math.round(offsetX);\n        this.overlayDir.overlayRef.updatePosition();\n    }\n\n    /** Comparison function to specify which option is displayed. Defaults to object equality. */\n    private _compareWith = (o1: any, o2: any) => o1 === o2;\n}\n","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { CdkTreeModule } from '@ptsecurity/cdk/tree';\nimport { MC_SELECT_SCROLL_STRATEGY_PROVIDER, McPseudoCheckboxModule } from '@ptsecurity/mosaic/core';\nimport { McIconModule } from '@ptsecurity/mosaic/icon';\nimport { McTagsModule } from '@ptsecurity/mosaic/tags';\nimport { McTreeModule } from '@ptsecurity/mosaic/tree';\n\nimport { McTreeSelect, McTreeSelectTrigger } from './tree-select.component';\n\n\n@NgModule({\n    imports: [\n        CommonModule,\n        OverlayModule,\n        CdkTreeModule,\n        McTreeModule,\n        McIconModule,\n        McTagsModule,\n        McPseudoCheckboxModule\n    ],\n    exports: [McTreeSelect, McTreeSelectTrigger, CommonModule],\n    declarations: [McTreeSelect, McTreeSelectTrigger],\n    providers: [MC_SELECT_SCROLL_STRATEGY_PROVIDER]\n})\nexport class McTreeSelectModule {}\n"]}
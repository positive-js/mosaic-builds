{"version":3,"file":"mosaic-button-toggle.umd.min.js","sources":["../../packages/mosaic/button-toggle/button-toggle.component.ts","../../packages/mosaic/button-toggle/button-toggle.module.ts"],"sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport {\n    AfterContentInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    Directive,\n    ElementRef,\n    EventEmitter,\n    forwardRef,\n    Input,\n    OnDestroy,\n    OnInit,\n    Optional,\n    Output,\n    QueryList,\n    ViewEncapsulation,\n    ViewChild\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { FocusMonitor } from '@ptsecurity/cdk/a11y';\nimport { McButton } from '@ptsecurity/mosaic/button';\n\n\n/** Acceptable types for a button toggle. */\nexport type ToggleType = 'checkbox' | 'radio';\n\n/**\n * Provider Expression that allows mc-button-toggle-group to register as a ControlValueAccessor.\n * This allows it to support [(ngModel)].\n * @docs-private\n */\nexport const MC_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McButtonToggleGroup),\n    multi: true\n};\n\n/** Change event object emitted by MсButtonToggle. */\nexport class McButtonToggleChange {\n    constructor(\n        /** The MсButtonToggle that emits the event. */\n        public source: McButtonToggle,\n        /** The value assigned to the MсButtonToggle. */\n        public value: any) {\n    }\n}\n\n/** Exclusive selection button toggle group that behaves like a radio-button group. */\n@Directive({\n    selector: 'mc-button-toggle-group',\n    providers: [MC_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR],\n    host: {\n        role: 'group',\n        class: 'mc-button-toggle-group',\n        '[class.mc-button-toggle-vertical]': 'vertical'\n    },\n    exportAs: 'mcButtonToggleGroup'\n})\nexport class McButtonToggleGroup implements ControlValueAccessor, OnInit, AfterContentInit {\n\n    /** Whether the toggle group is vertical. */\n    @Input()\n    get vertical(): boolean {\n        return this._vertical;\n    }\n\n    set vertical(value: boolean) {\n        this._vertical = coerceBooleanProperty(value);\n    }\n\n    /** Value of the toggle group. */\n    @Input()\n    get value(): any {\n        const selected = this.selectionModel ? this.selectionModel.selected : [];\n\n        if (this.multiple) {\n            return selected.map((toggle) => toggle.value);\n        }\n\n        return selected[0] ? selected[0].value : undefined;\n    }\n\n    set value(newValue: any) {\n        this.setSelectionByValue(newValue);\n        this.valueChange.emit(this.value);\n    }\n\n    /** Selected button toggles in the group. */\n    get selected(): any {\n        const selected = this.selectionModel.selected;\n\n        return this.multiple ? selected : (selected[0] || null);\n    }\n\n    /** Whether multiple button toggles can be selected. */\n    @Input()\n    get multiple(): boolean {\n        return this._multiple;\n    }\n\n    set multiple(value: boolean) {\n        this._multiple = coerceBooleanProperty(value);\n    }\n\n    /** Child button toggle buttons. */\n    @ContentChildren(forwardRef(() => McButtonToggle)) buttonToggles: QueryList<McButtonToggle>;\n\n    /** Whether multiple button toggle group is disabled. */\n    @Input()\n    get disabled(): boolean {\n        return this._disabled;\n    }\n\n    set disabled(value: boolean) {\n        this._disabled = coerceBooleanProperty(value);\n\n        if (!this.buttonToggles) {\n            return;\n        }\n\n        this.buttonToggles.forEach((toggle) => toggle.markForCheck());\n    }\n\n    /**\n     * Event that emits whenever the value of the group changes.\n     * Used to facilitate two-way data binding.\n     * @docs-private\n     */\n    @Output() readonly valueChange = new EventEmitter<any>();\n\n    /** Event emitted when the group's value changes. */\n    @Output() readonly change: EventEmitter<McButtonToggleChange> =\n        new EventEmitter<McButtonToggleChange>();\n    private _vertical = false;\n    private _multiple = false;\n    private _disabled = false;\n    private selectionModel: SelectionModel<McButtonToggle>;\n\n    /**\n     * Reference to the raw value that the consumer tried to assign. The real\n     * value will exclude any values from this one that don't correspond to a\n     * toggle. Useful for the cases where the value is assigned before the toggles\n     * have been initialized or at the same that they're being swapped out.\n     */\n    private rawValue: any;\n\n    constructor(private _changeDetector: ChangeDetectorRef) {}\n\n    /**\n     * The method to be called in order to update ngModel.\n     * Now `ngModel` binding is not supported in multiple selection mode.\n     */\n    // tslint:disable-next-line:no-empty\n    controlValueAccessorChangeFn: (value: any) => void = () => {};\n\n    /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\n    // tslint:disable-next-line:no-empty\n    onTouched: () => any = () => {};\n\n    ngOnInit() {\n        this.selectionModel = new SelectionModel<McButtonToggle>(this.multiple, undefined, false);\n    }\n\n    ngAfterContentInit() {\n        this.selectionModel.select(...this.buttonToggles.filter((toggle) => toggle.checked));\n        this.disabled = this._disabled;\n    }\n\n    /**\n     * Sets the model value. Implemented as part of ControlValueAccessor.\n     * @param value Value to be set to the model.\n     */\n    writeValue(value: any) {\n        this.value = value;\n        this._changeDetector.markForCheck();\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn: (value: any) => void) {\n        this.controlValueAccessorChangeFn = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn: any) {\n        this.onTouched = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled: boolean): void {\n        this.disabled = isDisabled;\n    }\n\n    /** Dispatch change event with current selection and group value. */\n    emitChangeEvent(): void {\n        const selected = this.selected;\n        const source = Array.isArray(selected) ? selected[selected.length - 1] : selected;\n        const event = new McButtonToggleChange(source, this.value);\n        this.controlValueAccessorChangeFn(event.value);\n        this.change.emit(event);\n    }\n\n    /**\n     * Syncs a button toggle's selected state with the model value.\n     * @param toggle Toggle to be synced.\n     * @param select Whether the toggle should be selected.\n     * @param isUserInput Whether the change was a result of a user interaction.\n     */\n    syncButtonToggle(toggle: McButtonToggle, select: boolean, isUserInput = false) {\n        // Deselect the currently-selected toggle, if we're in single-selection\n        // mode and the button being toggled isn't selected at the moment.\n        if (!this.multiple && this.selected && !toggle.checked) {\n            (this.selected as McButtonToggle).checked = false;\n        }\n\n        if (select) {\n            this.selectionModel.select(toggle);\n        } else {\n            this.selectionModel.deselect(toggle);\n        }\n\n        // Only emit the change event for user input.\n        if (isUserInput) {\n            this.emitChangeEvent();\n        }\n\n        // Note: we emit this one no matter whether it was a user interaction, because\n        // it is used by Angular to sync up the two-way data binding.\n        this.valueChange.emit(this.value);\n    }\n\n    /** Checks whether a button toggle is selected. */\n    isSelected(toggle: McButtonToggle) {\n        return this.selectionModel.isSelected(toggle);\n    }\n\n    /** Determines whether a button toggle should be checked on init. */\n    isPrechecked(toggle: McButtonToggle) {\n        if (this.rawValue === undefined) {\n            return false;\n        }\n\n        if (this.multiple && Array.isArray(this.rawValue)) {\n            return this.rawValue.some((value) => toggle.value != null && value === toggle.value);\n        }\n\n        return toggle.value === this.rawValue;\n    }\n\n    /** Updates the selection state of the toggles in the group based on a value. */\n    private setSelectionByValue(value: any | any[]) {\n        this.rawValue = value;\n\n        if (!this.buttonToggles) {\n            return;\n        }\n\n        if (this.multiple && value) {\n            if (!Array.isArray(value)) {\n                throw Error('Value must be an array in multiple-selection mode.');\n            }\n\n            this.clearSelection();\n            value.forEach((currentValue: any) => this.selectValue(currentValue));\n        } else {\n            this.clearSelection();\n            this.selectValue(value);\n        }\n    }\n\n    /** Clears the selected toggles. */\n    private clearSelection() {\n        this.selectionModel.clear();\n        this.buttonToggles.forEach((toggle) => toggle.checked = false);\n    }\n\n    /** Selects a value if there's a toggle that corresponds to it. */\n    private selectValue(value: any) {\n        const correspondingOption = this.buttonToggles.find((toggle) => {\n            return toggle.value != null && toggle.value === value;\n        });\n\n        if (correspondingOption) {\n            correspondingOption.checked = true;\n            this.selectionModel.select(correspondingOption);\n        }\n    }\n}\n\n/** Single button inside of a toggle group. */\n@Component({\n    selector: 'mc-button-toggle',\n    template: `\n        <button\n            mc-button\n            type=\"button\"\n            [class.mc-active]=\"checked\"\n            [disabled]=\"disabled\"\n            [attr.tabindex]=\"disabled ? -1 : tabIndex\"\n            (click)=\"onToggleClick()\">\n            <ng-content></ng-content>\n        </button>\n    `,\n    styleUrls: ['button-toggle.css'],\n    encapsulation: ViewEncapsulation.None,\n    exportAs: 'mcButtonToggle',\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    host: {\n        class: 'mc-button-toggle',\n        '[class.mc-button-toggle-standalone]': '!buttonToggleGroup',\n        // Always reset the tabindex to -1 so it doesn't conflict with the one on the `button`,\n        // but can still receive focus from things like cdkFocusInitial.\n        '[attr.tabindex]': '-1',\n        '[attr.disabled]': 'disabled || null',\n        '(focus)': 'focus()'\n    }\n})\nexport class McButtonToggle implements OnInit, OnDestroy {\n\n    /** Whether the button is checked. */\n    @Input()\n    get checked(): boolean {\n        return this.buttonToggleGroup ? this.buttonToggleGroup.isSelected(this) : this._checked;\n    }\n\n    set checked(value: boolean) {\n        const newValue = coerceBooleanProperty(value);\n\n        if (newValue !== this._checked) {\n            this._checked = newValue;\n\n            if (this.buttonToggleGroup) {\n                this.buttonToggleGroup.syncButtonToggle(this, this._checked);\n            }\n\n            this.changeDetectorRef.markForCheck();\n        }\n    }\n\n    // tslint:disable-next-line:no-reserved-keywords\n    type: ToggleType;\n\n    @ViewChild(McButton, {static: false}) mcButton: McButton;\n\n    /** McButtonToggleGroup reads this to assign its own value. */\n    @Input() value: any;\n\n    /** Tabindex for the toggle. */\n    @Input() tabIndex: number | null;\n\n    @Input()\n    get disabled(): boolean {\n        return this._disabled || (this.buttonToggleGroup && this.buttonToggleGroup.disabled);\n    }\n    set disabled(value: boolean) { this._disabled = coerceBooleanProperty(value); }\n\n    /** Event emitted when the group value changes. */\n    @Output() readonly change: EventEmitter<McButtonToggleChange> =\n        new EventEmitter<McButtonToggleChange>();\n\n    private isSingleSelector = false;\n    private _checked = false;\n    private _disabled: boolean = false;\n\n    constructor(\n        @Optional() public buttonToggleGroup: McButtonToggleGroup,\n        private changeDetectorRef: ChangeDetectorRef,\n        private focusMonitor: FocusMonitor,\n        private element: ElementRef\n    ) {}\n\n    ngOnInit() {\n        this.isSingleSelector = this.buttonToggleGroup && !this.buttonToggleGroup.multiple;\n        this.type = this.isSingleSelector ? 'radio' : 'checkbox';\n\n        if (this.buttonToggleGroup && this.buttonToggleGroup.isPrechecked(this)) {\n            this.checked = true;\n        }\n\n        this.focusMonitor.monitor(this.element.nativeElement, true);\n    }\n\n    ngOnDestroy() {\n        const group = this.buttonToggleGroup;\n\n        this.focusMonitor.stopMonitoring(this.element.nativeElement);\n\n        // Remove the toggle from the selection once it's destroyed. Needs to happen\n        // on the next tick in order to avoid \"changed after checked\" errors.\n        if (group && group.isSelected(this)) {\n            Promise.resolve().then(() => group.syncButtonToggle(this, false));\n        }\n    }\n\n    /** Focuses the button. */\n    focus(): void {\n        this.element.nativeElement.focus();\n    }\n\n    /** Checks the button toggle due to an interaction with the underlying native button. */\n    onToggleClick() {\n        if (this.disabled) {\n            return;\n        }\n\n        const newChecked = this.isSingleSelector ? true : !this._checked;\n\n        if (newChecked !== this._checked) {\n            this._checked = newChecked;\n            if (this.buttonToggleGroup) {\n                this.buttonToggleGroup.syncButtonToggle(this, this._checked, true);\n                this.buttonToggleGroup.onTouched();\n            }\n        }\n        // Emit a change event when it's the single selector\n        this.change.emit(new McButtonToggleChange(this, this.value));\n    }\n\n    /**\n     * Marks the button toggle as needing checking for change detection.\n     * This method is exposed because the parent button toggle group will directly\n     * update bound properties of the radio button.\n     */\n    markForCheck() {\n        // When the group value changes, the button will not be notified.\n        // Use `markForCheck` to explicit update button toggle's status.\n        this.changeDetectorRef.markForCheck();\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { McButtonModule } from '@ptsecurity/mosaic/button';\nimport { McCommonModule } from '@ptsecurity/mosaic/core';\n\nimport { McButtonToggle, McButtonToggleGroup } from './button-toggle.component';\n\n\n@NgModule({\n    imports: [McCommonModule, McButtonModule],\n    exports: [McCommonModule, McButtonToggleGroup, McButtonToggle],\n    declarations: [McButtonToggleGroup, McButtonToggle]\n})\nexport class McButtonToggleModule {}\n"],"names":["MC_BUTTON_TOGGLE_GROUP_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","McButtonToggleGroup","multi","McButtonToggleChange","source","value","this","_changeDetector","valueChange","EventEmitter","change","_vertical","_multiple","_disabled","controlValueAccessorChangeFn","onTouched","Object","defineProperty","prototype","coerceBooleanProperty","selected","selectionModel","multiple","map","toggle","undefined","newValue","setSelectionByValue","emit","buttonToggles","forEach","markForCheck","ngOnInit","SelectionModel","ngAfterContentInit","_a","select","apply","filter","checked","disabled","writeValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","emitChangeEvent","Array","isArray","length","event","syncButtonToggle","isUserInput","deselect","isSelected","isPrechecked","rawValue","some","_this","Error","clearSelection","currentValue","selectValue","clear","correspondingOption","find","type","Directive","args","selector","providers","host","role","class","[class.mc-button-toggle-vertical]","exportAs","ChangeDetectorRef","vertical","Input","ContentChildren","McButtonToggle","Output","buttonToggleGroup","changeDetectorRef","focusMonitor","element","isSingleSelector","_checked","monitor","nativeElement","ngOnDestroy","group","stopMonitoring","Promise","resolve","then","focus","onToggleClick","newChecked","Component","template","styles","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","[class.mc-button-toggle-standalone]","[attr.tabindex]","[attr.disabled]","(focus)","decorators","Optional","FocusMonitor","ElementRef","mcButton","ViewChild","McButton","static","tabIndex","McButtonToggleModule","NgModule","imports","McCommonModule","McButtonModule","exports","declarations"],"mappings":";;;;;;gyBAkCA,IAAaA,IACTC,QAASC,EAAAA,kBACTC,YAAaC,EAAAA,WAAU,WAAO,MAAAC,KAC9BC,OAAO,gBAKP,QAAJC,GAEeC,EAEAC,GAFAC,KAAfF,OAAeA,EAEAE,KAAfD,MAAeA,EAEf,MAAAF,MAGAF,EAAA,WAkGI,QAAJA,GAAwBM,GAAAD,KAAxBC,gBAAwBA,EAlBDD,KAAvBE,YAAqC,GAAIC,GAAAA,aAGlBH,KAAvBI,OACQ,GAAID,GAAAA,aACAH,KAAZK,WAAwB,EACZL,KAAZM,WAAwB,EACZN,KAAZO,WAAwB,EAkBpBP,KAAJQ,6BAAgC,aAI5BR,KAAJS,UAAa,aAiIb,MAjOIC,QAAJC,eACQhB,EADRiB,UAAA,gBAAI,WAEI,MAAOZ,MAAKK,eAGhB,SAAaN,GACTC,KAAKK,UAAYQ,EAAAA,sBAAsBd,oCAI3CW,OAAJC,eACQhB,EADRiB,UAAA,aAAI,WAEJ,GAAcE,GAAWd,KAAKe,eAAiBf,KAAKe,eAAeD,WAE3D,OAAId,MAAKgB,SACEF,EAASG,IAAG,SAAEC,GAAW,MAAAA,GAAOnB,QAGpCe,EAAS,GAAKA,EAAS,GAAGf,UAAQoB,QAG7C,SAAUC,GACNpB,KAAKqB,oBAAoBD,GACzBpB,KAAKE,YAAYoB,KAAKtB,KAAKD,wCAI/BW,OAAJC,eAAQhB,EAARiB,UAAA,gBAAI,WACJ,GAAcE,GAAWd,KAAKe,eAAeD,QAErC,OAAOd,MAAKgB,SAAWF,EAAYA,EAAS,IAAM,sCAItDJ,OAAJC,eACQhB,EADRiB,UAAA,gBAAI,WAEI,MAAOZ,MAAKM,eAGhB,SAAaP,GACTC,KAAKM,UAAYO,EAAAA,sBAAsBd,oCAO3CW,OAAJC,eACQhB,EADRiB,UAAA,gBAAI,WAEI,MAAOZ,MAAKO,eAGhB,SAAaR,GACTC,KAAKO,UAAYM,EAAAA,sBAAsBd,GAElCC,KAAKuB,eAIVvB,KAAKuB,cAAcC,QAAO,SAAEN,GAAW,MAAAA,GAAOO,kDAuClD9B,EAAJiB,UAAAc,SAAI,WACI1B,KAAKe,eAAiB,GAAIY,GAAAA,eAA+B3B,KAAKgB,aAAUG,IAAW,IAGvFxB,EAAJiB,UAAAgB,mBAAI,kBACIC,EAAA7B,KAAKe,gBAAee,OAA5BC,MAAAF,EAAsC7B,KAAKuB,cAAcS,OAAM,SAAEd,GAAW,MAAAA,GAAOe,WAC3EjC,KAAKkC,SAAWlC,KAAKO,WAOzBZ,EAAJiB,UAAAuB,WAAI,SAAWpC,GACPC,KAAKD,MAAQA,EACbC,KAAKC,gBAAgBwB,gBAIzB9B,EAAJiB,UAAAwB,iBAAI,SAAiBC,GACbrC,KAAKQ,6BAA+B6B,GAIxC1C,EAAJiB,UAAA0B,kBAAI,SAAkBD,GACdrC,KAAKS,UAAY4B,GAIrB1C,EAAJiB,UAAA2B,iBAAI,SAAiBC,GACbxC,KAAKkC,SAAWM,GAIpB7C,EAAJiB,UAAA6B,gBAAI,WACJ,GAAc3B,GAAWd,KAAKc,SAChBhB,EAAS4C,MAAMC,QAAQ7B,GAAYA,EAASA,EAAS8B,OAAS,GAAK9B,EACnE+B,EAAQ,GAAIhD,GAAqBC,EAAQE,KAAKD,MACpDC,MAAKQ,6BAA6BqC,EAAM9C,OACxCC,KAAKI,OAAOkB,KAAKuB,IASrBlD,EAAJiB,UAAAkC,iBAAI,SAAiB5B,EAAwBY,EAAiBiB,OAA9D,KAAAA,IAA8DA,GAA9D,GAGa/C,KAAKgB,WAAYhB,KAAKc,UAAaI,EAAOe,UAC1CjC,KAAa,SAAoBiC,SAAU,GAG5CH,EACA9B,KAAKe,eAAee,OAAOZ,GAE3BlB,KAAKe,eAAeiC,SAAS9B,GAI7B6B,GACA/C,KAAKyC,kBAKTzC,KAAKE,YAAYoB,KAAKtB,KAAKD,QAI/BJ,EAAJiB,UAAAqC,WAAI,SAAW/B,GACP,MAAOlB,MAAKe,eAAekC,WAAW/B,IAI1CvB,EAAJiB,UAAAsC,aAAI,SAAahC,GACT,WAAsBC,KAAlBnB,KAAKmD,WAILnD,KAAKgB,UAAY0B,MAAMC,QAAQ3C,KAAKmD,UAC7BnD,KAAKmD,SAASC,KAAI,SAAErD,GAAU,MAAgB,OAAhBmB,EAAOnB,OAAiBA,IAAUmB,EAAOnB,QAG3EmB,EAAOnB,QAAUC,KAAKmD,WAIzBxD,EAAZiB,UAAAS,oBAAI,SAA4BtB,GAA5B,GAAJsD,GAAArD,IAGQ,IAFAA,KAAKmD,SAAWpD,EAEXC,KAAKuB,cAIV,GAAIvB,KAAKgB,UAAYjB,EAAO,CACxB,IAAK2C,MAAMC,QAAQ5C,GACf,KAAMuD,OAAM,qDAGhBtD,MAAKuD,iBACLxD,EAAMyB,QAAO,SAAEgC,GAAsB,MAAAH,GAAKI,YAAYD,SAEtDxD,MAAKuD,iBACLvD,KAAKyD,YAAY1D,IAKjBJ,EAAZiB,UAAA2C,eAAI,WACIvD,KAAKe,eAAe2C,QACpB1D,KAAKuB,cAAcC,QAAO,SAAEN,GAAW,MAAAA,GAAOe,SAAU,KAIpDtC,EAAZiB,UAAA6C,YAAI,SAAoB1D,GACxB,GAAc4D,GAAsB3D,KAAKuB,cAAcqC,KAAI,SAAE1C,GACjD,MAAuB,OAAhBA,EAAOnB,OAAiBmB,EAAOnB,QAAUA,GAGhD4D,KACAA,EAAoB1B,SAAU,EAC9BjC,KAAKe,eAAee,OAAO6B,oBA3OvCE,KAACC,EAAAA,UAADC,OACIC,SAAU,yBACVC,WAAY3E,GACZ4E,MACIC,KAAM,QACNC,MAAO,yBACPC,oCAAqC,YAEzCC,SAAU,8DAtDdT,KAAIU,EAAAA,uCA2DJC,WAAAX,KAAKY,EAAAA,QAUL1E,QAAA8D,KAAKY,EAAAA,QAwBLzD,WAAA6C,KAAKY,EAAAA,QAULlD,gBAAAsC,KAAKa,EAAAA,gBAALX,MAAqBrE,EAAAA,WAAU,WAAO,MAAAiF,QAGtCzC,WAAA2B,KAAKY,EAAAA,QAoBLvE,cAAA2D,KAAKe,EAAAA,SAGLxE,SAAAyD,KAAKe,EAAAA,UA2JLjF,KAGAgF,EAAA,WA0EI,QAAJA,GAC2BE,EACXC,EACAC,EACAC,GAHWhF,KAA3B6E,kBAA2BA,EACX7E,KAAhB8E,kBAAgBA,EACA9E,KAAhB+E,aAAgBA,EACA/E,KAAhBgF,QAAgBA,EAXOhF,KAAvBI,OACQ,GAAID,GAAAA,aAEAH,KAAZiF,kBAA+B,EACnBjF,KAAZkF,UAAuB,EACXlF,KAAZO,WAAiC,EAkEjC,MA5GIG,QAAJC,eACQgE,EADR/D,UAAA,eAAI,WAEI,MAAOZ,MAAK6E,kBAAoB7E,KAAK6E,kBAAkB5B,WAAWjD,MAAQA,KAAKkF,cAGnF,SAAYnF,GAChB,GAAcqB,GAAWP,EAAAA,sBAAsBd,EAEnCqB,KAAapB,KAAKkF,WAClBlF,KAAKkF,SAAW9D,EAEZpB,KAAK6E,mBACL7E,KAAK6E,kBAAkB/B,iBAAiB9C,KAAMA,KAAKkF,UAGvDlF,KAAK8E,kBAAkBrD,iDAe/Bf,OAAJC,eACQgE,EADR/D,UAAA,gBAAI,WAEI,MAAOZ,MAAKO,WAAcP,KAAK6E,mBAAqB7E,KAAK6E,kBAAkB3C,cAE/E,SAAanC,GAAkBC,KAAKO,UAAYM,EAAAA,sBAAsBd,oCAiBtE4E,EAAJ/D,UAAAc,SAAI,WACI1B,KAAKiF,iBAAmBjF,KAAK6E,oBAAsB7E,KAAK6E,kBAAkB7D,SAC1EhB,KAAK6D,KAAO7D,KAAKiF,iBAAmB,QAAU,WAE1CjF,KAAK6E,mBAAqB7E,KAAK6E,kBAAkB3B,aAAalD,QAC9DA,KAAKiC,SAAU,GAGnBjC,KAAK+E,aAAaI,QAAQnF,KAAKgF,QAAQI,eAAe,IAG1DT,EAAJ/D,UAAAyE,YAAI,WAAA,GAAJhC,GAAArD,KACcsF,EAAQtF,KAAK6E,iBAEnB7E,MAAK+E,aAAaQ,eAAevF,KAAKgF,QAAQI,eAI1CE,GAASA,EAAMrC,WAAWjD,OAC1BwF,QAAQC,UAAUC,KAAI,WAAO,MAAAJ,GAAMxC,iBAAiBO,GAAM,MAKlEsB,EAAJ/D,UAAA+E,MAAI,WACI3F,KAAKgF,QAAQI,cAAcO,SAI/BhB,EAAJ/D,UAAAgF,cAAI,WACI,IAAI5F,KAAKkC,SAAT,CAIR,GAAc2D,KAAa7F,KAAKiF,mBAA2BjF,KAAKkF,QAEpDW,KAAe7F,KAAKkF,WACpBlF,KAAKkF,SAAWW,EACZ7F,KAAK6E,oBACL7E,KAAK6E,kBAAkB/B,iBAAiB9C,KAAMA,KAAKkF,UAAU,GAC7DlF,KAAK6E,kBAAkBpE,cAI/BT,KAAKI,OAAOkB,KAAK,GAAIzB,GAAqBG,KAAMA,KAAKD,UAQzD4E,EAAJ/D,UAAAa,aAAI,WAGIzB,KAAK8E,kBAAkBrD,+BAxI/BoC,KAACiC,EAAAA,UAAD/B,OACIC,SAAU,mBACV+B,SAAU,kTAWVC,QAAS,osHACTC,cAAeC,EAAAA,kBAAkBC,KACjC7B,SAAU,iBACV8B,gBAAiBC,EAAAA,wBAAwBC,OACzCpC,MACIE,MAAO,mBACPmC,sCAAuC,qBAGvCC,kBAAmB,KACnBC,kBAAmB,mBACnBC,UAAW,mDAmDnB7C,KAA8ClE,EAA9CgH,aAAA9C,KAAS+C,EAAAA,aA1WT/C,KAAIU,EAAAA,oBAiBJV,KAASgD,EAAAA,eAbThD,KAAIiD,EAAAA,gCAyTJ7E,UAAA4B,KAAKY,EAAAA,QAsBLsC,WAAAlD,KAAKmD,EAAAA,UAALjD,MAAekD,EAAAA,UAAWC,QAAQ,MAGlCnH,QAAA8D,KAAKY,EAAAA,QAGL0C,WAAAtD,KAAKY,EAAAA,QAELvC,WAAA2B,KAAKY,EAAAA,QAOLrE,SAAAyD,KAAKe,EAAAA,UAuELD,KCvaAyC,EAAA,WAAA,QAAAA,MAKmC,sBALnCvD,KAACwD,EAAAA,SAADtD,OACIuD,SAAUC,EAAAA,eAAgBC,EAAAA,gBAC1BC,SAAUF,EAAAA,eAAgB5H,EAAqBgF,GAC/C+C,cAAe/H,EAAqBgF,OAExCyC"}
{"version":3,"sources":["../../../packages/mosaic/autocomplete/autocomplete.component.ts","../../../packages/mosaic/autocomplete/autocomplete-origin.directive.ts","../../../node_modules/tslib/tslib.es6.js","../../../packages/mosaic/autocomplete/autocomplete-trigger.directive.ts","../../../packages/mosaic/autocomplete/autocomplete.module.ts"],"names":["uniqueAutocompleteIdCounter","source","option","this","MC_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","McAutocomplete","changeDetectorRef","elementRef","defaults","id","showPanel","displayWith","optionSelected","EventEmitter","opened","closed","_classList","_isOpen","_openOnFocus","_autoActiveFirstOption","Object","defineProperty","prototype","value","_this","length","split","forEach","className","trim","nativeElement","coerceBooleanProperty","ngAfterContentInit","keyManager","ActiveDescendantKeyManager","options","setVisibility","setScrollTop","scrollTop","panel","getScrollTop","markForCheck","emitSelectEvent","event","McAutocompleteSelectedEvent","emit","onKeydown","Component","args","selector","exportAs","template","host","class","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","providers","provide","MC_OPTION_PARENT_COMPONENT","useExisting","ChangeDetectorRef","ElementRef","Inject","ViewChild","TemplateRef","static","ContentChildren","McOption","descendants","McOptgroup","Input","Output","Directive","create","__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","error","MC_AUTOCOMPLETE_SCROLL_STRATEGY","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","McAutocompleteTrigger","multi","getMcAutocompleteMissingPanelError","Error","viewContainerRef","zone","scrollStrategy","dir","formField","document","viewportRuler","optionSelections","defer","autocomplete","merge","apply","arguments","concat","__spread","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","autocompleteAttribute","_autocompleteDisabled","overlayAttached","componentDestroyed","viewportSubscription","Subscription","EMPTY","canOpenOnNextFocus","closeKeyEventStream","Subject","onChange","onTouched","windowBlurHandler","activeElement","panelOpen","window","runOutsideAngular","addEventListener","activeItem","ngOnDestroy","removeEventListener","unsubscribe","destroyPanel","complete","openPanel","attachOverlay","closePanel","isOpen","overlayRef","hasAttached","detach","closingActionsSubscription","detectChanges","updatePosition","tabOut","filter","getOutsideClickStream","detachments","observableOf","McOptionSelectionChange","writeValue","Promise","resolve","then","setTriggerValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","selectViaInteraction","resetActiveItem","prevActiveItem","TAB","DOWN_ARROW","canOpen","UP_ARROW","scrollToOption","handleInput","target","type","parseFloat","previousValue","handleFocus","openOnFocus","handleClick","$event","fromEvent","clickTarget","_elementRef","customOrigin","connectedTo","contains","overlayElement","index","activeItemIndex","labelCount","countGroupLabelsBeforeOption","optionGroups","newScrollPosition","getOptionScrollPosition","subscribeToClosingActions","firstStable","optionChanges","changes","tap","positionStrategy","reapplyLastPosition","delay","wasOpen","panelClosingActions","subscribe","setValueAndClose","dispose","toDisplay","inputValue","control","clearPreviousSelectedOption","focus","skip","selected","deselect","getConfig","setOrigin","getConnectedElement","updateSize","width","getPanelWidth","portal","TemplatePortal","getOverlayConfig","keydownEvents","altKey","change","attach","OverlayConfig","getOverlayPosition","direction","position","flexibleConnectedTo","withFlexibleDimensions","withPush","withPositions","originX","originY","overlayX","overlayY","panelClass","getConnectedOverlayOrigin","panelWidth","getHostWidth","getBoundingClientRect","setFirstItemActive","setActiveItem","element","readOnly","[attr.autocomplete]","(focusin)","(blur)","(input)","(keydown)","(click)","ViewContainerRef","NgZone","Directionality","decorators","Optional","McFormField","Host","DOCUMENT","ViewportRuler","NgModule","imports","McOptionModule","OverlayModule","McCommonModule","CommonModule","exports","McAutocompleteOrigin","declarations"],"mappings":"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","sourcesContent":["import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    AfterContentInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    InjectionToken,\n    Input,\n    Output,\n    QueryList,\n    TemplateRef,\n    ViewChild,\n    ViewEncapsulation\n} from '@angular/core';\nimport { ActiveDescendantKeyManager } from '@ptsecurity/cdk/a11y';\nimport { MC_OPTION_PARENT_COMPONENT, McOptgroup, McOption } from '@ptsecurity/mosaic/core';\n\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet uniqueAutocompleteIdCounter = 0;\n\nexport class McAutocompleteSelectedEvent {\n    constructor(public source: McAutocomplete, public option: McOption) {}\n}\n\n/** Default `mc-autocomplete` options that can be overridden. */\n// tslint:disable-next-line naming-convention\nexport interface McAutocompleteDefaultOptions {\n    /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n    autoActiveFirstOption?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mc-autocomplete`. */\nexport const MC_AUTOCOMPLETE_DEFAULT_OPTIONS =\n    new InjectionToken<McAutocompleteDefaultOptions>('mc-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n    });\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY(): McAutocompleteDefaultOptions {\n    return { autoActiveFirstOption: true };\n}\n\n@Component({\n    selector: 'mc-autocomplete',\n    exportAs: 'mcAutocomplete',\n    templateUrl: 'autocomplete.html',\n    styleUrls: ['autocomplete.scss'],\n    host: {\n        class: 'mc-autocomplete'\n    },\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [{\n        provide: MC_OPTION_PARENT_COMPONENT, useExisting: McAutocomplete\n    }]\n})\nexport class McAutocomplete implements AfterContentInit {\n    /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n    id: string = `mc-autocomplete-${uniqueAutocompleteIdCounter++}`;\n\n    /** Manages active item in option list based on key events. */\n    keyManager: ActiveDescendantKeyManager<McOption>;\n\n    /** Whether the autocomplete panel should be visible, depending on option length. */\n    showPanel: boolean = false;\n\n    @ViewChild(TemplateRef, {static: true}) template: TemplateRef<any>;\n\n    @ViewChild('panel', {static: false}) panel: ElementRef;\n\n    @ContentChildren(McOption, { descendants: true }) options: QueryList<McOption>;\n\n    @ContentChildren(McOptgroup) optionGroups: QueryList<McOptgroup>;\n\n    /** Function that maps an option's control value to its display value in the trigger. */\n    @Input() displayWith: ((value: any) => string) | null = null;\n\n    /**\n     * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n     * match the width of its host.\n     */\n    @Input() panelWidth: string | number;\n\n    /** Event that is emitted whenever an option from the list is selected. */\n    @Output() readonly optionSelected: EventEmitter<McAutocompleteSelectedEvent> =\n        new EventEmitter<McAutocompleteSelectedEvent>();\n\n    /** Event that is emitted when the autocomplete panel is opened. */\n    @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n    /** Event that is emitted when the autocomplete panel is closed. */\n    @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n    /**\n     * Takes classes set on the host mc-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    @Input('class')\n    get classList() {\n        return this._classList;\n    }\n\n    set classList(value: string) {\n        if (value && value.length) {\n            value.split(' ')\n                .forEach((className) => this._classList[className.trim()] = true);\n\n            this.elementRef.nativeElement.className = '';\n        }\n    }\n\n    private _classList: any = {};\n\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MC_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    @Input()\n    get autoActiveFirstOption(): boolean {\n        return this._autoActiveFirstOption;\n    }\n\n    set autoActiveFirstOption(value: boolean) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n\n    private _autoActiveFirstOption: boolean;\n\n    get isOpen(): boolean {\n        return this._isOpen && this.showPanel;\n    }\n\n    set isOpen(value: boolean) {\n        this._isOpen = value;\n    }\n\n    private _isOpen: boolean = false;\n\n    @Input()\n    get openOnFocus(): boolean {\n        return this._openOnFocus;\n    }\n\n    set openOnFocus(value: boolean) {\n        this._openOnFocus = value;\n    }\n\n    private _openOnFocus: boolean = true;\n\n    constructor(\n        private changeDetectorRef: ChangeDetectorRef,\n        private elementRef: ElementRef<HTMLElement>,\n        @Inject(MC_AUTOCOMPLETE_DEFAULT_OPTIONS) defaults: McAutocompleteDefaultOptions\n    ) {\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n    }\n\n    ngAfterContentInit() {\n        this.keyManager = new ActiveDescendantKeyManager<McOption>(this.options);\n        this.setVisibility();\n    }\n\n    setScrollTop(scrollTop: number): void {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n\n    getScrollTop(): number {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n\n    setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._classList['mc-autocomplete_visible'] = this.showPanel;\n        this._classList['mc-autocomplete_hidden'] = !this.showPanel;\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    emitSelectEvent(option: McOption): void {\n        const event = new McAutocompleteSelectedEvent(this, option);\n\n        this.optionSelected.emit(event);\n    }\n\n    onKeydown(event: KeyboardEvent): any {\n        this.keyManager.onKeydown(event);\n    }\n}\n\n","import { Directive, ElementRef } from '@angular/core';\n\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n    selector: '[mcAutocompleteOrigin]',\n    exportAs: 'mcAutocompleteOrigin'\n})\nexport class McAutocompleteOrigin {\n    constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || from);\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","import { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    ConnectedPosition,\n    FlexibleConnectedPositionStrategy,\n    Overlay,\n    OverlayConfig,\n    OverlayRef,\n    PositionStrategy,\n    ScrollStrategy\n} from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport {\n    ChangeDetectorRef,\n    Directive,\n    ElementRef,\n    forwardRef,\n    Host,\n    Inject,\n    InjectionToken,\n    Input,\n    NgZone,\n    OnDestroy,\n    Optional,\n    ViewContainerRef\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@ptsecurity/cdk/keycodes';\nimport {\n    countGroupLabelsBeforeOption,\n    getOptionScrollPosition,\n    McOption,\n    McOptionSelectionChange\n} from '@ptsecurity/mosaic/core';\nimport { McFormField } from '@ptsecurity/mosaic/form-field';\nimport { Subscription, defer, fromEvent, merge, of as observableOf, Subject, Observable } from 'rxjs';\nimport { filter, take, switchMap, delay, tap, map } from 'rxjs/operators';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n\n/** The height of each autocomplete option. */\nexport const AUTOCOMPLETE_OPTION_HEIGHT = 32;\n\n/** The total height of the autocomplete panel. */\nexport const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n\nexport const AUTOCOMPLETE_BORDER_WIDTH: number = 2;\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY =\n    new InjectionToken<() => ScrollStrategy>('mc-autocomplete-scroll-strategy');\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n    return () => overlay.scrollStrategies.reposition();\n}\n\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MC_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McAutocompleteTrigger),\n    multi: true\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMcAutocompleteMissingPanelError(): Error {\n    return Error('Attempting to open an undefined instance of `mc-autocomplete`. ' +\n        'Make sure that the id passed to the `mcAutocomplete` is correct and that ' +\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\n\n\n@Directive({\n    selector: `input[mcAutocomplete], textarea[mcAutocomplete]`,\n    host: {\n        class: 'mc-autocomplete-trigger',\n        '[attr.autocomplete]': 'autocompleteAttribute',\n        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n        // a little earlier. This avoids issues where IE delays the focusing of the input.\n        '(focusin)': 'handleFocus()',\n        '(blur)': 'onTouched()',\n        '(input)': 'handleInput($event)',\n        '(keydown)': 'handleKeydown($event)',\n        '(click)': 'handleClick($event)'\n    },\n    exportAs: 'mcAutocompleteTrigger',\n    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n})\nexport class McAutocompleteTrigger implements ControlValueAccessor, OnDestroy {\n    // @ts-ignore\n    readonly optionSelections: Observable<McOptionSelectionChange> = defer(() => {\n        if (this.autocomplete && this.autocomplete.options) {\n            return merge(...this.autocomplete.options.map((option) => option.onSelectionChange));\n        }\n\n        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n        return this.zone.onStable\n            .asObservable()\n            .pipe(take(1), switchMap(() => this.optionSelections));\n    });\n\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption(): McOption | null {\n        if (this.autocomplete && this.autocomplete.keyManager) {\n            return this.autocomplete.keyManager.activeItem;\n        }\n\n        return null;\n    }\n\n    get panelOpen(): boolean {\n        return this.overlayAttached && this.autocomplete.showPanel;\n    }\n\n    /** The autocomplete panel to be attached to this trigger. */\n    @Input('mcAutocomplete') autocomplete: McAutocomplete;\n\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     */\n    @Input('mcAutocompleteConnectedTo') connectedTo: McAutocompleteOrigin;\n\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * @docs-private\n     */\n    @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    @Input('mcAutocompleteDisabled')\n    get autocompleteDisabled(): boolean {\n        return this._autocompleteDisabled;\n    }\n\n    set autocompleteDisabled(value: boolean) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n\n    private _autocompleteDisabled = false;\n\n    private overlayAttached: boolean = false;\n\n    private overlayRef: OverlayRef | null;\n\n    private portal: TemplatePortal;\n\n    private componentDestroyed = false;\n\n    private scrollStrategy: () => ScrollStrategy;\n\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n    private previousValue: string | number | null;\n\n    /** Strategy that is used to position the panel. */\n    private positionStrategy: FlexibleConnectedPositionStrategy;\n\n    /** The subscription for closing actions (some are bound to document). */\n    private closingActionsSubscription: Subscription;\n\n    /** Subscription to viewport size changes. */\n    private viewportSubscription = Subscription.EMPTY;\n\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     */\n    private canOpenOnNextFocus = true;\n\n    /** Stream of keyboard events that can close the panel. */\n    private readonly closeKeyEventStream = new Subject<void>();\n\n    constructor(\n        private elementRef: ElementRef<HTMLInputElement>,\n        private viewContainerRef: ViewContainerRef,\n        private changeDetectorRef: ChangeDetectorRef,\n        private overlay: Overlay,\n        private zone: NgZone,\n        @Inject(MC_AUTOCOMPLETE_SCROLL_STRATEGY) scrollStrategy: any,\n        @Optional() private dir: Directionality,\n        @Optional() @Host() private formField: McFormField,\n        @Optional() @Inject(DOCUMENT) private document: any,\n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        private viewportRuler?: ViewportRuler\n    ) {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            zone.runOutsideAngular(() => {\n                window.addEventListener('blur', this.windowBlurHandler);\n            });\n        }\n\n        this.scrollStrategy = scrollStrategy;\n    }\n\n    ngOnDestroy() {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this.windowBlurHandler);\n        }\n\n        this.viewportSubscription.unsubscribe();\n        this.componentDestroyed = true;\n        this.destroyPanel();\n        this.closeKeyEventStream.complete();\n    }\n\n    /** `View -> model callback called when value changes` */\n    // tslint:disable-next-line no-empty\n    onChange: (value: any) => void = () => {};\n\n    /** `View -> model callback called when autocomplete has been touched` */\n    // tslint:disable-next-line no-empty\n    onTouched: () => void = () => {};\n\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void {\n        this.attachOverlay();\n    }\n\n    closePanel(): void {\n        if (!this.overlayAttached) { return; }\n\n        if (this.panelOpen) {\n            this.autocomplete.closed.emit();\n        }\n\n        this.autocomplete.isOpen = this.overlayAttached = false;\n\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n            this.overlayRef.detach();\n            this.closingActionsSubscription.unsubscribe();\n        }\n\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this.componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this.changeDetectorRef.detectChanges();\n        }\n    }\n\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition(): void {\n        if (this.overlayAttached) {\n            this.overlayRef!.updatePosition();\n        }\n    }\n\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions(): Observable<McOptionSelectionChange | null> {\n        return merge(\n            this.optionSelections,\n            this.autocomplete.keyManager.tabOut.pipe(filter(() => this.overlayAttached)),\n            this.closeKeyEventStream,\n            this.getOutsideClickStream(),\n            this.overlayRef ?\n                this.overlayRef.detachments().pipe(filter(() => this.overlayAttached)) :\n                observableOf()\n        ).pipe(\n            // Normalize the output so we return a consistent type.\n            map((event) => event instanceof McOptionSelectionChange ? event : null)\n        );\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value: any): void {\n        Promise.resolve(null).then(() => this.setTriggerValue(value));\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn: (value: any) => {}): void {\n        this.onChange = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn: () => {}) {\n        this.onTouched = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled: boolean) {\n        this.elementRef.nativeElement.disabled = isDisabled;\n    }\n\n    handleKeydown(event: KeyboardEvent): void {\n        // tslint:disable-next-line deprecation\n        const keyCode = event.keyCode;\n\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE) {\n            event.preventDefault();\n        }\n\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n            this.activeOption.selectViaInteraction();\n            this.resetActiveItem();\n            event.preventDefault();\n        } else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete.keyManager.activeItem;\n\n            if (this.panelOpen || keyCode === TAB) {\n                this.autocomplete.onKeydown(event);\n            } else if (keyCode === DOWN_ARROW && this.canOpen()) {\n                this.openPanel();\n            }\n\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n            if (isArrowKey || this.autocomplete.keyManager.activeItem !== prevActiveItem) {\n                this.scrollToOption();\n            }\n        }\n    }\n\n    handleInput(event: KeyboardEvent): void {\n        const target = event.target as HTMLInputElement;\n        let value: number | string | null = target.value;\n\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value === '' ? null : parseFloat(value);\n        }\n\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this.previousValue !== value) {\n            this.previousValue = value;\n            this.onChange(value);\n\n            if (this.canOpen() && this.document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n\n    handleFocus(): void {\n        if (!this.canOpenOnNextFocus) {\n            this.canOpenOnNextFocus = true;\n        } else if (this.canOpen() && this.autocomplete.openOnFocus) {\n            this.previousValue = this.elementRef.nativeElement.value;\n            this.attachOverlay();\n        }\n    }\n\n    handleClick($event: MouseEvent) {\n        if (this.canOpen() && this.document.activeElement === $event.target) {\n            this.openPanel();\n        }\n    }\n\n    /** Stream of clicks outside of the autocomplete panel. */\n    private getOutsideClickStream(): Observable<any> {\n        return merge(\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'click') as Observable<MouseEvent>,\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'touchend') as Observable<TouchEvent>\n        )\n            .pipe(filter((event) => {\n\n                const clickTarget = event.target as HTMLElement;\n                const formField = this.formField ? this.formField._elementRef.nativeElement : null;\n                const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\n\n                return this.overlayAttached &&\n                    clickTarget !== this.elementRef.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!customOrigin || !customOrigin.contains(clickTarget)) &&\n                    (!!this.overlayRef && !this.overlayRef.overlayElement.contains(clickTarget));\n            }));\n    }\n\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     */\n    private windowBlurHandler = () => {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        this.canOpenOnNextFocus = this.document.activeElement !== this.elementRef.nativeElement || this.panelOpen;\n    }\n\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     */\n    private scrollToOption(): void {\n        const index = this.autocomplete.keyManager.activeItemIndex || 0;\n        const labelCount = countGroupLabelsBeforeOption(\n            index,\n            this.autocomplete.options, this.autocomplete.optionGroups\n        );\n\n        const newScrollPosition = getOptionScrollPosition(\n            index + labelCount,\n            AUTOCOMPLETE_OPTION_HEIGHT,\n            this.autocomplete.getScrollTop(),\n            AUTOCOMPLETE_PANEL_HEIGHT\n        );\n\n        this.autocomplete.setScrollTop(newScrollPosition);\n    }\n\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private subscribeToClosingActions(): Subscription {\n        const firstStable = this.zone.onStable.asObservable()\n            .pipe(take(1));\n        const optionChanges = this.autocomplete.options.changes\n            .pipe(\n                tap(() => this.positionStrategy.reapplyLastPosition()),\n                // Defer emitting to the stream until the next tick, because changing\n                // bindings in here will cause \"changed after checked\" errors.\n                delay(0)\n            );\n\n        // When the zone is stable initially, and when the option list changes...\n        return merge(firstStable, optionChanges)\n            .pipe(\n                // create a new stream of panelClosingActions, replacing any previous streams\n                // that were created, and flatten it so our stream only emits closing events...\n                switchMap(() => {\n                    const wasOpen = this.panelOpen;\n                    this.resetActiveItem();\n                    this.autocomplete.setVisibility();\n\n                    if (this.panelOpen) {\n                        this.overlayRef!.updatePosition();\n\n                        // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                        // event, because we may not have emitted it when the panel was attached. This\n                        // can happen if the users opens the panel and there are no options, but the\n                        // options come in slightly later or as a result of the value changing.\n                        if (wasOpen !== this.panelOpen) {\n                            this.autocomplete.opened.emit();\n                        }\n                    }\n\n                    return this.panelClosingActions;\n                }),\n                // when the first closing event occurs...\n                take(1)\n            )\n            // set the value, close the panel, and complete.\n            .subscribe((event) => this.setValueAndClose(event));\n    }\n\n    /** Destroys the autocomplete suggestion panel. */\n    private destroyPanel(): void {\n        if (this.overlayRef) {\n            this.closePanel();\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n\n    private setTriggerValue(value: any): void {\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n            this.autocomplete.displayWith(value) :\n            value;\n\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        const inputValue = toDisplay != null ? toDisplay : '';\n\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this.formField) {\n            this.formField.control.value = inputValue;\n        } else {\n            this.elementRef.nativeElement.value = inputValue;\n        }\n\n        this.previousValue = inputValue;\n    }\n\n    /** This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    private setValueAndClose(event: McOptionSelectionChange | null): void {\n        if (event && event.source) {\n            this.clearPreviousSelectedOption(event.source);\n            this.setTriggerValue(event.source.value);\n            this.onChange(event.source.value);\n            this.elementRef.nativeElement.focus();\n\n            this.autocomplete.emitSelectEvent(event.source);\n        }\n\n        this.closePanel();\n    }\n\n    /** Clear any previous selected option and emit a selection change event for this option */\n    private clearPreviousSelectedOption(skip: McOption) {\n        this.autocomplete.options.forEach((option) => {\n            if (option !== skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n\n    private attachOverlay(): void {\n        if (!this.autocomplete) {\n            throw getMcAutocompleteMissingPanelError();\n        }\n\n        let overlayRef = this.overlayRef;\n\n        if (!overlayRef) {\n            this.portal = new TemplatePortal(this.autocomplete.template, this.viewContainerRef);\n            overlayRef = this.overlay.create(this.getOverlayConfig());\n            this.overlayRef = overlayRef;\n\n            // Use the `keydownEvents` in order to take advantage of\n            // the overlay event targeting provided by the CDK overlay.\n            overlayRef.keydownEvents().subscribe((event) => {\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                // tslint:disable-next-line deprecation\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\n                    this.resetActiveItem();\n                    this.closeKeyEventStream.next();\n                }\n            });\n\n            if (this.viewportRuler) {\n                this.viewportSubscription = this.viewportRuler.change().subscribe(() => {\n                    if (this.panelOpen && overlayRef) {\n                        overlayRef.updateSize({ width: this.getPanelWidth() });\n                    }\n                });\n            }\n        } else {\n            const position = overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;\n\n            // Update the trigger, panel width and direction, in case anything has changed.\n            position.setOrigin(this.getConnectedElement());\n            overlayRef.updateSize({ width: this.getPanelWidth() });\n        }\n\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this.portal);\n            this.closingActionsSubscription = this.subscribeToClosingActions();\n        }\n\n        const wasOpen = this.panelOpen;\n\n        this.autocomplete.setVisibility();\n        this.autocomplete.isOpen = this.overlayAttached = true;\n\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n\n    private getOverlayConfig(): OverlayConfig {\n        return new OverlayConfig({\n            positionStrategy: this.getOverlayPosition(),\n            scrollStrategy: this.scrollStrategy(),\n            width: this.getPanelWidth(),\n            direction: this.dir\n        });\n    }\n\n    private getOverlayPosition(): PositionStrategy {\n        this.positionStrategy = this.overlay.position()\n            .flexibleConnectedTo(this.getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withPositions([\n                {\n                    originX: 'start',\n                    originY: 'bottom',\n                    overlayX: 'start',\n                    overlayY: 'top'\n                },\n                {\n                    originX: 'start',\n                    originY: 'top',\n                    overlayX: 'start',\n                    overlayY: 'bottom',\n\n                    // The overlay edge connected to the trigger should have squared corners, while\n                    // the opposite end has rounded corners. We apply a CSS class to swap the\n                    // border-radius based on the overlay position.\n                    panelClass: 'mc-autocomplete-panel-above'\n                }\n            ] as ConnectedPosition[]);\n\n        return this.positionStrategy;\n    }\n\n    private getConnectedElement(): ElementRef<HTMLElement> {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n\n        return this.formField ? this.formField.getConnectedOverlayOrigin() : this.elementRef;\n    }\n\n    private getPanelWidth(): number | string {\n        return this.autocomplete.panelWidth || this.getHostWidth() - AUTOCOMPLETE_BORDER_WIDTH;\n    }\n\n    private getHostWidth(): number {\n        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     */\n    private resetActiveItem(): void {\n        if (this.autocomplete.autoActiveFirstOption) {\n            this.autocomplete.keyManager.setFirstItemActive();\n        } else {\n            this.autocomplete.keyManager.setActiveItem(-1);\n        }\n    }\n\n    private canOpen(): boolean {\n        const element = this.elementRef.nativeElement;\n\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n}\n","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { McOptionModule, McCommonModule } from '@ptsecurity/mosaic/core';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport {\n    McAutocompleteTrigger,\n    MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER\n} from './autocomplete-trigger.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n@NgModule({\n    imports: [McOptionModule, OverlayModule, McCommonModule, CommonModule],\n    exports: [\n        McAutocomplete,\n        McOptionModule,\n        McAutocompleteTrigger,\n        McAutocompleteOrigin,\n        McCommonModule\n    ],\n    declarations: [McAutocomplete, McAutocompleteTrigger, McAutocompleteOrigin],\n    providers: [MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]\n})\nexport class McAutocompleteModule {}\n"]}
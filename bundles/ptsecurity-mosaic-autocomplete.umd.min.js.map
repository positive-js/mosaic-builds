{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@ptsecurity/mosaic/autocomplete/autocomplete.component.ts","ng://@ptsecurity/mosaic/autocomplete/autocomplete-origin.directive.ts","ng://@ptsecurity/mosaic/autocomplete/autocomplete-trigger.directive.ts","ng://@ptsecurity/mosaic/autocomplete/autocomplete.module.ts"],"names":["__read","o","n","m","Symbol","iterator","r","e","i","call","ar","next","done","push","value","error","uniqueAutocompleteIdCounter","source","option","this","MC_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","factory","MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","McAutocomplete","changeDetectorRef","elementRef","defaults","id","showPanel","displayWith","optionSelected","EventEmitter","opened","closed","_classList","_isOpen","_autoActiveFirstOption","Object","defineProperty","prototype","_this","length","split","forEach","className","trim","nativeElement","coerceBooleanProperty","ngAfterContentInit","keyManager","ActiveDescendantKeyManager","options","setVisibility","setScrollTop","scrollTop","panel","getScrollTop","markForCheck","emitSelectEvent","event","McAutocompleteSelectedEvent","emit","onKeydown","Component","args","selector","exportAs","template","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","host","class","providers","provide","MC_OPTION_PARENT_COMPONENT","useExisting","ChangeDetectorRef","ElementRef","Inject","ViewChild","TemplateRef","static","ContentChildren","McOption","descendants","McOptgroup","Input","Output","McAutocompleteOrigin","Directive","MC_AUTOCOMPLETE_SCROLL_STRATEGY","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","overlay","scrollStrategies","reposition","MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","McAutocompleteTrigger","multi","getMcAutocompleteMissingPanelError","Error","viewContainerRef","zone","scrollStrategy","dir","formField","document","viewportRuler","optionSelections","defer","autocomplete","merge","apply","arguments","concat","__spread","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","autocompleteAttribute","_autocompleteDisabled","overlayAttached","componentDestroyed","viewportSubscription","Subscription","EMPTY","canOpenOnNextFocus","closeKeyEventStream","Subject","onChange","onTouched","windowBlurHandler","activeElement","panelOpen","window","runOutsideAngular","addEventListener","activeItem","ngOnDestroy","removeEventListener","unsubscribe","destroyPanel","complete","openPanel","attachOverlay","closePanel","isOpen","overlayRef","hasAttached","detach","closingActionsSubscription","detectChanges","updatePosition","tabOut","filter","getOutsideClickStream","detachments","observableOf","McOptionSelectionChange","writeValue","Promise","resolve","then","setTriggerValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","selectViaInteraction","resetActiveItem","prevActiveItem","TAB","DOWN_ARROW","canOpen","UP_ARROW","scrollToOption","handleInput","target","type","parseFloat","previousValue","handleFocus","handleClick","$event","fromEvent","clickTarget","_elementRef","contains","overlayElement","index","activeItemIndex","labelCount","countGroupLabelsBeforeOption","optionGroups","newScrollPosition","getOptionScrollPosition","subscribeToClosingActions","firstStable","optionChanges","changes","tap","positionStrategy","reapplyLastPosition","delay","wasOpen","panelClosingActions","subscribe","setValueAndClose","dispose","toDisplay","inputValue","control","clearPreviousSelectedOption","focus","skip","selected","deselect","getConfig","setOrigin","getConnectedElement","updateSize","width","getPanelWidth","portal","TemplatePortal","create","getOverlayConfig","keydownEvents","altKey","change","attach","OverlayConfig","getOverlayPosition","direction","position","flexibleConnectedTo","withFlexibleDimensions","withPush","withPositions","originX","originY","overlayX","overlayY","panelClass","connectedTo","getConnectedOverlayOrigin","panelWidth","getHostWidth","getBoundingClientRect","setActiveItem","element","readOnly","[attr.autocomplete]","(focusin)","(blur)","(input)","(keydown)","(click)","ViewContainerRef","NgZone","Directionality","decorators","Optional","McFormField","Host","DOCUMENT","ViewportRuler","McAutocompleteModule","NgModule","imports","McOptionModule","OverlayModule","McCommonModule","CommonModule","exports","declarations"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    AfterContentInit,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    ElementRef,\n    EventEmitter,\n    Inject,\n    InjectionToken,\n    Input,\n    Output,\n    QueryList,\n    TemplateRef,\n    ViewChild,\n    ViewEncapsulation\n} from '@angular/core';\nimport { ActiveDescendantKeyManager } from '@ptsecurity/cdk/a11y';\nimport { MC_OPTION_PARENT_COMPONENT, McOptgroup, McOption } from '@ptsecurity/mosaic/core';\n\n\n/**\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet uniqueAutocompleteIdCounter = 0;\n\nexport class McAutocompleteSelectedEvent {\n    constructor(public source: McAutocomplete, public option: McOption) {}\n}\n\n/** Default `mc-autocomplete` options that can be overridden. */\n// tslint:disable-next-line naming-convention\nexport interface McAutocompleteDefaultOptions {\n    /** Whether the first option should be highlighted when an autocomplete panel is opened. */\n    autoActiveFirstOption?: boolean;\n}\n\n/** Injection token to be used to override the default options for `mc-autocomplete`. */\nexport const MC_AUTOCOMPLETE_DEFAULT_OPTIONS =\n    new InjectionToken<McAutocompleteDefaultOptions>('mc-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY\n    });\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY(): McAutocompleteDefaultOptions {\n    return { autoActiveFirstOption: true };\n}\n\n@Component({\n    selector: 'mc-autocomplete',\n    exportAs: 'mcAutocomplete',\n    templateUrl: 'autocomplete.html',\n    styleUrls: ['autocomplete.scss'],\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    host: { class: 'mc-autocomplete' },\n    providers: [\n        { provide: MC_OPTION_PARENT_COMPONENT, useExisting: McAutocomplete }\n    ]\n})\nexport class McAutocomplete implements AfterContentInit {\n    /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n    id: string = `mc-autocomplete-${uniqueAutocompleteIdCounter++}`;\n\n    /** Manages active item in option list based on key events. */\n    keyManager: ActiveDescendantKeyManager<McOption>;\n\n    /** Whether the autocomplete panel should be visible, depending on option length. */\n    showPanel: boolean = false;\n\n    @ViewChild(TemplateRef, {static: true}) template: TemplateRef<any>;\n\n    @ViewChild('panel', {static: false}) panel: ElementRef;\n\n    @ContentChildren(McOption, { descendants: true }) options: QueryList<McOption>;\n\n    @ContentChildren(McOptgroup) optionGroups: QueryList<McOptgroup>;\n\n    /** Function that maps an option's control value to its display value in the trigger. */\n    @Input() displayWith: ((value: any) => string) | null = null;\n\n    /**\n     * Specify the width of the autocomplete panel.  Can be any CSS sizing value, otherwise it will\n     * match the width of its host.\n     */\n    @Input() panelWidth: string | number;\n\n    /** Event that is emitted whenever an option from the list is selected. */\n    @Output() readonly optionSelected: EventEmitter<McAutocompleteSelectedEvent> =\n        new EventEmitter<McAutocompleteSelectedEvent>();\n\n    /** Event that is emitted when the autocomplete panel is opened. */\n    @Output() readonly opened: EventEmitter<void> = new EventEmitter<void>();\n\n    /** Event that is emitted when the autocomplete panel is closed. */\n    @Output() readonly closed: EventEmitter<void> = new EventEmitter<void>();\n\n    /**\n     * Takes classes set on the host mc-autocomplete element and applies them to the panel\n     * inside the overlay container to allow for easy styling.\n     */\n    get classList() {\n        return this._classList;\n    }\n\n    @Input('class')\n    set classList(value: string) {\n        if (value && value.length) {\n            value.split(' ')\n                .forEach((className) => this._classList[className.trim()] = true);\n\n            this.elementRef.nativeElement.className = '';\n        }\n    }\n\n    private _classList: any = {};\n\n    /**\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\n     * Can be configured globally through the `MC_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n     */\n    @Input()\n    get autoActiveFirstOption(): boolean {\n        return this._autoActiveFirstOption;\n    }\n\n    set autoActiveFirstOption(value: boolean) {\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\n    }\n\n    private _autoActiveFirstOption: boolean;\n\n    get isOpen(): boolean {\n        return this._isOpen && this.showPanel;\n    }\n\n    set isOpen(value: boolean) {\n        this._isOpen = value;\n    }\n\n    private _isOpen: boolean = false;\n\n    constructor(\n        private changeDetectorRef: ChangeDetectorRef,\n        private elementRef: ElementRef<HTMLElement>,\n        @Inject(MC_AUTOCOMPLETE_DEFAULT_OPTIONS) defaults: McAutocompleteDefaultOptions\n    ) {\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n    }\n\n    ngAfterContentInit() {\n        this.keyManager = new ActiveDescendantKeyManager<McOption>(this.options);\n        this.setVisibility();\n    }\n\n    setScrollTop(scrollTop: number): void {\n        if (this.panel) {\n            this.panel.nativeElement.scrollTop = scrollTop;\n        }\n    }\n\n    getScrollTop(): number {\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\n    }\n\n    setVisibility() {\n        this.showPanel = !!this.options.length;\n        this._classList['mc-autocomplete_visible'] = this.showPanel;\n        this._classList['mc-autocomplete_hidden'] = !this.showPanel;\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    emitSelectEvent(option: McOption): void {\n        const event = new McAutocompleteSelectedEvent(this, option);\n\n        this.optionSelected.emit(event);\n    }\n\n    onKeydown(event: KeyboardEvent): any {\n        this.keyManager.onKeydown(event);\n    }\n}\n\n","import { Directive, ElementRef } from '@angular/core';\n\n\n/**\n * Directive applied to an element to make it usable\n * as a connection point for an autocomplete panel.\n */\n@Directive({\n    selector: '[mcAutocompleteOrigin]',\n    exportAs: 'mcAutocompleteOrigin'\n})\nexport class McAutocompleteOrigin {\n    constructor(public elementRef: ElementRef<HTMLElement>) {}\n}\n","import { Directionality } from '@angular/cdk/bidi';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    ConnectedPosition,\n    FlexibleConnectedPositionStrategy,\n    Overlay,\n    OverlayConfig,\n    OverlayRef,\n    PositionStrategy,\n    ScrollStrategy\n} from '@angular/cdk/overlay';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { ViewportRuler } from '@angular/cdk/scrolling';\nimport { DOCUMENT } from '@angular/common';\nimport {\n    ChangeDetectorRef,\n    Directive,\n    ElementRef,\n    forwardRef,\n    Host,\n    Inject,\n    InjectionToken,\n    Input,\n    NgZone,\n    OnDestroy,\n    Optional,\n    ViewContainerRef\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOWN_ARROW, ENTER, ESCAPE, TAB, UP_ARROW } from '@ptsecurity/cdk/keycodes';\nimport {\n    countGroupLabelsBeforeOption,\n    getOptionScrollPosition,\n    McOption,\n    McOptionSelectionChange\n} from '@ptsecurity/mosaic/core';\nimport { McFormField } from '@ptsecurity/mosaic/form-field';\nimport { Subscription, defer, fromEvent, merge, of as observableOf, Subject, Observable } from 'rxjs';\nimport { filter, take, switchMap, delay, tap, map } from 'rxjs/operators';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the scrollTop of the panel. Because we are not\n * actually focusing the active item, scroll must be handled manually.\n */\n\n/** The height of each autocomplete option. */\nexport const AUTOCOMPLETE_OPTION_HEIGHT = 32;\n\n/** The total height of the autocomplete panel. */\nexport const AUTOCOMPLETE_PANEL_HEIGHT = 256;\n\nexport const AUTOCOMPLETE_BORDER_WIDTH: number = 2;\n\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY =\n    new InjectionToken<() => ScrollStrategy>('mc-autocomplete-scroll-strategy');\n\n// tslint:disable-next-line naming-convention\nexport function MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay: Overlay): () => ScrollStrategy {\n    return () => overlay.scrollStrategies.reposition();\n}\n\nexport const MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n    provide: MC_AUTOCOMPLETE_SCROLL_STRATEGY,\n    deps: [Overlay],\n    useFactory: MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY\n};\n\n/**\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\n * @docs-private\n */\nexport const MAT_AUTOCOMPLETE_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McAutocompleteTrigger),\n    multi: true\n};\n\n/**\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n * @docs-private\n */\nexport function getMcAutocompleteMissingPanelError(): Error {\n    return Error('Attempting to open an undefined instance of `mc-autocomplete`. ' +\n        'Make sure that the id passed to the `mcAutocomplete` is correct and that ' +\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\n}\n\n\n@Directive({\n    selector: `input[mcAutocomplete], textarea[mcAutocomplete]`,\n    host: {\n        class: 'mc-autocomplete-trigger',\n        '[attr.autocomplete]': 'autocompleteAttribute',\n        // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n        // a little earlier. This avoids issues where IE delays the focusing of the input.\n        '(focusin)': 'handleFocus()',\n        '(blur)': 'onTouched()',\n        '(input)': 'handleInput($event)',\n        '(keydown)': 'handleKeydown($event)',\n        '(click)': 'handleClick($event)'\n    },\n    exportAs: 'mcAutocompleteTrigger',\n    providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n})\nexport class McAutocompleteTrigger implements ControlValueAccessor, OnDestroy {\n    // @ts-ignore\n    readonly optionSelections: Observable<McOptionSelectionChange> = defer(() => {\n        if (this.autocomplete && this.autocomplete.options) {\n            return merge(...this.autocomplete.options.map((option) => option.onSelectionChange));\n        }\n\n        // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n        // Return a stream that we'll replace with the real one once everything is in place.\n        return this.zone.onStable\n            .asObservable()\n            .pipe(take(1), switchMap(() => this.optionSelections));\n    });\n\n    /** The currently active option, coerced to MatOption type. */\n    get activeOption(): McOption | null {\n        if (this.autocomplete && this.autocomplete.keyManager) {\n            return this.autocomplete.keyManager.activeItem;\n        }\n\n        return null;\n    }\n\n    get panelOpen(): boolean {\n        return this.overlayAttached && this.autocomplete.showPanel;\n    }\n\n    /** The autocomplete panel to be attached to this trigger. */\n    @Input('mcAutocomplete') autocomplete: McAutocomplete;\n\n    /**\n     * Reference relative to which to position the autocomplete panel.\n     * Defaults to the autocomplete trigger element.\n     */\n    @Input('mcAutocompleteConnectedTo') connectedTo: McAutocompleteOrigin;\n\n    /**\n     * `autocomplete` attribute to be set on the input element.\n     * @docs-private\n     */\n    @Input('autocomplete') autocompleteAttribute: string = 'off';\n\n    /**\n     * Whether the autocomplete is disabled. When disabled, the element will\n     * act as a regular input and the user won't be able to open the panel.\n     */\n    @Input('mcAutocompleteDisabled')\n    get autocompleteDisabled(): boolean {\n        return this._autocompleteDisabled;\n    }\n\n    set autocompleteDisabled(value: boolean) {\n        this._autocompleteDisabled = coerceBooleanProperty(value);\n    }\n\n    private _autocompleteDisabled = false;\n\n    private overlayAttached: boolean = false;\n\n    private overlayRef: OverlayRef | null;\n\n    private portal: TemplatePortal;\n\n    private componentDestroyed = false;\n\n    private scrollStrategy: () => ScrollStrategy;\n\n    /** Old value of the native input. Used to work around issues with the `input` event on IE. */\n    private previousValue: string | number | null;\n\n    /** Strategy that is used to position the panel. */\n    private positionStrategy: FlexibleConnectedPositionStrategy;\n\n    /** The subscription for closing actions (some are bound to document). */\n    private closingActionsSubscription: Subscription;\n\n    /** Subscription to viewport size changes. */\n    private viewportSubscription = Subscription.EMPTY;\n\n    /**\n     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n     * closed autocomplete from being reopened if the user switches to another browser tab and then\n     * comes back.\n     */\n    private canOpenOnNextFocus = true;\n\n    /** Stream of keyboard events that can close the panel. */\n    private readonly closeKeyEventStream = new Subject<void>();\n\n    constructor(\n        private elementRef: ElementRef<HTMLInputElement>,\n        private viewContainerRef: ViewContainerRef,\n        private changeDetectorRef: ChangeDetectorRef,\n        private overlay: Overlay,\n        private zone: NgZone,\n        @Inject(MC_AUTOCOMPLETE_SCROLL_STRATEGY) scrollStrategy: any,\n        @Optional() private dir: Directionality,\n        @Optional() @Host() private formField: McFormField,\n        @Optional() @Inject(DOCUMENT) private document: any,\n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        private viewportRuler?: ViewportRuler\n    ) {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            zone.runOutsideAngular(() => {\n                window.addEventListener('blur', this.windowBlurHandler);\n            });\n        }\n\n        this.scrollStrategy = scrollStrategy;\n    }\n\n    ngOnDestroy() {\n        // tslint:disable-next-line no-typeof-undefined\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('blur', this.windowBlurHandler);\n        }\n\n        this.viewportSubscription.unsubscribe();\n        this.componentDestroyed = true;\n        this.destroyPanel();\n        this.closeKeyEventStream.complete();\n    }\n\n    /** `View -> model callback called when value changes` */\n    // tslint:disable-next-line no-empty\n    onChange: (value: any) => void = () => {};\n\n    /** `View -> model callback called when autocomplete has been touched` */\n    // tslint:disable-next-line no-empty\n    onTouched: () => void = () => {};\n\n    /** Opens the autocomplete suggestion panel. */\n    openPanel(): void {\n        this.attachOverlay();\n    }\n\n    closePanel(): void {\n        if (!this.overlayAttached) { return; }\n\n        if (this.panelOpen) {\n            this.autocomplete.closed.emit();\n        }\n\n        this.autocomplete.isOpen = this.overlayAttached = false;\n\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n            this.overlayRef.detach();\n            this.closingActionsSubscription.unsubscribe();\n        }\n\n        // Note that in some cases this can end up being called after the component is destroyed.\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\n        if (!this.componentDestroyed) {\n            // We need to trigger change detection manually, because\n            // `fromEvent` doesn't seem to do it at the proper time.\n            // This ensures that the label is reset when the\n            // user clicks outside.\n            this.changeDetectorRef.detectChanges();\n        }\n    }\n\n    /**\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n     * within the viewport.\n     */\n    updatePosition(): void {\n        if (this.overlayAttached) {\n            this.overlayRef!.updatePosition();\n        }\n    }\n\n    /**\n     * A stream of actions that should close the autocomplete panel, including\n     * when an option is selected, on blur, and when TAB is pressed.\n     */\n    get panelClosingActions(): Observable<McOptionSelectionChange | null> {\n        return merge(\n            this.optionSelections,\n            this.autocomplete.keyManager.tabOut.pipe(filter(() => this.overlayAttached)),\n            this.closeKeyEventStream,\n            this.getOutsideClickStream(),\n            this.overlayRef ?\n                this.overlayRef.detachments().pipe(filter(() => this.overlayAttached)) :\n                observableOf()\n        ).pipe(\n            // Normalize the output so we return a consistent type.\n            map((event) => event instanceof McOptionSelectionChange ? event : null)\n        );\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    writeValue(value: any): void {\n        Promise.resolve(null).then(() => this.setTriggerValue(value));\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnChange(fn: (value: any) => {}): void {\n        this.onChange = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    registerOnTouched(fn: () => {}) {\n        this.onTouched = fn;\n    }\n\n    // Implemented as part of ControlValueAccessor.\n    setDisabledState(isDisabled: boolean) {\n        this.elementRef.nativeElement.disabled = isDisabled;\n    }\n\n    handleKeydown(event: KeyboardEvent): void {\n        // tslint:disable-next-line deprecation\n        const keyCode = event.keyCode;\n\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\n        // the input value to the one that it had on focus, however it won't dispatch any events\n        // which means that the model value will be out of sync with the view.\n        if (keyCode === ESCAPE) {\n            event.preventDefault();\n        }\n\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\n            this.activeOption.selectViaInteraction();\n            this.resetActiveItem();\n            event.preventDefault();\n        } else if (this.autocomplete) {\n            const prevActiveItem = this.autocomplete.keyManager.activeItem;\n\n            if (this.panelOpen || keyCode === TAB) {\n                this.autocomplete.onKeydown(event);\n            } else if (keyCode === DOWN_ARROW && this.canOpen()) {\n                this.openPanel();\n            }\n\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n            if (isArrowKey || this.autocomplete.keyManager.activeItem !== prevActiveItem) {\n                this.scrollToOption();\n            }\n        }\n    }\n\n    handleInput(event: KeyboardEvent): void {\n        const target = event.target as HTMLInputElement;\n        let value: number | string | null = target.value;\n\n        // Based on `NumberValueAccessor` from forms.\n        if (target.type === 'number') {\n            value = value === '' ? null : parseFloat(value);\n        }\n\n        // If the input has a placeholder, IE will fire the `input` event on page load,\n        // focus and blur, in addition to when the user actually changed the value. To\n        // filter out all of the extra events, we save the value on focus and between\n        // `input` events, and we check whether it changed.\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\n        if (this.previousValue !== value) {\n            this.previousValue = value;\n            this.onChange(value);\n\n            if (this.canOpen() && this.document.activeElement === event.target) {\n                this.openPanel();\n            }\n        }\n    }\n\n    handleFocus(): void {\n        if (!this.canOpenOnNextFocus) {\n            this.canOpenOnNextFocus = true;\n        } else if (this.canOpen()) {\n            this.previousValue = this.elementRef.nativeElement.value;\n            this.attachOverlay();\n        }\n    }\n\n    handleClick($event: MouseEvent) {\n        if (this.canOpen() && this.document.activeElement === $event.target) {\n            this.openPanel();\n        }\n    }\n\n    /** Stream of clicks outside of the autocomplete panel. */\n    private getOutsideClickStream(): Observable<any> {\n        return merge(\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'click') as Observable<MouseEvent>,\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            fromEvent(this.document, 'touchend') as Observable<TouchEvent>\n        )\n            .pipe(filter((event) => {\n                const clickTarget = event.target as HTMLElement;\n                const formField = this.formField ?\n                    this.formField._elementRef.nativeElement : null;\n\n                return this.overlayAttached &&\n                    clickTarget !== this.elementRef.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!!this.overlayRef && !this.overlayRef.overlayElement.contains(clickTarget));\n            }));\n    }\n\n    /**\n     * Event handler for when the window is blurred. Needs to be an\n     * arrow function in order to preserve the context.\n     */\n    private windowBlurHandler = () => {\n        // If the user blurred the window while the autocomplete is focused, it means that it'll be\n        // refocused when they come back. In this case we want to skip the first focus event, if the\n        // pane was closed, in order to avoid reopening it unintentionally.\n        this.canOpenOnNextFocus = this.document.activeElement !== this.elementRef.nativeElement || this.panelOpen;\n    }\n\n    /**\n     * Given that we are not actually focusing active options, we must manually adjust scroll\n     * to reveal options below the fold. First, we find the offset of the option from the top\n     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n     * the panel height + the option height, so the active option will be just visible at the\n     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n     * will become the offset. If that offset is visible within the panel already, the scrollTop is\n     * not adjusted.\n     */\n    private scrollToOption(): void {\n        const index = this.autocomplete.keyManager.activeItemIndex || 0;\n        const labelCount = countGroupLabelsBeforeOption(index,\n            this.autocomplete.options, this.autocomplete.optionGroups);\n\n        const newScrollPosition = getOptionScrollPosition(\n            index + labelCount,\n            AUTOCOMPLETE_OPTION_HEIGHT,\n            this.autocomplete.getScrollTop(),\n            AUTOCOMPLETE_PANEL_HEIGHT\n        );\n\n        this.autocomplete.setScrollTop(newScrollPosition);\n    }\n\n    /**\n     * This method listens to a stream of panel closing actions and resets the\n     * stream every time the option list changes.\n     */\n    private subscribeToClosingActions(): Subscription {\n        const firstStable = this.zone.onStable.asObservable()\n            .pipe(take(1));\n        const optionChanges = this.autocomplete.options.changes\n            .pipe(\n                tap(() => this.positionStrategy.reapplyLastPosition()),\n                // Defer emitting to the stream until the next tick, because changing\n                // bindings in here will cause \"changed after checked\" errors.\n                delay(0)\n            );\n\n        // When the zone is stable initially, and when the option list changes...\n        return merge(firstStable, optionChanges)\n            .pipe(\n                // create a new stream of panelClosingActions, replacing any previous streams\n                // that were created, and flatten it so our stream only emits closing events...\n                switchMap(() => {\n                    const wasOpen = this.panelOpen;\n                    this.resetActiveItem();\n                    this.autocomplete.setVisibility();\n\n                    if (this.panelOpen) {\n                        this.overlayRef!.updatePosition();\n\n                        // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                        // event, because we may not have emitted it when the panel was attached. This\n                        // can happen if the users opens the panel and there are no options, but the\n                        // options come in slightly later or as a result of the value changing.\n                        if (wasOpen !== this.panelOpen) {\n                            this.autocomplete.opened.emit();\n                        }\n                    }\n\n                    return this.panelClosingActions;\n                }),\n                // when the first closing event occurs...\n                take(1)\n            )\n            // set the value, close the panel, and complete.\n            .subscribe((event) => this.setValueAndClose(event));\n    }\n\n    /** Destroys the autocomplete suggestion panel. */\n    private destroyPanel(): void {\n        if (this.overlayRef) {\n            this.closePanel();\n            this.overlayRef.dispose();\n            this.overlayRef = null;\n        }\n    }\n\n    private setTriggerValue(value: any): void {\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n            this.autocomplete.displayWith(value) :\n            value;\n\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\n        const inputValue = toDisplay != null ? toDisplay : '';\n\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\n        // through change detection.\n        if (this.formField) {\n            this.formField.control.value = inputValue;\n        } else {\n            this.elementRef.nativeElement.value = inputValue;\n        }\n\n        this.previousValue = inputValue;\n    }\n\n    /** This method closes the panel, and if a value is specified, also sets the associated\n     * control to that value. It will also mark the control as dirty if this interaction\n     * stemmed from the user.\n     */\n    private setValueAndClose(event: McOptionSelectionChange | null): void {\n        if (event && event.source) {\n            this.clearPreviousSelectedOption(event.source);\n            this.setTriggerValue(event.source.value);\n            this.onChange(event.source.value);\n            this.elementRef.nativeElement.focus();\n\n            this.autocomplete.emitSelectEvent(event.source);\n        }\n\n        this.closePanel();\n    }\n\n    /** Clear any previous selected option and emit a selection change event for this option */\n    private clearPreviousSelectedOption(skip: McOption) {\n        this.autocomplete.options.forEach((option) => {\n            if (option !== skip && option.selected) {\n                option.deselect();\n            }\n        });\n    }\n\n    private attachOverlay(): void {\n        if (!this.autocomplete) {\n            throw getMcAutocompleteMissingPanelError();\n        }\n\n        let overlayRef = this.overlayRef;\n\n        if (!overlayRef) {\n            this.portal = new TemplatePortal(this.autocomplete.template, this.viewContainerRef);\n            overlayRef = this.overlay.create(this.getOverlayConfig());\n            this.overlayRef = overlayRef;\n\n            // Use the `keydownEvents` in order to take advantage of\n            // the overlay event targeting provided by the CDK overlay.\n            overlayRef.keydownEvents().subscribe((event) => {\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                // tslint:disable-next-line deprecation\n                if (event.keyCode === ESCAPE || (event.keyCode === UP_ARROW && event.altKey)) {\n                    this.resetActiveItem();\n                    this.closeKeyEventStream.next();\n                }\n            });\n\n            if (this.viewportRuler) {\n                this.viewportSubscription = this.viewportRuler.change().subscribe(() => {\n                    if (this.panelOpen && overlayRef) {\n                        overlayRef.updateSize({ width: this.getPanelWidth() });\n                    }\n                });\n            }\n        } else {\n            const position = overlayRef.getConfig().positionStrategy as FlexibleConnectedPositionStrategy;\n\n            // Update the trigger, panel width and direction, in case anything has changed.\n            position.setOrigin(this.getConnectedElement());\n            overlayRef.updateSize({ width: this.getPanelWidth() });\n        }\n\n        if (overlayRef && !overlayRef.hasAttached()) {\n            overlayRef.attach(this.portal);\n            this.closingActionsSubscription = this.subscribeToClosingActions();\n        }\n\n        const wasOpen = this.panelOpen;\n\n        this.autocomplete.setVisibility();\n        this.autocomplete.isOpen = this.overlayAttached = true;\n\n        // We need to do an extra `panelOpen` check in here, because the\n        // autocomplete won't be shown if there are no options.\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\n            this.autocomplete.opened.emit();\n        }\n    }\n\n    private getOverlayConfig(): OverlayConfig {\n        return new OverlayConfig({\n            positionStrategy: this.getOverlayPosition(),\n            scrollStrategy: this.scrollStrategy(),\n            width: this.getPanelWidth(),\n            direction: this.dir\n        });\n    }\n\n    private getOverlayPosition(): PositionStrategy {\n        this.positionStrategy = this.overlay.position()\n            .flexibleConnectedTo(this.getConnectedElement())\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withPositions([\n                {\n                    originX: 'start',\n                    originY: 'bottom',\n                    overlayX: 'start',\n                    overlayY: 'top'\n                },\n                {\n                    originX: 'start',\n                    originY: 'top',\n                    overlayX: 'start',\n                    overlayY: 'bottom',\n\n                    // The overlay edge connected to the trigger should have squared corners, while\n                    // the opposite end has rounded corners. We apply a CSS class to swap the\n                    // border-radius based on the overlay position.\n                    panelClass: 'mc-autocomplete-panel-above'\n                }\n            ] as ConnectedPosition[]);\n\n        return this.positionStrategy;\n    }\n\n    private getConnectedElement(): ElementRef {\n        if (this.connectedTo) {\n            return this.connectedTo.elementRef;\n        }\n\n        return this.formField ? this.formField.getConnectedOverlayOrigin() : this.elementRef;\n    }\n\n    private getPanelWidth(): number | string {\n        return this.autocomplete.panelWidth || this.getHostWidth() - AUTOCOMPLETE_BORDER_WIDTH;\n    }\n\n    private getHostWidth(): number {\n        return this.getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n\n    /**\n     * Resets the active item to -1 so arrow events will activate the\n     * correct options, or to 0 if the consumer opted into it.\n     */\n    private resetActiveItem(): void {\n        this.autocomplete.keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n    }\n\n    private canOpen(): boolean {\n        const element = this.elementRef.nativeElement;\n\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n    }\n}\n","import { OverlayModule } from '@angular/cdk/overlay';\nimport { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { McOptionModule, McCommonModule } from '@ptsecurity/mosaic/core';\n\nimport { McAutocompleteOrigin } from './autocomplete-origin.directive';\nimport {\n    McAutocompleteTrigger,\n    MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER\n} from './autocomplete-trigger.directive';\nimport { McAutocomplete } from './autocomplete.component';\n\n\n@NgModule({\n    imports: [McOptionModule, OverlayModule, McCommonModule, CommonModule],\n    exports: [\n        McAutocomplete,\n        McOptionModule,\n        McAutocompleteTrigger,\n        McAutocompleteOrigin,\n        McCommonModule\n    ],\n    declarations: [McAutocomplete, McAutocompleteTrigger, McAutocompleteOrigin],\n    providers: [MC_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]\n})\nexport class McAutocompleteModule {}\n"]}
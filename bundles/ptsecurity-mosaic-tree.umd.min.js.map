{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","../../../packages/mosaic/tree/node.directive.ts","../../../packages/mosaic/tree/padding.directive.ts","../../../packages/mosaic/tree/toggle.ts","../../../packages/mosaic/tree/tree-option.component.ts","../../../packages/mosaic/tree/tree-selection.component.ts","../../../packages/mosaic/tree/tree.module.ts","../../../packages/mosaic/tree/data-source/flat-data-source.ts","../../../packages/mosaic/tree/data-source/nested-data-source.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__read","o","n","m","Symbol","iterator","r","e","i","ar","next","done","push","value","error","__spread","arguments","length","concat","McTreeNodeDef","_super","CdkTreeNodeDef","Directive","args","selector","inputs","providers","provide","useExisting","Input","McTreeNodePadding","_this","apply","baseLeftPadding","iconWidth","defineProperty","_level","setLevelInput","_indent","indent","setIndentInput","withIcon","paddingIndent","nodeLevel","treeNode","data","tree","treeControl","getLevel","level","leftPadding","ngOnInit","isExpandable","setPadding","CdkTreeNodePadding","McTreeNodeToggleComponent","disabled","_recursive","filterValue","pipe","map","subscribe","state","isExpanded","node","toggle","event","recursive","toggleDescendants","stopPropagation","Component","template","host","class","[class.mc-opened]","[attr.disabled]","(click)","encapsulation","ViewEncapsulation","None","CdkTree","CdkTreeNode","McTreeNodeToggleDirective","MC_TREE_OPTION_PARENT_COMPONENT","InjectionToken","source","isUserInput","uniqueIdCounter","McTreeOption","elementRef","changeDetectorRef","ngZone","onFocus","Subject","onBlur","_disabled","onSelectionChange","EventEmitter","_selected","_id","hasFocus","_value","newValue","coerceBooleanProperty","undefined","_showCheckbox","showCheckbox","isSelected","setSelected","multiple","getHostElement","textContent","trim","ngAfterContentInit","getValue","selected","selectionModel","select","deselect","markForCheck","focus","focusOrigin","nativeElement","option","Promise","resolve","then","blur","onStable","asObservable","take","run","getHeight","clientRects","getClientRects","height","emitSelectionChangeEvent","selectViaInteraction","$event","shiftKey","hasModifierKey","ctrlKey","setSelectedOptionsByClick","emit","McTreeOptionChange","exportAs","[attr.id]","[attr.tabindex]","[class.mc-selected]","[class.mc-focused]","(focus)","(blur)","changeDetection","ChangeDetectionStrategy","OnPush","ElementRef","ChangeDetectorRef","NgZone","Inject","Output","MC_SELECTION_TREE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","McTreeSelection","multi","differs","renderedOptions","QueryList","resetFocusedItemOnBlur","navigationChange","selectionChange","multipleMode","userTabIndex","sortedNodes","_autoSelect","_noUnselectLast","_tabIndex","destroy","onChange","onTouched","updateRenderedOptions","orderedOptions","forEach","found","unorderedOptions","find","reset","notifyOnChanges","MultipleMode","CHECKBOX","KEYBOARD","autoSelect","noUnselectLast","SelectionModel","merge","rawValue","markOptionsForCheck","changes","keyManager","FocusKeyManager","withVerticalOrientation","withHorizontalOrientation","change","takeUntil","activeItem","emitNavigationEvent","updateOptionsFocus","tabOut","allowFocusEscape","changed","getSelectedValues","options","resetOptions","updateTabIndex","selectedValue","ngOnDestroy","complete","isFocusReceivedFromNestedOption","setFirstItemActive","hasFocusedOption","setActiveItem","onKeyDown","setFocusOrigin","keyCode","DOWN_ARROW","setNextItemActive","UP_ARROW","setPreviousItemActive","LEFT_ARROW","collapse","preventDefault","RIGHT_ARROW","expand","SPACE","ENTER","toggleFocusedOption","HOME","END","setLastItemActive","PAGE_UP","setPreviousPageItemActive","PAGE_DOWN","setNextPageItemActive","setSelectedOptionsByKey","updateScrollSize","first","withScrollSize","Math","floor","setSelectedOptions","canDeselectLast","clear","emitChangeEvent","selectedOptionState","fromIndex","previousActiveItemIndex","toIndex","activeItemIndex","_a","toArray","slice","filter","item","renderedOption","setFocusedOption","focusedOption","renderNodeChanges","dataDiffer","viewContainer","parentData","nodeOutlet","getSortedNodes","detectChanges","getItemHeight","McTreeNavigationChange","writeValue","isArray","getMcSelectNonArrayValueError","setOptionsFromValues","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","values","valuesToSelect","reduce","result","hasValue","array","viewRef","get","context","$implicit","setTimeout","dropSubscriptions","listenToOptionsFocus","optionFocusSubscription","unsubscribe","optionBlurSubscription","optionFocusChanges","index","indexOf","isValidIndex","updateActiveItem","optionBlurChanges","some","relatedTarget","classList","contains","(keydown)","(window:resize)","IterableDiffers","decorators","type","Attribute","ViewChild","CdkTreeNodeOutlet","static","ContentChildren","MC_TREE_DIRECTIVES","NgModule","imports","CommonModule","CdkTreeModule","McPseudoCheckboxModule","exports","declarations","McTreeFlattener","transformFunction","getChildren","flattenNode","resultNodes","parent","flatNode","childrenNodes","flattenChildren","children","child","flattenNodes","structuredData","expandFlattenedNodes","nodes","results","currentExpand","McTreeDataSourceChangeTypes","McTreeFlatDataSource","treeFlattener","initialData","flattenedData","BehaviorSubject","expandedData","filteredData","_data","dataNodes","connect","collectionViewer","viewChange","expansionModel","changeObj","filterHandler","expansionHandler","filterModel","expandedNodes","disconnect","DataSource","McTreeNestedDataSource"],"mappings":";;;;;;;;;;;;;;oFAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOC,OAAOK,UAAUC,eAAeC,KAAKR,EAAGK,KAAIN,EAAEM,GAAKL,EAAEK,MAC3EN,EAAGC,aAGZS,EAAUV,EAAGC,GAEzB,SAASU,IAAOC,KAAKC,YAAcb,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEO,UAAkB,OAANN,EAAaC,OAAOY,OAAOb,IAAMU,EAAGJ,UAAYN,EAAEM,UAAW,IAAII,GA+EtDT,OAAOY,gBAwBpBC,EAAOC,EAAGC,GACtB,IAAIC,EAAsB,mBAAXC,QAAyBH,EAAEG,OAAOC,UACjD,IAAKF,EAAG,OAAOF,EACf,IAAmBK,EAAYC,EAA3BC,EAAIL,EAAET,KAAKO,GAAOQ,EAAK,GAC3B,IACI,WAAc,IAANP,GAAgBA,KAAM,MAAQI,EAAIE,EAAEE,QAAQC,MAAMF,EAAGG,KAAKN,EAAEO,OAExE,MAAOC,GAASP,EAAI,CAAEO,MAAOA,WAEzB,IACQR,IAAMA,EAAEK,OAASR,EAAIK,EAAU,SAAIL,EAAET,KAAKc,WAExC,GAAID,EAAG,MAAMA,EAAEO,OAE7B,OAAOL,WAGKM,IACZ,IAAK,IAAIN,EAAK,GAAID,EAAI,EAAGA,EAAIQ,UAAUC,OAAQT,IAC3CC,EAAKA,EAAGS,OAAOlB,EAAOgB,UAAUR,KACpC,OAAOC,EA8CctB,OAAOY,yBC1LhC,SAAAoB,0DAAsCxB,EAAAwB,EAAAC,MAAAC,EAAAA,oCALrCC,EAAAA,UAASC,KAAA,CAAC,CACPC,SAAU,kBACVC,OAAQ,CAAC,2BACTC,UAAW,CAAC,CAAEC,QAASN,EAAAA,eAAgBO,YAAaT,sCAGnDU,EAAAA,MAAKN,KAAA,CAAC,mCCNX,SAAAO,IAAA,IAAAC,EAAAX,EAAAY,MAAAnC,KAAAkB,EAAAC,aAAAnB,YAcIkC,EAAAE,gBAA0B,GAG1BF,EAAAG,UAAoB,YAbkBvC,EAAAmC,EAAAV,GAEtCjC,OAAAgD,eACIL,EAAAtC,UAAA,QAAK,KADT,WACsB,OAAOK,KAAKuC,YAClC,SAAUvB,GAAiBhB,KAAKwC,cAAcxB,oCAE9C1B,OAAAgD,eACIL,EAAAtC,UAAA,SAAM,KADV,WACgC,OAAOK,KAAKyC,aAC5C,SAAWC,GAA2B1C,KAAK2C,eAAeD,oCAO1DpD,OAAAgD,eAAIL,EAAAtC,UAAA,cAAW,KAAf,WACI,OAAQK,KAAK4C,SAAW,EAAI5C,KAAKqC,WAAarC,KAAKoC,iDAGvDH,EAAAtC,UAAAkD,cAAA,eACUC,EAAa9C,KAAK+C,SAASC,MAAQhD,KAAKiD,KAAKC,YAAYC,SACzDnD,KAAKiD,KAAKC,YAAYC,SAASnD,KAAK+C,SAASC,MAC7C,EAEAI,EAAQpD,KAAKoD,OAASN,EAE5B,OAAOM,EAAQ,EAAQA,EAAQpD,KAAKyC,QAAWzC,KAAKqD,YAAW,KAAUrD,KAAKqD,YAAW,MAG7FpB,EAAAtC,UAAA2D,SAAA,WACItD,KAAK4C,SAAW5C,KAAKiD,KAAKC,YAAYK,aAAavD,KAAK+C,SAASC,MAEjEhD,KAAKwD,iBAhC6BC,EAAAA,wCAJzChC,EAAAA,UAASC,KAAA,CAAC,CACPC,SAAU,sBACVE,UAAW,CAAC,CAAEC,QAAS2B,EAAAA,mBAAoB1B,YAAaE,uCAIvDD,EAAAA,MAAKN,KAAA,CAAC,qCAINM,EAAAA,MAAKN,KAAA,CAAC,+CCwBP,SAAAgC,EAAoBT,EAA0BF,GAA9C,IAAAb,EAAAlC,KAAoBA,KAAAiD,KAAAA,EAA0BjD,KAAA+C,SAAAA,EAnB9C/C,KAAA2D,UAAoB,EAaZ3D,KAAA4D,YAAa,EAOjB5D,KAAKiD,KAAKC,YAAYW,YACjBC,KAAKC,EAAAA,KAAG,SAAE/C,GAAU,OAAAA,EAAMI,OAAS,MACnC4C,WAAS,SAAEC,GAAmB,OAAA/B,EAAKyB,SAAWM,YAlBvD3E,OAAAgD,eACIoB,EAAA/D,UAAA,YAAS,KADb,WAEI,OAAOK,KAAK4D,gBAGhB,SAAc5C,GACVhB,KAAK4D,WAAa5C,mCAKtB1B,OAAAgD,eAAIoB,EAAA/D,UAAA,YAAS,KAAb,WACI,OAAOK,KAAK2D,UAAY3D,KAAKiD,KAAKC,YAAYgB,WAAWlE,KAAKmE,uCASlET,EAAA/D,UAAAyE,OAAA,SAAOC,GACHrE,KAAKsE,UACCtE,KAAKiD,KAAKC,YAAYqB,kBAAkBvE,KAAK+C,SAASC,MACtDhD,KAAKiD,KAAKC,YAAYkB,OAAOpE,KAAK+C,SAASC,MAEjDqB,EAAMG,4CA5CbC,EAAAA,UAAS/C,KAAA,CAAC,CACPC,SAAU,sBACV+C,SAAU,gEAGVC,KAAM,CACFC,MAAO,sBACPC,oBAAqB,YACrBC,kBAAmB,mBACnBC,UAAW,kBAEfC,cAAeC,EAAAA,kBAAkBC,kDAf5BC,EAAAA,eAASC,EAAAA,6CAoBbpD,EAAAA,yBAEAA,EAAAA,MAAKN,KAAA,CAAC,kDAmDP,SAAA2D,EAAoBpC,EAA0BF,GAA9C,IAAAb,EAAAlC,KAAoBA,KAAAiD,KAAAA,EAA0BjD,KAAA+C,SAAAA,EAb9C/C,KAAA2D,UAAoB,EAWZ3D,KAAA4D,YAAa,EAIjB5D,KAAKiD,KAAKC,YAAYW,YACjBC,KAAKC,EAAAA,KAAG,SAAE/C,GAAU,OAAAA,EAAMI,OAAS,MACnC4C,WAAS,SAAEC,GAAmB,OAAA/B,EAAKyB,SAAWM,YAfvD3E,OAAAgD,eACI+C,EAAA1F,UAAA,YAAS,KADb,WAEI,OAAOK,KAAK4D,gBAGhB,SAAc5C,GACVhB,KAAK4D,WAAa5C,mCAYtBqE,EAAA1F,UAAAyE,OAAA,SAAOC,GACHrE,KAAKsE,UACCtE,KAAKiD,KAAKC,YAAYqB,kBAAkBvE,KAAK+C,SAASC,MACtDhD,KAAKiD,KAAKC,YAAYkB,OAAOpE,KAAK+C,SAASC,MAEjDqB,EAAMG,4CAjCb/C,EAAAA,UAASC,KAAA,CAAC,CACPC,SAAU,qBACVgD,KAAM,CACFG,kBAAmB,mBACnBC,UAAW,+DAxDVI,EAAAA,eAASC,EAAAA,kDA8DbpD,EAAAA,MAAKN,KAAA,CAAC,qCChCE4D,EAAkC,IAAIC,EAAAA,eAAoB,qCAGnE,SAAmBC,EAA6BC,QAAA,IAAAA,IAAAA,GAAA,GAA7BzF,KAAAwF,OAAAA,EAA6BxF,KAAAyF,YAAAA,OAGhDC,EAA0B,gBAmG1B,SAAAC,EACIC,EACQC,EACAC,EACwC7C,GAJpD,IAAAf,EAMIX,EAAA1B,KAAAG,KAAM4F,EAAY3C,IAAKjD,YAJfkC,EAAA2D,kBAAAA,EACA3D,EAAA4D,OAAAA,EACwC5D,EAAAe,KAAAA,EA7E3Cf,EAAA6D,QAAU,IAAIC,EAAAA,QAEd9D,EAAA+D,OAAS,IAAID,EAAAA,QAyBd9D,EAAAgE,WAAqB,EAaVhE,EAAAiE,kBAAoB,IAAIC,EAAAA,aAcnClE,EAAAmE,WAAqB,EAMrBnE,EAAAoE,IAAM,kBAAkBZ,IAWhCxD,EAAAqE,UAAoB,WAxEUzG,EAAA6F,EAAApE,GAK9BjC,OAAAgD,eAAIqD,EAAAhG,UAAA,QAAK,KAAT,WACI,OAAOK,KAAKwG,YAGhB,SAAUxF,GACNhB,KAAKwG,OAASxF,mCAKlB1B,OAAAgD,eACIqD,EAAAhG,UAAA,WAAQ,KADZ,WAEI,OAAOK,KAAKkG,WAAclG,KAAKiD,MAAQjD,KAAKiD,KAAKU,cAGrD,SAAa3C,OACHyF,EAAWC,EAAAA,sBAAsB1F,GAEnCyF,IAAazG,KAAKkG,YAClBlG,KAAKkG,UAAYO,oCAMzBnH,OAAAgD,eACIqD,EAAAhG,UAAA,eAAY,KADhB,WAEI,YAA8BgH,IAAvB3G,KAAK4G,cAA8B5G,KAAK4G,cAAgB5G,KAAKiD,KAAK4D,kBAG7E,SAAiB7F,GACbhB,KAAK4G,cAAgBF,EAAAA,sBAAsB1F,oCAO/C1B,OAAAgD,eAAIqD,EAAAhG,UAAA,WAAQ,KAAZ,WACI,OAAOK,KAAKqG,eAGhB,SAAarF,OACH8F,EAAaJ,EAAAA,sBAAsB1F,GAErC8F,IAAe9G,KAAKqG,WACpBrG,KAAK+G,YAAYD,oCAMzBxH,OAAAgD,eAAIqD,EAAAhG,UAAA,KAAE,KAAN,WACI,OAAOK,KAAKsG,qCAKhBhH,OAAAgD,eAAIqD,EAAAhG,UAAA,WAAQ,KAAZ,WACI,OAAOK,KAAKiD,KAAK+D,0CAGrB1H,OAAAgD,eAAIqD,EAAAhG,UAAA,YAAS,KAAb,WAEI,OAAQK,KAAKiH,iBAAiBC,aAAe,IAAIC,wCAcrDxB,EAAAhG,UAAAyH,mBAAA,WACIpH,KAAKgB,MAAQhB,KAAKiD,KAAKC,YAAYmE,SAASrH,KAAKgD,OAGrD2C,EAAAhG,UAAAyE,OAAA,WACIpE,KAAKsH,UAAYtH,KAAKsH,UAG1B3B,EAAAhG,UAAAoH,YAAA,SAAYO,GACJtH,KAAKqG,YAAciB,GAAatH,KAAKiD,KAAKsE,iBAE9CvH,KAAKqG,UAAYiB,EAEbA,EACAtH,KAAKiD,KAAKsE,eAAeC,OAAOxH,KAAKgD,MAErChD,KAAKiD,KAAKsE,eAAeE,SAASzH,KAAKgD,MAG3ChD,KAAK6F,kBAAkB6B,iBAG3B/B,EAAAhG,UAAAgI,MAAA,SAAMC,GAAN,IAAA1F,EAAAlC,KACwB,YAAhB4H,IAEA5H,KAAK2D,UAAY3D,KAAKuG,WAE1BvG,KAAK4F,WAAWiC,cAAcF,QAE9B3H,KAAK+F,QAAQlF,KAAK,CAAEiH,OAAQ9H,OAE5B+H,QAAQC,UAAUC,MAAI,WAClB/F,EAAKqE,UAAW,EAEhBrE,EAAK2D,kBAAkB6B,qBAI/B/B,EAAAhG,UAAAuI,KAAA,WAAA,IAAAhG,EAAAlC,KAKIA,KAAK8F,OAAOqC,SACPC,eACAtE,KAAKuE,EAAAA,KAAK,IACVrE,WAAS,WACN9B,EAAK4D,OAAOwC,KAAG,WACXpG,EAAKqE,UAAW,EAEhBrE,EAAK+D,OAAOpF,KAAK,CAAEiH,OAAQ5F,WAK3CyD,EAAAhG,UAAA4I,UAAA,eACUC,EAAcxI,KAAK4F,WAAWiC,cAAcY,iBAElD,OAAID,EAAYpH,OACLoH,EAAY,GAAGE,OAGnB,GAGX/C,EAAAhG,UAAA6H,OAAA,WACSxH,KAAKqG,YACNrG,KAAKqG,WAAY,EAEjBrG,KAAK6F,kBAAkB6B,eACvB1H,KAAK2I,6BAIbhD,EAAAhG,UAAA8H,SAAA,WACQzH,KAAKqG,YACLrG,KAAKqG,WAAY,EAEjBrG,KAAK6F,kBAAkB6B,iBAI/B/B,EAAAhG,UAAAiJ,qBAAA,SAAqBC,GACjB,IAAK7I,KAAK2D,SAAU,CAChB3D,KAAK6F,kBAAkB6B,eACvB1H,KAAK2I,0BAAyB,OAExBG,IAAWD,GAASE,EAAAA,eAAeF,EAAQ,YAC3CG,IAAUH,GAASE,EAAAA,eAAeF,EAAQ,WAEhD7I,KAAKiD,KAAKgG,0BAA0BjJ,KAAM8I,EAAUE,KAI5DrD,EAAAhG,UAAAgJ,yBAAA,SAAyBlD,QAAA,IAAAA,IAAAA,GAAA,GACrBzF,KAAKmG,kBAAkB+C,KAAK,IAAIC,EAAmBnJ,KAAMyF,KAG7DE,EAAAhG,UAAAsH,eAAA,WACI,OAAOjH,KAAK4F,WAAWiC,eAG3BlC,EAAAhG,UAAA+H,aAAA,WACI1H,KAAK6F,kBAAkB6B,mBA1LGtC,EAAAA,iCAvBjCX,EAAAA,UAAS/C,KAAA,CAAC,CACPC,SAAU,iBACVyH,SAAU,eACV1E,SAAA,4XACAC,KAAM,CACF0E,YAAa,KACbC,kBAAmB,KAEnBxE,kBAAmB,mBAEnBF,MAAO,iBACP2E,sBAAuB,WACvBC,qBAAsB,WAEtBC,UAAW,UACXC,SAAU,SAEV3E,UAAW,gCAEf4E,gBAAiBC,EAAAA,wBAAwBC,OACzC7E,cAAeC,EAAAA,kBAAkBC,KACjCrD,UAAW,CAAC,CAAEC,QAASsD,EAAAA,YAAarD,YAAa4D,iDApDjDmE,EAAAA,kBALAC,EAAAA,yBAWAC,EAAAA,uCA8HKC,EAAAA,OAAMvI,KAAA,CAAC4D,0CA/DXtD,EAAAA,4BAeAA,EAAAA,iCAWAkI,EAAAA,cCtDQC,EAAwC,CACjDrI,QAASsI,EAAAA,kBACTrI,YAAasI,EAAAA,YAAU,WAAO,OAAAC,KAC9BC,OAAO,KAIP,SAAmB/E,EAAqCsC,GAArC9H,KAAAwF,OAAAA,EAAqCxF,KAAA8H,OAAAA,SAIxD,SAAmBtC,EAAqCsC,GAArC9H,KAAAwF,OAAAA,EAAqCxF,KAAA8H,OAAAA,qBAuIxD,SAAAwC,EACY1E,EACR4E,EACA3E,EACuBmB,GAJ3B,IAAA9E,EAMIX,EAAA1B,KAAAG,KAAMwK,EAAS3E,IAAkB7F,YALzBkC,EAAA0D,WAAAA,EA9FZ1D,EAAAuI,gBAAkB,IAAIC,EAAAA,UAMtBxI,EAAAyI,wBAAkC,EAIfzI,EAAA0I,iBAAmB,IAAIxE,EAAAA,aAEvBlE,EAAA2I,gBAAkB,IAAIzE,EAAAA,aAEzClE,EAAA4I,aAAoC,KAEpC5I,EAAA6I,aAA8B,KAEtB7I,EAAA8I,YAAmB,GAWnB9I,EAAA+I,aAAuB,EAuBvB/I,EAAAgJ,iBAA2B,EAiB3BhJ,EAAAgE,WAAqB,EAYrBhE,EAAAiJ,UAAY,EAMHjJ,EAAAkJ,QAAU,IAAIpF,EAAAA,QAsS/B9D,EAAAmJ,SAAQ,aAORnJ,EAAAoJ,UAAS,aAgCDpJ,EAAAqJ,sBAAqB,eACnBC,EAAsB,GAE5BtJ,EAAK8I,YAAYS,SAAO,SAAEtH,OAChBuH,EAAQxJ,EAAKyJ,iBAAiBC,MAAI,SAAE9D,GAAW,OAAAA,EAAO9G,QAAUkB,EAAKgB,YAAYmE,SAASlD,MAE5FuH,GACAF,EAAezK,KAAK2K,MAI5BxJ,EAAKuI,gBAAgBoB,MAAML,GAC3BtJ,EAAKuI,gBAAgBqB,mBA3UjB9E,IAAa+E,EAAAA,aAAaC,UAAYhF,IAAa+E,EAAAA,aAAaE,SAChE/J,EAAK4I,aAAe9D,EACA,OAAbA,IACP9E,EAAK4I,aAAeiB,EAAAA,aAAaC,UAGjC9J,EAAK4I,eAAiBiB,EAAAA,aAAaC,WACnC9J,EAAKgK,YAAa,EAClBhK,EAAKiK,gBAAiB,GAG1BjK,EAAKqF,eAAiB,IAAI6E,EAAAA,eAAqClK,EAAK8E,mBAvHflH,EAAAwK,EAAA/I,GA2BzDjC,OAAAgD,eACIgI,EAAA3K,UAAA,aAAU,KADd,WAEI,OAAOK,KAAKiL,iBAGhB,SAAejK,GACXhB,KAAKiL,YAAcvE,EAAAA,sBAAsB1F,oCAK7C1B,OAAAgD,eAAIgI,EAAA3K,UAAA,qBAAkB,KAAtB,WACI,OAAO0M,EAAAA,MAAKlK,WAAA,EAAAjB,EAAIlB,KAAKyK,gBAAgB1G,KAAG,SAAE+D,GAAW,OAAAA,EAAO/B,8CAGhEzG,OAAAgD,eAAIgI,EAAA3K,UAAA,oBAAiB,KAArB,WACI,OAAO0M,EAAAA,MAAKlK,WAAA,EAAAjB,EAAIlB,KAAKyK,gBAAgB1G,KAAG,SAAE+D,GAAW,OAAAA,EAAO7B,6CAGhE3G,OAAAgD,eAAIgI,EAAA3K,UAAA,WAAQ,KAAZ,WACI,QAASK,KAAK8K,8CAGlBxL,OAAAgD,eACIgI,EAAA3K,UAAA,iBAAc,KADlB,WAEI,OAAOK,KAAKkL,qBAGhB,SAAmBlK,GACfhB,KAAKkL,gBAAkBxE,EAAAA,sBAAsB1F,oCAKjD1B,OAAAgD,eACIgI,EAAA3K,UAAA,WAAQ,KADZ,WAEI,OAAOK,KAAKkG,eAGhB,SAAaoG,OACHtL,EAAQ0F,EAAAA,sBAAsB4F,GAEhCtM,KAAKkG,YAAclF,IACnBhB,KAAKkG,UAAYlF,EAEjBhB,KAAKuM,wDAMbjN,OAAAgD,eACIgI,EAAA3K,UAAA,WAAQ,KADZ,WAEI,OAAOK,KAAK2D,UAAY,EAAI3D,KAAKmL,eAGrC,SAAanK,GACThB,KAAKmL,UAAYnK,EACjBhB,KAAK+K,aAAe/J,mCAKxB1B,OAAAgD,eAAIgI,EAAA3K,UAAA,eAAY,KAAhB,WACI,OAAOK,KAAK8K,eAAiBiB,EAAAA,aAAaC,0CA+B9C1B,EAAA3K,UAAAyH,mBAAA,WAAA,IAAAlF,EAAAlC,KACIA,KAAK2L,iBAAiBa,QAAQxI,UAAUhE,KAAKuL,uBAE7CvL,KAAKyM,WAAa,IAAIC,EAAAA,gBAAmB1M,KAAKyK,iBACzCkC,yBAAwB,GACxBC,0BAA0B,MAE/B5M,KAAKyM,WAAWI,OACX/I,KAAKgJ,EAAAA,UAAU9M,KAAKoL,UACpBpH,WAAS,WACF9B,EAAKuK,WAAWM,aAChB7K,EAAK8K,oBAAoB9K,EAAKuK,WAAWM,YAGrC7K,EAAKgK,aAAehK,EAAKuK,WAAWM,WAAWpJ,UAC/CzB,EAAK+K,yBAKrBjN,KAAKyM,WAAWS,OACXpJ,KAAKgJ,EAAAA,UAAU9M,KAAKoL,UACpBpH,WAAS,WAAO,OAAA9B,EAAKiL,sBAE1BnN,KAAKuH,eAAe6F,QACftJ,KAAKgJ,EAAAA,UAAU9M,KAAKoL,UACpBpH,WAAS,WACN9B,EAAKmJ,SAASnJ,EAAKmL,qBAEnBnL,EAAKuI,gBAAgBqB,qBAG7B9L,KAAKyK,gBAAgB+B,QAChB1I,KAAKgJ,EAAAA,UAAU9M,KAAKoL,UACpBpH,WAAS,SAAEsJ,GACRpL,EAAKqL,eAGLrL,EAAKsL,iBAGLF,EAAQ7B,SAAO,SAAE3D,GACbA,EAAOL,WAEPvF,EAAKmL,oBAAoB5B,SAAO,SAAEgC,GAC1B3F,EAAO9G,QAAUyM,GACjB3F,EAAON,mBAO/B8C,EAAA3K,UAAA+N,YAAA,WACI1N,KAAKoL,QAAQvK,OACbb,KAAKoL,QAAQuC,YAGjBrD,EAAA3K,UAAAgI,MAAA,SAAMkB,GACkC,IAAhC7I,KAAKyK,gBAAgBrJ,QAAgBpB,KAAK4N,gCAAgC/E,IAE9E7I,KAAKyM,WAAWoB,sBAGpBvD,EAAA3K,UAAAuI,KAAA,YACSlI,KAAK8N,oBAAsB9N,KAAK2K,wBACjC3K,KAAKyM,WAAWsB,eAAe,GAGnC/N,KAAKsL,YACLtL,KAAK6F,kBAAkB6B,gBAG3B4C,EAAA3K,UAAAqO,UAAA,SAAU3J,GAKN,OAJArE,KAAKyM,WAAWwB,eAAe,YAEf5J,EAAM6J,SAGlB,KAAKC,EAAAA,WACDnO,KAAKyM,WAAW2B,oBAEhB,MACJ,KAAKC,EAAAA,SACDrO,KAAKyM,WAAW6B,wBAEhB,MACJ,KAAKC,EAAAA,WAOD,OANIvO,KAAKyM,WAAWM,YAChB/M,KAAKkD,YAAYsL,SAASxO,KAAKyM,WAAWM,WAAe,WAG7D1I,EAAMoK,iBAGV,KAAKC,EAAAA,YAOD,OANI1O,KAAKyM,WAAWM,YAChB/M,KAAKkD,YAAYyL,OAAO3O,KAAKyM,WAAWM,WAAe,WAG3D1I,EAAMoK,iBAGV,KAAKG,EAAAA,MACL,KAAKC,EAAAA,MACD7O,KAAK8O,sBACLzK,EAAMoK,iBAEN,MACJ,KAAKM,EAAAA,KACD/O,KAAKyM,WAAWoB,qBAChBxJ,EAAMoK,iBAEN,MACJ,KAAKO,EAAAA,IACDhP,KAAKyM,WAAWwC,oBAChB5K,EAAMoK,iBAEN,MACJ,KAAKS,EAAAA,QACDlP,KAAKyM,WAAW0C,4BAChB9K,EAAMoK,iBAEN,MACJ,KAAKW,EAAAA,UACDpP,KAAKyM,WAAW4C,wBAChBhL,EAAMoK,iBAEN,MACJ,QACI,OAGJzO,KAAKyM,WAAWM,YAChB/M,KAAKsP,wBACDtP,KAAKyM,WAAWM,WAAYhE,EAAAA,eAAe1E,EAAO,YAAa0E,EAAAA,eAAe1E,EAAO,aAKjGiG,EAAA3K,UAAA4P,iBAAA,WACSvP,KAAKyK,gBAAgB+E,OAE1BxP,KAAKyM,WAAWgD,eAAeC,KAAKC,MAAM3P,KAAKuI,YAAcvI,KAAKyK,gBAAgB+E,MAAMjH,eAG5F+B,EAAA3K,UAAA2P,wBAAA,SAAwBxH,EAAWgB,EAAmBE,GAClD,GAAIF,GAAY9I,KAAKgH,SACjBhH,KAAK4P,mBAAmB9H,QACrB,GAAIkB,GACP,IAAKhJ,KAAK6P,gBAAgB/H,GAAW,YAC9B9H,KAAKkM,aACZlM,KAAKuH,eAAeuI,QACpB9P,KAAKuH,eAAenD,OAAO0D,EAAO9E,OAGtChD,KAAK+P,gBAAgBjI,IAGzBwC,EAAA3K,UAAAsJ,0BAAA,SAA0BnB,EAAWgB,EAAmBE,GAKpD,GAJKF,GAAaE,GACdhJ,KAAKyM,WAAWsB,cAAcjG,GAG9BgB,GAAY9I,KAAKgH,SACjBhH,KAAK4P,mBAAmB9H,QACrB,GAAIkB,EAAS,CAChB,IAAKhJ,KAAK6P,gBAAgB/H,GAAW,OAErC9H,KAAKuH,eAAenD,OAAO0D,EAAO9E,WAC3BhD,KAAKkM,YACZlM,KAAKuH,eAAeuI,QACpB9P,KAAKuH,eAAenD,OAAO0D,EAAO9E,OAElChD,KAAKuH,eAAenD,OAAO0D,EAAO9E,MAGtChD,KAAK+P,gBAAgBjI,IAGzBwC,EAAA3K,UAAAiQ,mBAAA,SAAmB9H,SAAnB5F,EAAAlC,KACUgQ,EAAsBlI,EAAOR,SAE/B2I,EAAYjQ,KAAKyM,WAAWyD,wBAC5BC,EAAUnQ,KAAKyM,WAAWyD,wBAA0BlQ,KAAKyM,WAAW2D,gBAEpED,IAAYF,IAEZA,EAAYE,IACXF,GAADI,EAAAlQ,EAAuB,CAACgQ,EAASF,GAAU,IAAjC,GAAEE,EAAOE,EAAA,IAGvBrQ,KAAKyK,gBACA6F,UACAC,MAAMN,EAAWE,EAAU,GAC3BK,QAAM,SAAEC,GAAS,OAACA,EAAK9M,YACvB8H,SAAO,SAAEiF,GACuBA,IAAmBxO,EAAKuK,WAAWM,YAEpC2D,EAAepJ,UAAYpF,EAAKiK,gBAE5DuE,EAAe3J,aAAaiJ,QAIxC1F,EAAA3K,UAAAgR,iBAAA,SAAiB7I,GACb9H,KAAKyM,WAAWsB,cAAcjG,IAGlCwC,EAAA3K,UAAAmP,oBAAA,eACU8B,EAAgB5Q,KAAKyM,WAAWM,YAElC6D,GAAmBA,EAActJ,WAAYtH,KAAK6P,gBAAgBe,KAClEA,EAAcxM,SACdpE,KAAK+P,gBAAgBa,KAI7BtG,EAAA3K,UAAAkR,kBAAA,SACI7N,EACA8N,EACAC,EACAC,QAFA,IAAAF,IAAAA,EAAgC9Q,KAAK8Q,iBACrC,IAAAC,IAAAA,EAAkC/Q,KAAKiR,WAAWF,eAGlDxP,EAAA5B,UAAMkR,kBAAiBhR,KAAAG,KAACgD,EAAM8N,EAAYC,EAAeC,GAEzDhR,KAAKgL,YAAchL,KAAKkR,eAAeH,GAEvC/Q,KAAKuP,mBAELvP,KAAKiR,WAAWpL,kBAAkBsL,iBAGtC7G,EAAA3K,UAAA4I,UAAA,eACUC,EAAcxI,KAAK4F,WAAWiC,cAAcY,iBAElD,OAAID,EAAYpH,OACLoH,EAAY,GAAGE,OAGnB,GAGX4B,EAAA3K,UAAAyR,cAAA,WACI,OAAOpR,KAAKyK,gBAAgB+E,MAAQxP,KAAKyK,gBAAgB+E,MAAMjH,YAAc,GAGjF+B,EAAA3K,UAAAqN,oBAAA,SAAoBlF,GAChB9H,KAAK4K,iBAAiB1B,KAAK,IAAImI,EAAuBrR,KAAM8H,KAGhEwC,EAAA3K,UAAAoQ,gBAAA,SAAgBjI,GACZ9H,KAAK6K,gBAAgB3B,KAAK,IAAImI,EAAuBrR,KAAM8H,KAG/DwC,EAAA3K,UAAA2R,WAAA,SAAWtQ,GACP,GAAIhB,KAAKgH,UAAYhG,IAAUvB,MAAM8R,QAAQvQ,GACzC,MAAMwQ,EAAAA,gCAGNxR,KAAKyK,gBAAgBrJ,QACrBpB,KAAKyR,qBAAqBzR,KAAKgH,SAAWhG,EAAQ,CAACA,KAO3DsJ,EAAA3K,UAAA+R,iBAAA,SAAiBC,GACb3R,KAAKqL,SAAWsG,GAMpBrH,EAAA3K,UAAAiS,kBAAA,SAAkBD,GACd3R,KAAKsL,UAAYqG,GAMrBrH,EAAA3K,UAAAkS,iBAAA,SAAiBC,GACb9R,KAAKkG,UAAY4L,EACjB9R,KAAK6F,kBAAkB6B,gBAG3B4C,EAAA3K,UAAA8R,qBAAA,SAAqBM,SAArB7P,EAAAlC,KACIA,KAAKuH,eAAeuI,YAEdkC,EAAiBD,EAAOE,QAAM,SAAEC,EAAQlR,GAC1C,OAAOkB,EAAKgB,YAAYiP,SAASnR,GAAME,EAAOgR,EAAM,CAAEhQ,EAAKgB,YAAYiP,SAASnR,KAAME,EAAQgR,KAC/F,KAEH7B,EAAArQ,KAAKuH,gBAAeC,OAAMrF,MAAAkO,EAAAnP,EAAI8Q,KAGlC1H,EAAA3K,UAAA0N,kBAAA,WAAA,IAAAnL,EAAAlC,KACI,OAAOA,KAAKuH,eAAeD,SAASvD,KAAG,SAAEuD,GAAa,OAAApF,EAAKgB,YAAYmE,SAASC,OAG1EgD,EAAA3K,UAAA6N,eAAA,WACNxN,KAAKmL,UAA4C,IAAhCnL,KAAKyK,gBAAgBrJ,QAAgB,EAAI,GAkBtDkJ,EAAA3K,UAAAuR,eAAA,SAAeH,GAGnB,QAFMqB,EAAa,GAEVzR,EAAI,EAAGA,EAAIoQ,EAAc3P,OAAQT,IAAK,KACrC0R,EAAUtB,EAAcuB,IAAI3R,GAElCyR,EAAMrR,KAAKsR,EAAQE,QAAQC,WAG/B,OAAOJ,GAGH9H,EAAA3K,UAAAwN,iBAAA,WAAA,IAAAjL,EAAAlC,MACoB,IAApBA,KAAKmL,YACLnL,KAAKmL,WAAa,EAElBsH,YAAU,WACNvQ,EAAKiJ,UAAYjJ,EAAK6I,cAAgB,EACtC7I,EAAK2D,kBAAkB6B,oBAK3B4C,EAAA3K,UAAA4N,aAAA,WACJvN,KAAK0S,oBACL1S,KAAK2S,wBAGDrI,EAAA3K,UAAA+S,kBAAA,WACA1S,KAAK4S,0BACL5S,KAAK4S,wBAAwBC,cAC7B7S,KAAK4S,wBAA0B,MAG/B5S,KAAK8S,yBACL9S,KAAK8S,uBAAuBD,cAC5B7S,KAAK8S,uBAAyB,OAI9BxI,EAAA3K,UAAAgT,qBAAA,WAAA,IAAAzQ,EAAAlC,KACJA,KAAK4S,wBAA0B5S,KAAK+S,mBAC/B/O,WAAS,SAAEK,OACF2O,EAAgB9Q,EAAKuI,gBAAgB6F,UAAU2C,QAAQ5O,EAAY,QAEzEnC,EAAKuI,gBACA+F,QAAM,SAAE1I,GAAW,OAAAA,EAAOvB,YAC1BkF,SAAO,SAAE3D,GAAW,OAAAA,EAAOvB,UAAW,KAEvCrE,EAAKgR,aAAaF,IAClB9Q,EAAKuK,WAAW0G,iBAAiBH,MAI7ChT,KAAK8S,uBAAyB9S,KAAKoT,kBAC9BpP,WAAS,WAAO,OAAA9B,EAAKgG,WAQtBoC,EAAA3K,UAAAuT,aAAA,SAAaF,GACjB,OAAOA,GAAS,GAAKA,EAAQhT,KAAKyK,gBAAgBrJ,QAI9CkJ,EAAA3K,UAAAmO,iBAAA,WACJ,OAAO9N,KAAKyK,gBAAgB4I,MAAI,SAAEvL,GAAW,OAAAA,EAAOvB,aAGhD+D,EAAA3K,UAAA4M,oBAAA,WACAvM,KAAKyK,gBAAgBrJ,QACrBpB,KAAKyK,gBAAgBgB,SAAO,SAAE3D,GAAW,OAAAA,EAAOJ,mBAIhD4C,EAAA3K,UAAAsN,mBAAA,WACJjN,KAAKyK,gBACA+F,QAAM,SAAE1I,GAAW,OAAAA,EAAOvB,YAC1BkF,SAAO,SAAE3D,GAAW,OAAAA,EAAOvB,UAAW,MAGvC+D,EAAA3K,UAAAkQ,gBAAA,SAAgB/H,GACpB,QAAS9H,KAAKmM,gBAA0D,IAAxCnM,KAAKuH,eAAeD,SAASlG,QAAgB0G,EAAOR,WAGhFgD,EAAA3K,UAAAiO,gCAAA,SAAgC/E,GACpC,SAAKA,IAAWA,EAAOyK,gBAEfzK,EAAoB,cAAiB0K,UAAUC,SAAS,sBArhBXrO,EAAAA,6BAzB5DV,EAAAA,UAAS/C,KAAA,CAAC,CACPC,SAAU,oBACVyH,SAAU,kBACV1E,SAAU,kDAEVC,KAAM,CACFC,MAAO,oBAEP0E,kBAAmB,WACnBxE,kBAAmB,mBAEnB4E,SAAU,SACVD,UAAW,gBAEXgK,YAAa,oBACbC,kBAAmB,sBAEvB1O,cAAeC,EAAAA,kBAAkBC,KACjCyE,gBAAiBC,EAAAA,wBAAwBC,OACzChI,UAAW,CACPsI,EACA,CAAErI,QAASwD,EAAiCvD,YAAauI,GACzD,CAAExI,QAASqD,EAAAA,QAASpD,YAAauI,kmBAlFrCR,EAAAA,kBAKA6J,EAAAA,uBARA5J,EAAAA,yBAkCAgC,EAAAA,aAAY6H,WAAA,CAAA,CAAAC,KA8JPC,EAAAA,UAASpS,KAAA,CAAC,qDArGdqS,EAAAA,UAASrS,KAAA,CAACsS,EAAAA,kBAAmB,CAAEC,QAAQ,8BAEvCC,EAAAA,gBAAexS,KAAA,CAACiE,wBAUhB3D,EAAAA,gCAEAkI,EAAAA,gCAEAA,EAAAA,2BAQAlI,EAAAA,8BAuBAA,EAAAA,wBAWAA,EAAAA,wBAiBAA,EAAAA,aCjKCmS,EAAqB,CACvB7J,EACA3E,EACArE,EACAW,EACAyB,EACA2B,KAQJ,iCALC+O,EAAAA,SAAQ1S,KAAA,CAAC,CACN2S,QAAS,CAACC,EAAAA,aAAcC,EAAAA,cAAeC,EAAAA,wBACvCC,QAASN,EACTO,aAAcP,uBCiBd,SAAAQ,EACWC,EACAzR,EACAI,EACAsR,GAHA7U,KAAA4U,kBAAAA,EACA5U,KAAAmD,SAAAA,EACAnD,KAAAuD,aAAAA,EACAvD,KAAA6U,YAAAA,SAGXF,EAAAhV,UAAAmV,YAAA,SAAY3Q,EAASf,EAAe2R,EAAkBC,GAAtD,IAAA9S,EAAAlC,KACUiV,EAAWjV,KAAK4U,kBAAkBzQ,EAAMf,EAAO4R,GAGrD,GAFAD,EAAYhU,KAAKkU,GAEbjV,KAAKuD,aAAa0R,GAAW,KACvBC,EAAgBlV,KAAK6U,YAAY1Q,GAEnC+Q,IACIzV,MAAM8R,QAAQ2D,GACdlV,KAAKmV,gBAAgBD,EAAe9R,EAAO2R,EAAaE,GAExDC,EACKpR,KAAKuE,EAAAA,KAAK,IACVrE,WAAS,SAAEoR,GACRlT,EAAKiT,gBAAgBC,EAAUhS,EAAO2R,EAAaE,OAMvE,OAAOF,GAGXJ,EAAAhV,UAAAwV,gBAAA,SAAgBC,EAAehS,EAAe2R,EAAkBC,GAAhE,IAAA9S,EAAAlC,KACIoV,EAAS3J,SAAO,SAAE4J,GACdnT,EAAK4S,YAAYO,EAAOjS,EAAQ,EAAG2R,EAAaC,OASxDL,EAAAhV,UAAA2V,aAAA,SAAaC,GAAb,IAAArT,EAAAlC,KACU+U,EAAmB,GAGzB,OAFAQ,EAAe9J,SAAO,SAAEtH,GAAS,OAAAjC,EAAK4S,YAAY3Q,EAAM,EAAG4Q,EAAa,SAEjEA,GAOXJ,EAAAhV,UAAA6V,qBAAA,SAAqBC,EAAYvS,GAAjC,IAAAhB,EAAAlC,KACU0V,EAAe,GACfC,EAA2B,GAgBjC,OAfAA,EAAc,IAAK,EAEnBF,EAAMhK,SAAO,SAAEtH,GAEX,QADIwK,GAAS,EACJhO,EAAI,EAAGA,GAAKuB,EAAKiB,SAASgB,GAAOxD,IACtCgO,EAASA,GAAUgH,EAAchV,GAGjCgO,GAAU+G,EAAQ3U,KAAKoD,GAEvBjC,EAAKqB,aAAaY,KAClBwR,EAAczT,EAAKiB,SAASgB,GAAQ,GAAKjB,EAAYgB,WAAWC,OAIjEuR,QAIf,IAAKE,EACQ,YADRA,EAEK,uBA8BN,SAAAC,EACY3S,EACA4S,EACRC,QAAA,IAAAA,IAAAA,EAAA,IAHJ,IAAA7T,EAKIX,EAAA1B,KAAAG,OAAOA,YAJCkC,EAAAgB,YAAAA,EACAhB,EAAA4T,cAAAA,EArBZ5T,EAAA8T,cAAgB,IAAIC,EAAAA,gBAAqB,IAEzC/T,EAAAgU,aAAe,IAAID,EAAAA,gBAAqB,IAExC/T,EAAAiU,aAAe,IAAIF,EAAAA,gBAAqB,IAsBpC/T,EAAKkU,MAAQ,IAAIH,EAAAA,gBAAqBF,YA3BEjW,EAAA+V,EAAAtU,GAO5CjC,OAAAgD,eAAIuT,EAAAlW,UAAA,OAAI,KAAR,WACI,OAAOK,KAAKoW,MAAMpV,WAGtB,SAASA,GACLhB,KAAKoW,MAAMvV,KAAKG,GAEhBhB,KAAKgW,cAAcnV,KAAKb,KAAK8V,cAAcR,aAAatV,KAAKgD,OAC7DhD,KAAKkD,YAAYmT,UAAYrW,KAAKgW,cAAchV,uCAepD6U,EAAAlW,UAAA2W,QAAA,SAAQC,GAAR,IAAArU,EAAAlC,KACI,OAAOqM,EAAAA,MACHkK,EAAiBC,WACjBxW,KAAKkD,YAAYuT,eAAerJ,QAC3BtJ,KAAKC,EAAAA,KAAG,SAAE/C,GAAU,MAAA,CAAG6S,KAAM+B,EAAuC5U,MAAKA,OAC9EhB,KAAKkD,YAAYW,YACZC,KAAKC,EAAAA,KAAG,SAAE/C,GAAU,MAAA,CAAG6S,KAAM+B,EAAoC5U,MAAKA,OAC3EhB,KAAKgW,eAERlS,KAAKC,EAAAA,KAAG,SAAE2S,GACP,OAAIA,EAAU7C,OAAS+B,GACfc,EAAU1V,OAAS0V,EAAU1V,MAAMI,OAAS,EACrCc,EAAKyU,gBAMbzU,EAAK0U,wBAIpBf,EAAAlW,UAAAgX,cAAA,WAGI,OAFA3W,KAAKmW,aAAatV,KAAKb,KAAKkD,YAAY2T,YAAYvP,UAE7CtH,KAAKmW,aAAanV,OAG7B6U,EAAAlW,UAAAiX,iBAAA,eACUE,EAAgB9W,KAAK8V,cAAcN,qBAAqBxV,KAAKgW,cAAchV,MAAOhB,KAAKkD,aAG7F,OAFAlD,KAAKkW,aAAarV,KAAKiW,GAEhB9W,KAAKkW,aAAalV,OAG7B6U,EAAAlW,UAAAoX,WAAA,gBAjE4CC,EAAAA,8BCpHhD,SAAAC,IAAA,IAAA/U,EAAAX,EAAAY,MAAAnC,KAAAkB,EAAAC,aAAAnB,YAWYkC,EAAAkU,MAAQ,IAAIH,EAAAA,gBAAqB,aAXEnW,EAAAmX,EAAA1V,GAE3CjC,OAAAgD,eAAI2U,EAAAtX,UAAA,OAAI,KAAR,WACI,OAAOK,KAAKoW,MAAMpV,WAGtB,SAASA,GACLhB,KAAKoW,MAAMvV,KAAKG,oCAMpBiW,EAAAtX,UAAA2W,QAAA,SAAQC,GAAR,IAAArU,EAAAlC,KACI,OAAOqM,EAAAA,MAAKlK,WAAA,EAAAjB,EAAI,CAACqV,EAAiBC,WAAYxW,KAAKoW,SAC9CtS,KAAKC,EAAAA,KAAG,WAAO,OAAA7B,EAAKc,UAG7BiU,EAAAtX,UAAAoX,WAAA,gBAlB2CC,EAAAA","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import { Directive, Input } from '@angular/core';\nimport { CdkTreeNodeDef } from '@ptsecurity/cdk/tree';\n\n\n@Directive({\n    selector: '[mcTreeNodeDef]',\n    inputs: ['when: mcTreeNodeDefWhen'],\n    providers: [{ provide: CdkTreeNodeDef, useExisting: McTreeNodeDef }]\n})\nexport class McTreeNodeDef<T> extends CdkTreeNodeDef<T> {\n    @Input('mcTreeNode') data: T;\n}\n","import { Directive, Input, OnInit } from '@angular/core';\nimport { CdkTreeNodePadding } from '@ptsecurity/cdk/tree';\n\n\n@Directive({\n    selector: '[mcTreeNodePadding]',\n    providers: [{ provide: CdkTreeNodePadding, useExisting: McTreeNodePadding }]\n})\nexport class McTreeNodePadding<T> extends CdkTreeNodePadding<T> implements OnInit {\n\n    @Input('mcTreeNodePadding')\n    get level(): number { return this._level; }\n    set level(value: number) { this.setLevelInput(value); }\n\n    @Input('mcTreeNodePaddingIndent')\n    get indent(): number | string { return this._indent; }\n    set indent(indent: number | string) { this.setIndentInput(indent); }\n\n    baseLeftPadding: number = 12;\n\n    withIcon: boolean;\n    iconWidth: number = 20;\n\n    get leftPadding(): number {\n        return (this.withIcon ? 0 : this.iconWidth) + this.baseLeftPadding;\n    }\n\n    paddingIndent(): string | null {\n        const nodeLevel = (this.treeNode.data && this.tree.treeControl.getLevel)\n            ? this.tree.treeControl.getLevel(this.treeNode.data)\n            : 0;\n\n        const level = this.level || nodeLevel;\n\n        return level > 0 ? `${(level * this._indent) + this.leftPadding}px` : `${this.leftPadding}px`;\n    }\n\n    ngOnInit(): void {\n        this.withIcon = this.tree.treeControl.isExpandable(this.treeNode.data);\n\n        this.setPadding();\n    }\n}\n","import { Component, Directive, Input, ViewEncapsulation } from '@angular/core';\nimport { CdkTree, CdkTreeNode } from '@ptsecurity/cdk/tree';\nimport { map } from 'rxjs/operators';\n\n\n@Component({\n    selector: 'mc-tree-node-toggle',\n    template: `\n        <i class=\"mc mc-icon mc-angle-down-S_16\"></i>\n    `,\n    host: {\n        class: 'mc-tree-node-toggle',\n        '[class.mc-opened]': 'iconState',\n        '[attr.disabled]': 'disabled || null',\n        '(click)': 'toggle($event)'\n    },\n    encapsulation: ViewEncapsulation.None\n})\nexport class McTreeNodeToggleComponent<T> {\n    disabled: boolean = false;\n\n    @Input() node: T;\n\n    @Input('cdkTreeNodeToggleRecursive')\n    get recursive(): boolean {\n        return this._recursive;\n    }\n\n    set recursive(value: boolean) {\n        this._recursive = value;\n    }\n\n    private _recursive = false;\n\n    get iconState(): any {\n        return this.disabled || this.tree.treeControl.isExpanded(this.node);\n    }\n\n    constructor(private tree: CdkTree<T>, private treeNode: CdkTreeNode<T>) {\n        this.tree.treeControl.filterValue\n            .pipe(map((value) => value.length > 0))\n            .subscribe((state: boolean) => this.disabled = state);\n    }\n\n    toggle(event: Event): void {\n        this.recursive\n            ? this.tree.treeControl.toggleDescendants(this.treeNode.data)\n            : this.tree.treeControl.toggle(this.treeNode.data);\n\n        event.stopPropagation();\n    }\n}\n\n@Directive({\n    selector: '[mcTreeNodeToggle]',\n    host: {\n        '[attr.disabled]': 'disabled || null',\n        '(click)': 'toggle($event)'\n    }\n})\nexport class McTreeNodeToggleDirective<T> {\n    disabled: boolean = false;\n\n    @Input('cdkTreeNodeToggleRecursive')\n    get recursive(): boolean {\n        return this._recursive;\n    }\n\n    set recursive(value: boolean) {\n        this._recursive = value;\n    }\n\n    private _recursive = false;\n\n    constructor(private tree: CdkTree<T>, private treeNode: CdkTreeNode<T>) {\n\n        this.tree.treeControl.filterValue\n            .pipe(map((value) => value.length > 0))\n            .subscribe((state: boolean) => this.disabled = state);\n    }\n\n    toggle(event: Event): void {\n        this.recursive\n            ? this.tree.treeControl.toggleDescendants(this.treeNode.data)\n            : this.tree.treeControl.toggle(this.treeNode.data);\n\n        event.stopPropagation();\n    }\n}\n","import { FocusOrigin } from '@angular/cdk/a11y';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport {\n    ChangeDetectorRef,\n    Component,\n    EventEmitter,\n    Input,\n    Output,\n    ElementRef,\n    Inject,\n    InjectionToken,\n    ChangeDetectionStrategy,\n    ViewEncapsulation,\n    AfterContentInit,\n    NgZone\n} from '@angular/core';\nimport { hasModifierKey } from '@ptsecurity/cdk/keycodes';\nimport { CdkTreeNode } from '@ptsecurity/cdk/tree';\nimport { CanDisable } from '@ptsecurity/mosaic/core';\nimport { Subject } from 'rxjs';\nimport { take } from 'rxjs/operators';\n\n\n// tslint:disable-next-line:naming-convention\nexport interface McTreeOptionEvent {\n    option: McTreeOption;\n}\n\n/**\n * Injection token used to provide the parent component to options.\n */\nexport const MC_TREE_OPTION_PARENT_COMPONENT = new InjectionToken<any>('MC_TREE_OPTION_PARENT_COMPONENT');\n\nexport class McTreeOptionChange {\n    constructor(public source: McTreeOption, public isUserInput = false) {}\n}\n\nlet uniqueIdCounter: number = 0;\n\n@Component({\n    selector: 'mc-tree-option',\n    exportAs: 'mcTreeOption',\n    templateUrl: './tree-option.html',\n    host: {\n        '[attr.id]': 'id',\n        '[attr.tabindex]': '-1',\n\n        '[attr.disabled]': 'disabled || null',\n\n        class: 'mc-tree-option',\n        '[class.mc-selected]': 'selected',\n        '[class.mc-focused]': 'hasFocus',\n\n        '(focus)': 'focus()',\n        '(blur)': 'blur()',\n\n        '(click)': 'selectViaInteraction($event)'\n    },\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    encapsulation: ViewEncapsulation.None,\n    providers: [{ provide: CdkTreeNode, useExisting: McTreeOption }]\n})\nexport class McTreeOption extends CdkTreeNode<McTreeOption> implements CanDisable, AfterContentInit {\n    readonly onFocus = new Subject<McTreeOptionEvent>();\n\n    readonly onBlur = new Subject<McTreeOptionEvent>();\n\n    get value(): any {\n        return this._value;\n    }\n\n    set value(value: any) {\n        this._value = value;\n    }\n\n    private _value: any;\n\n    @Input()\n    get disabled() {\n        return this._disabled || (this.tree && this.tree.disabled);\n    }\n\n    set disabled(value: any) {\n        const newValue = coerceBooleanProperty(value);\n\n        if (newValue !== this._disabled) {\n            this._disabled = newValue;\n        }\n    }\n\n    private _disabled: boolean = false;\n\n    @Input()\n    get showCheckbox() {\n        return this._showCheckbox !== undefined ? this._showCheckbox : this.tree.showCheckbox;\n    }\n\n    set showCheckbox(value: any) {\n        this._showCheckbox = coerceBooleanProperty(value);\n    }\n\n    private _showCheckbox: boolean;\n\n    @Output() readonly onSelectionChange = new EventEmitter<McTreeOptionChange>();\n\n    get selected(): boolean {\n        return this._selected;\n    }\n\n    set selected(value: boolean) {\n        const isSelected = coerceBooleanProperty(value);\n\n        if (isSelected !== this._selected) {\n            this.setSelected(isSelected);\n        }\n    }\n\n    private _selected: boolean = false;\n\n    get id(): string {\n        return this._id;\n    }\n\n    private _id = `mc-tree-option-${uniqueIdCounter++}`;\n\n    get multiple(): boolean {\n        return this.tree.multiple;\n    }\n\n    get viewValue(): string {\n        // TODO: Add input property alternative for node envs.\n        return (this.getHostElement().textContent || '').trim();\n    }\n\n    hasFocus: boolean = false;\n\n    constructor(\n        elementRef: ElementRef,\n        private changeDetectorRef: ChangeDetectorRef,\n        private ngZone: NgZone,\n        @Inject(MC_TREE_OPTION_PARENT_COMPONENT) public tree: any\n    ) {\n        super(elementRef, tree);\n    }\n\n    ngAfterContentInit(): void {\n        this.value = this.tree.treeControl.getValue(this.data);\n    }\n\n    toggle(): void {\n        this.selected = !this.selected;\n    }\n\n    setSelected(selected: boolean): void {\n        if (this._selected === selected || !this.tree.selectionModel) { return; }\n\n        this._selected = selected;\n\n        if (selected) {\n            this.tree.selectionModel.select(this.data);\n        } else {\n            this.tree.selectionModel.deselect(this.data);\n        }\n\n        this.changeDetectorRef.markForCheck();\n    }\n\n    focus(focusOrigin?: FocusOrigin) {\n        if (focusOrigin === 'program') { return; }\n\n        if (this.disabled || this.hasFocus) { return; }\n\n        this.elementRef.nativeElement.focus();\n\n        this.onFocus.next({ option: this });\n\n        Promise.resolve().then(() => {\n            this.hasFocus = true;\n\n            this.changeDetectorRef.markForCheck();\n        });\n    }\n\n    blur(): void {\n        // When animations are enabled, Angular may end up removing the option from the DOM a little\n        // earlier than usual, causing it to be blurred and throwing off the logic in the tree\n        // that moves focus not the next item. To work around the issue, we defer marking the option\n        // as not focused until the next time the zone stabilizes.\n        this.ngZone.onStable\n            .asObservable()\n            .pipe(take(1))\n            .subscribe(() => {\n                this.ngZone.run(() => {\n                    this.hasFocus = false;\n\n                    this.onBlur.next({ option: this });\n                });\n            });\n    }\n\n    getHeight(): number {\n        const clientRects = this.elementRef.nativeElement.getClientRects();\n\n        if (clientRects.length) {\n            return clientRects[0].height;\n        }\n\n        return 0;\n    }\n\n    select(): void {\n        if (!this._selected) {\n            this._selected = true;\n\n            this.changeDetectorRef.markForCheck();\n            this.emitSelectionChangeEvent();\n        }\n    }\n\n    deselect(): void {\n        if (this._selected) {\n            this._selected = false;\n\n            this.changeDetectorRef.markForCheck();\n        }\n    }\n\n    selectViaInteraction($event?: KeyboardEvent): void {\n        if (!this.disabled) {\n            this.changeDetectorRef.markForCheck();\n            this.emitSelectionChangeEvent(true);\n\n            const shiftKey = $event ? hasModifierKey($event, 'shiftKey') : false;\n            const ctrlKey = $event ? hasModifierKey($event, 'ctrlKey') : false;\n\n            this.tree.setSelectedOptionsByClick(this, shiftKey, ctrlKey);\n        }\n    }\n\n    emitSelectionChangeEvent(isUserInput = false): void {\n        this.onSelectionChange.emit(new McTreeOptionChange(this, isUserInput));\n    }\n\n    getHostElement(): HTMLElement {\n        return this.elementRef.nativeElement;\n    }\n\n    markForCheck() {\n        this.changeDetectorRef.markForCheck();\n    }\n}\n","/* tslint:disable:no-empty */\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport {\n    AfterContentInit,\n    Attribute,\n    ChangeDetectionStrategy,\n    ChangeDetectorRef,\n    Component,\n    ContentChildren,\n    ElementRef,\n    EventEmitter,\n    forwardRef,\n    Input,\n    IterableDiffer,\n    IterableDiffers,\n    Output,\n    QueryList,\n    ViewChild, ViewContainerRef,\n    ViewEncapsulation\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { FocusKeyManager } from '@ptsecurity/cdk/a11y';\nimport {\n    hasModifierKey,\n    END,\n    ENTER,\n    HOME,\n    LEFT_ARROW,\n    PAGE_DOWN,\n    PAGE_UP,\n    RIGHT_ARROW,\n    SPACE,\n    DOWN_ARROW,\n    UP_ARROW\n} from '@ptsecurity/cdk/keycodes';\nimport { CdkTree, CdkTreeNodeOutlet, FlatTreeControl } from '@ptsecurity/cdk/tree';\nimport {\n    CanDisable,\n    getMcSelectNonArrayValueError,\n    HasTabIndex,\n    MultipleMode\n} from '@ptsecurity/mosaic/core';\nimport { merge, Observable, Subject, Subscription } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\nimport { MC_TREE_OPTION_PARENT_COMPONENT, McTreeOption, McTreeOptionEvent } from './tree-option.component';\n\n\nexport const MC_SELECTION_TREE_VALUE_ACCESSOR: any = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => McTreeSelection),\n    multi: true\n};\n\nexport class McTreeNavigationChange<T> {\n    constructor(public source: McTreeSelection<any>, public option: T) {}\n}\n\nexport class McTreeSelectionChange<T> {\n    constructor(public source: McTreeSelection<any>, public option: T) {}\n}\n\n// tslint:disable-next-line:naming-convention\ninterface SelectionModelOption {\n    id: number | string;\n    value: string;\n}\n\n\n@Component({\n    selector: 'mc-tree-selection',\n    exportAs: 'mcTreeSelection',\n    template: '<ng-container cdkTreeNodeOutlet></ng-container>',\n    styleUrls: ['./tree.scss'],\n    host: {\n        class: 'mc-tree-selection',\n\n        '[attr.tabindex]': 'tabIndex',\n        '[attr.disabled]': 'disabled || null',\n\n        '(blur)': 'blur()',\n        '(focus)': 'focus($event)',\n\n        '(keydown)': 'onKeyDown($event)',\n        '(window:resize)': 'updateScrollSize()'\n    },\n    encapsulation: ViewEncapsulation.None,\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    providers: [\n        MC_SELECTION_TREE_VALUE_ACCESSOR,\n        { provide: MC_TREE_OPTION_PARENT_COMPONENT, useExisting: McTreeSelection },\n        { provide: CdkTree, useExisting: McTreeSelection }\n    ]\n})\nexport class McTreeSelection<T extends McTreeOption> extends CdkTree<T>\n    implements ControlValueAccessor, AfterContentInit, CanDisable, HasTabIndex {\n\n    @ViewChild(CdkTreeNodeOutlet, { static: true }) nodeOutlet: CdkTreeNodeOutlet;\n\n    @ContentChildren(McTreeOption) unorderedOptions: QueryList<T>;\n\n    renderedOptions = new QueryList<T>();\n\n    keyManager: FocusKeyManager<T>;\n\n    selectionModel: SelectionModel<SelectionModelOption>;\n\n    resetFocusedItemOnBlur: boolean = true;\n\n    @Input() treeControl: FlatTreeControl<T>;\n\n    @Output() readonly navigationChange = new EventEmitter<McTreeNavigationChange<T>>();\n\n    @Output() readonly selectionChange = new EventEmitter<McTreeSelectionChange<T>>();\n\n    multipleMode: MultipleMode | null = null;\n\n    userTabIndex: number | null = null;\n\n    private sortedNodes: T[] = [];\n\n    @Input()\n    get autoSelect(): boolean {\n        return this._autoSelect;\n    }\n\n    set autoSelect(value: boolean) {\n        this._autoSelect = coerceBooleanProperty(value);\n    }\n\n    private _autoSelect: boolean = true;\n\n    get optionFocusChanges(): Observable<McTreeOptionEvent> {\n        return merge(...this.renderedOptions.map((option) => option.onFocus));\n    }\n\n    get optionBlurChanges(): Observable<McTreeOptionEvent> {\n        return merge(...this.renderedOptions.map((option) => option.onBlur));\n    }\n\n    get multiple(): boolean {\n        return !!this.multipleMode;\n    }\n\n    @Input()\n    get noUnselectLast(): boolean {\n        return this._noUnselectLast;\n    }\n\n    set noUnselectLast(value: boolean) {\n        this._noUnselectLast = coerceBooleanProperty(value);\n    }\n\n    private _noUnselectLast: boolean = true;\n\n    @Input()\n    get disabled(): boolean {\n        return this._disabled;\n    }\n\n    set disabled(rawValue: boolean) {\n        const value = coerceBooleanProperty(rawValue);\n\n        if (this._disabled !== value) {\n            this._disabled = value;\n\n            this.markOptionsForCheck();\n        }\n    }\n\n    private _disabled: boolean = false;\n\n    @Input()\n    get tabIndex(): any {\n        return this.disabled ? -1 : this._tabIndex;\n    }\n\n    set tabIndex(value: any) {\n        this._tabIndex = value;\n        this.userTabIndex = value;\n    }\n\n    private _tabIndex = 0;\n\n    get showCheckbox(): boolean {\n        return this.multipleMode === MultipleMode.CHECKBOX;\n    }\n\n    private readonly destroy = new Subject<void>();\n\n    private optionFocusSubscription: Subscription | null;\n\n    private optionBlurSubscription: Subscription | null;\n\n    constructor(\n        private elementRef: ElementRef,\n        differs: IterableDiffers,\n        changeDetectorRef: ChangeDetectorRef,\n        @Attribute('multiple') multiple: MultipleMode\n    ) {\n        super(differs, changeDetectorRef);\n\n        if (multiple === MultipleMode.CHECKBOX || multiple === MultipleMode.KEYBOARD) {\n            this.multipleMode = multiple;\n        } else if (multiple !== null) {\n            this.multipleMode = MultipleMode.CHECKBOX;\n        }\n\n        if (this.multipleMode === MultipleMode.CHECKBOX) {\n            this.autoSelect = false;\n            this.noUnselectLast = false;\n        }\n\n        this.selectionModel = new SelectionModel<SelectionModelOption>(this.multiple);\n    }\n\n    ngAfterContentInit(): void {\n        this.unorderedOptions.changes.subscribe(this.updateRenderedOptions);\n\n        this.keyManager = new FocusKeyManager<T>(this.renderedOptions)\n            .withVerticalOrientation(true)\n            .withHorizontalOrientation(null);\n\n        this.keyManager.change\n            .pipe(takeUntil(this.destroy))\n            .subscribe(() => {\n                if (this.keyManager.activeItem) {\n                    this.emitNavigationEvent(this.keyManager.activeItem);\n\n                    // todo need check this logic\n                    if (this.autoSelect && !this.keyManager.activeItem.disabled) {\n                        this.updateOptionsFocus();\n                    }\n                }\n            });\n\n        this.keyManager.tabOut\n            .pipe(takeUntil(this.destroy))\n            .subscribe(() => this.allowFocusEscape());\n\n        this.selectionModel.changed\n            .pipe(takeUntil(this.destroy))\n            .subscribe(() => {\n                this.onChange(this.getSelectedValues());\n\n                this.renderedOptions.notifyOnChanges();\n            });\n\n        this.renderedOptions.changes\n            .pipe(takeUntil(this.destroy))\n            .subscribe((options) => {\n                this.resetOptions();\n\n                // Check to see if we need to update our tab index\n                this.updateTabIndex();\n\n                // todo need to do optimisation\n                options.forEach((option) => {\n                    option.deselect();\n\n                    this.getSelectedValues().forEach((selectedValue) => {\n                        if (option.value === selectedValue) {\n                            option.select();\n                        }\n                    });\n                });\n            });\n    }\n\n    ngOnDestroy(): void {\n        this.destroy.next();\n        this.destroy.complete();\n    }\n\n    focus($event): void {\n        if (this.renderedOptions.length === 0 || this.isFocusReceivedFromNestedOption($event)) { return; }\n\n        this.keyManager.setFirstItemActive();\n    }\n\n    blur() {\n        if (!this.hasFocusedOption() && this.resetFocusedItemOnBlur) {\n            this.keyManager.setActiveItem(-1);\n        }\n\n        this.onTouched();\n        this.changeDetectorRef.markForCheck();\n    }\n\n    onKeyDown(event: KeyboardEvent): void {\n        this.keyManager.setFocusOrigin('keyboard');\n        // tslint:disable-next-line: deprecation\n        const keyCode = event.keyCode;\n\n        switch (keyCode) {\n            case DOWN_ARROW:\n                this.keyManager.setNextItemActive();\n\n                break;\n            case UP_ARROW:\n                this.keyManager.setPreviousItemActive();\n\n                break;\n            case LEFT_ARROW:\n                if (this.keyManager.activeItem) {\n                    this.treeControl.collapse(this.keyManager.activeItem.data as T);\n                }\n\n                event.preventDefault();\n\n                return;\n            case RIGHT_ARROW:\n                if (this.keyManager.activeItem) {\n                    this.treeControl.expand(this.keyManager.activeItem.data as T);\n                }\n\n                event.preventDefault();\n\n                return;\n            case SPACE:\n            case ENTER:\n                this.toggleFocusedOption();\n                event.preventDefault();\n\n                break;\n            case HOME:\n                this.keyManager.setFirstItemActive();\n                event.preventDefault();\n\n                break;\n            case END:\n                this.keyManager.setLastItemActive();\n                event.preventDefault();\n\n                break;\n            case PAGE_UP:\n                this.keyManager.setPreviousPageItemActive();\n                event.preventDefault();\n\n                break;\n            case PAGE_DOWN:\n                this.keyManager.setNextPageItemActive();\n                event.preventDefault();\n\n                break;\n            default:\n                return;\n        }\n\n        if (this.keyManager.activeItem) {\n            this.setSelectedOptionsByKey(\n                this.keyManager.activeItem, hasModifierKey(event, 'shiftKey'), hasModifierKey(event, 'ctrlKey')\n            );\n        }\n    }\n\n    updateScrollSize(): void {\n        if (!this.renderedOptions.first) { return; }\n\n        this.keyManager.withScrollSize(Math.floor(this.getHeight() / this.renderedOptions.first.getHeight()));\n    }\n\n    setSelectedOptionsByKey(option: T, shiftKey: boolean, ctrlKey: boolean): void {\n        if (shiftKey && this.multiple) {\n            this.setSelectedOptions(option);\n        } else if (ctrlKey) {\n            if (!this.canDeselectLast(option)) { return; }\n        } else if (this.autoSelect) {\n            this.selectionModel.clear();\n            this.selectionModel.toggle(option.data);\n        }\n\n        this.emitChangeEvent(option);\n    }\n\n    setSelectedOptionsByClick(option: T, shiftKey: boolean, ctrlKey: boolean): void {\n        if (!shiftKey && !ctrlKey) {\n            this.keyManager.setActiveItem(option);\n        }\n\n        if (shiftKey && this.multiple) {\n            this.setSelectedOptions(option);\n        } else if (ctrlKey) {\n            if (!this.canDeselectLast(option)) { return; }\n\n            this.selectionModel.toggle(option.data);\n        } else if (this.autoSelect) {\n            this.selectionModel.clear();\n            this.selectionModel.toggle(option.data);\n        } else {\n            this.selectionModel.toggle(option.data);\n        }\n\n        this.emitChangeEvent(option);\n    }\n\n    setSelectedOptions(option: T): void {\n        const selectedOptionState = option.selected;\n\n        let fromIndex = this.keyManager.previousActiveItemIndex;\n        let toIndex = this.keyManager.previousActiveItemIndex = this.keyManager.activeItemIndex;\n\n        if (toIndex === fromIndex) { return; }\n\n        if (fromIndex > toIndex) {\n            [fromIndex, toIndex] = [toIndex, fromIndex];\n        }\n\n        this.renderedOptions\n            .toArray()\n            .slice(fromIndex, toIndex + 1)\n            .filter((item) => !item.disabled)\n            .forEach((renderedOption) => {\n                const isLastRenderedOption = renderedOption === this.keyManager.activeItem;\n\n                if (isLastRenderedOption && renderedOption.selected && this.noUnselectLast) { return; }\n\n                renderedOption.setSelected(!selectedOptionState);\n            });\n    }\n\n    setFocusedOption(option: T): void {\n        this.keyManager.setActiveItem(option);\n    }\n\n    toggleFocusedOption(): void {\n        const focusedOption = this.keyManager.activeItem;\n\n        if (focusedOption && (!focusedOption.selected || this.canDeselectLast(focusedOption))) {\n            focusedOption.toggle();\n            this.emitChangeEvent(focusedOption);\n        }\n    }\n\n    renderNodeChanges(\n        data: T[],\n        dataDiffer: IterableDiffer<T> = this.dataDiffer,\n        viewContainer: ViewContainerRef = this.nodeOutlet.viewContainer,\n        parentData?: T\n    ): void {\n        super.renderNodeChanges(data, dataDiffer, viewContainer, parentData);\n\n        this.sortedNodes = this.getSortedNodes(viewContainer);\n\n        this.updateScrollSize();\n\n        this.nodeOutlet.changeDetectorRef.detectChanges();\n    }\n\n    getHeight(): number {\n        const clientRects = this.elementRef.nativeElement.getClientRects();\n\n        if (clientRects.length) {\n            return clientRects[0].height;\n        }\n\n        return 0;\n    }\n\n    getItemHeight(): number {\n        return this.renderedOptions.first ? this.renderedOptions.first.getHeight() : 0;\n    }\n\n    emitNavigationEvent(option: T): void {\n        this.navigationChange.emit(new McTreeNavigationChange(this, option));\n    }\n\n    emitChangeEvent(option: T): void {\n        this.selectionChange.emit(new McTreeNavigationChange(this, option));\n    }\n\n    writeValue(value: any): void {\n        if (this.multiple && value && !Array.isArray(value)) {\n            throw getMcSelectNonArrayValueError();\n        }\n\n        if (this.renderedOptions.length) {\n            this.setOptionsFromValues(this.multiple ? value : [value]);\n        }\n    }\n\n    /** `View -> model callback called when value changes` */\n    onChange: (value: any) => void = () => {};\n\n    registerOnChange(fn: (value: any) => void): void {\n        this.onChange = fn;\n    }\n\n    /** `View -> model callback called when select has been touched` */\n    onTouched = () => {};\n\n    registerOnTouched(fn: () => {}): void {\n        this.onTouched = fn;\n    }\n\n    /**\n     * Sets the disabled state of the control. Implemented as a part of ControlValueAccessor.\n     */\n    setDisabledState(isDisabled: boolean): void {\n        this._disabled = isDisabled;\n        this.changeDetectorRef.markForCheck();\n    }\n\n    setOptionsFromValues(values: any[]): void {\n        this.selectionModel.clear();\n\n        const valuesToSelect = values.reduce((result, value) => {\n            return this.treeControl.hasValue(value) ? [...result, this.treeControl.hasValue(value)] : [...result];\n        }, []);\n\n        this.selectionModel.select(...valuesToSelect);\n    }\n\n    getSelectedValues(): any[] {\n        return this.selectionModel.selected.map((selected) => this.treeControl.getValue(selected));\n    }\n\n    protected updateTabIndex(): void {\n        this._tabIndex = this.renderedOptions.length === 0 ? -1 : 0;\n    }\n\n    private updateRenderedOptions = () => {\n        const orderedOptions: T[] = [];\n\n        this.sortedNodes.forEach((node) => {\n            const found = this.unorderedOptions.find((option) => option.value === this.treeControl.getValue(node));\n\n            if (found) {\n                orderedOptions.push(found);\n            }\n        });\n\n        this.renderedOptions.reset(orderedOptions);\n        this.renderedOptions.notifyOnChanges();\n    }\n\n    private getSortedNodes(viewContainer: ViewContainerRef) {\n        const array: T[] = [];\n\n        for (let i = 0; i < viewContainer.length; i++) {\n            const viewRef = viewContainer.get(i) as any;\n\n            array.push(viewRef.context.$implicit);\n        }\n\n        return array;\n    }\n\n    private allowFocusEscape() {\n        if (this._tabIndex !== -1) {\n            this._tabIndex = -1;\n\n            setTimeout(() => {\n                this._tabIndex = this.userTabIndex || 0;\n                this.changeDetectorRef.markForCheck();\n            });\n        }\n    }\n\n    private resetOptions() {\n        this.dropSubscriptions();\n        this.listenToOptionsFocus();\n    }\n\n    private dropSubscriptions() {\n        if (this.optionFocusSubscription) {\n            this.optionFocusSubscription.unsubscribe();\n            this.optionFocusSubscription = null;\n        }\n\n        if (this.optionBlurSubscription) {\n            this.optionBlurSubscription.unsubscribe();\n            this.optionBlurSubscription = null;\n        }\n    }\n\n    private listenToOptionsFocus(): void {\n        this.optionFocusSubscription = this.optionFocusChanges\n            .subscribe((event) => {\n                const index: number = this.renderedOptions.toArray().indexOf(event.option as T);\n\n                this.renderedOptions\n                    .filter((option) => option.hasFocus)\n                    .forEach((option) => option.hasFocus = false);\n\n                if (this.isValidIndex(index)) {\n                    this.keyManager.updateActiveItem(index);\n                }\n            });\n\n        this.optionBlurSubscription = this.optionBlurChanges\n            .subscribe(() => this.blur());\n    }\n\n    /**\n     * Utility to ensure all indexes are valid.\n     * @param index The index to be checked.\n     * @returns True if the index is valid for our list of options.\n     */\n    private isValidIndex(index: number): boolean {\n        return index >= 0 && index < this.renderedOptions.length;\n    }\n\n    /** Checks whether any of the options is focused. */\n    private hasFocusedOption() {\n        return this.renderedOptions.some((option) => option.hasFocus);\n    }\n\n    private markOptionsForCheck() {\n        if (this.renderedOptions.length) {\n            this.renderedOptions.forEach((option) => option.markForCheck());\n        }\n    }\n\n    private updateOptionsFocus() {\n        this.renderedOptions\n            .filter((option) => option.hasFocus)\n            .forEach((option) => option.hasFocus = false);\n    }\n\n    private canDeselectLast(option: McTreeOption): boolean {\n        return !(this.noUnselectLast && this.selectionModel.selected.length === 1 && option.selected);\n    }\n\n    private isFocusReceivedFromNestedOption($event: FocusEvent) {\n        if (!$event || !$event.relatedTarget) { return false; }\n\n        return ($event.relatedTarget as HTMLElement).classList.contains('mc-tree-option');\n    }\n}\n\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { CdkTreeModule } from '@ptsecurity/cdk/tree';\nimport { McPseudoCheckboxModule } from '@ptsecurity/mosaic/core';\n\nimport { McTreeNodeDef } from './node.directive';\nimport { McTreeNodePadding } from './padding.directive';\nimport { McTreeNodeToggleDirective, McTreeNodeToggleComponent } from './toggle';\nimport { McTreeOption } from './tree-option.component';\nimport { McTreeSelection } from './tree-selection.component';\n\n\nconst MC_TREE_DIRECTIVES = [\n    McTreeSelection,\n    McTreeOption,\n    McTreeNodeDef,\n    McTreeNodePadding,\n    McTreeNodeToggleComponent,\n    McTreeNodeToggleDirective\n];\n\n@NgModule({\n    imports: [CommonModule, CdkTreeModule, McPseudoCheckboxModule],\n    exports: MC_TREE_DIRECTIVES,\n    declarations: MC_TREE_DIRECTIVES\n})\nexport class McTreeModule {}\n","import { CollectionViewer, DataSource } from '@angular/cdk/collections';\nimport { FlatTreeControl, TreeControl } from '@ptsecurity/cdk/tree';\nimport { BehaviorSubject, merge, Observable } from 'rxjs';\nimport { map, take } from 'rxjs/operators';\n\n\n/**\n * Tree flattener to convert a normal type of node to node with children & level information.\n * Transform nested nodes of type `T` to flattened nodes of type `F`.\n *\n * For example, the input data of type `T` is nested, and contains its children data:\n *   SomeNode: {\n *     key: 'Fruits',\n *     children: [\n *       NodeOne: {\n *         key: 'Apple',\n *       },\n *       NodeTwo: {\n *        key: 'Pear',\n *      }\n *    ]\n *  }\n *  After flattener flatten the tree, the structure will become\n *  SomeNode: {\n *    key: 'Fruits',\n *    expandable: true,\n *    level: 1\n *  },\n *  NodeOne: {\n *    key: 'Apple',\n *    expandable: false,\n *    level: 2\n *  },\n *  NodeTwo: {\n *   key: 'Pear',\n *   expandable: false,\n *   level: 2\n * }\n * and the output flattened type is `F` with additional information.\n */\nexport class McTreeFlattener<T, F> {\n    constructor(\n        public transformFunction: (node: T, level: number, parent: F | null) => F,\n        public getLevel: (node: F) => number,\n        public isExpandable: (node: F) => boolean,\n        public getChildren: (node: T) => Observable<T[]> | T[] | undefined | null\n    ) {}\n\n    flattenNode(node: T, level: number, resultNodes: F[], parent: F | null): F[] {\n        const flatNode = this.transformFunction(node, level, parent);\n        resultNodes.push(flatNode);\n\n        if (this.isExpandable(flatNode)) {\n            const childrenNodes = this.getChildren(node);\n\n            if (childrenNodes) {\n                if (Array.isArray(childrenNodes)) {\n                    this.flattenChildren(childrenNodes, level, resultNodes, flatNode);\n                } else {\n                    childrenNodes\n                        .pipe(take(1))\n                        .subscribe((children) => {\n                            this.flattenChildren(children, level, resultNodes, flatNode);\n                        });\n                }\n            }\n        }\n\n        return resultNodes;\n    }\n\n    flattenChildren(children: T[], level: number, resultNodes: F[], parent: F | null): void {\n        children.forEach((child) => {\n            this.flattenNode(child, level + 1, resultNodes, parent);\n        });\n    }\n\n    /**\n     * Flatten a list of node type T to flattened version of node F.\n     * Please note that type T may be nested, and the length of `structuredData` may be different\n     * from that of returned list `F[]`.\n     */\n    flattenNodes(structuredData: T[]): F[] {\n        const resultNodes: F[] = [];\n        structuredData.forEach((node) => this.flattenNode(node, 0, resultNodes, null));\n\n        return resultNodes;\n    }\n\n    /**\n     * Expand flattened node with current expansion status.\n     * The returned list may have different length.\n     */\n    expandFlattenedNodes(nodes: F[], treeControl: TreeControl<F>): F[] {\n        const results: F[] = [];\n        const currentExpand: boolean[] = [];\n        currentExpand[0] = true;\n\n        nodes.forEach((node) => {\n            let expand = true;\n            for (let i = 0; i <= this.getLevel(node); i++) {\n                expand = expand && currentExpand[i];\n            }\n\n            if (expand) { results.push(node); }\n\n            if (this.isExpandable(node)) {\n                currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);\n            }\n        });\n\n        return results;\n    }\n}\n\nenum McTreeDataSourceChangeTypes {\n    Expansion = 'expansion',\n    Filter = 'filter'\n}\n\n/**\n * Data source for flat tree.\n * The data source need to handle expansion/collapsion of the tree node and change the data feed\n * to `McTree`.\n * The nested tree nodes of type `T` are flattened through `MсTreeFlattener`, and converted\n * to type `F` for `McTree` to consume.\n */\nexport class McTreeFlatDataSource<T, F> extends DataSource<F> {\n    flattenedData = new BehaviorSubject<F[]>([]);\n\n    expandedData = new BehaviorSubject<F[]>([]);\n\n    filteredData = new BehaviorSubject<F[]>([]);\n\n    get data() {\n        return this._data.value;\n    }\n\n    set data(value: T[]) {\n        this._data.next(value);\n\n        this.flattenedData.next(this.treeFlattener.flattenNodes(this.data));\n        this.treeControl.dataNodes = this.flattenedData.value;\n    }\n\n    private _data: BehaviorSubject<T[]>;\n\n    constructor(\n        private treeControl: FlatTreeControl<F>,\n        private treeFlattener: McTreeFlattener<T, F>,\n        initialData: T[] = []\n    ) {\n        super();\n\n        this._data = new BehaviorSubject<T[]>(initialData);\n    }\n\n    connect(collectionViewer: CollectionViewer): Observable<F[]> {\n        return merge(\n            collectionViewer.viewChange,\n            this.treeControl.expansionModel.changed\n                .pipe(map((value) => ({ type: McTreeDataSourceChangeTypes.Expansion, value }))),\n            this.treeControl.filterValue\n                .pipe(map((value) => ({ type: McTreeDataSourceChangeTypes.Filter, value }))),\n            this.flattenedData\n        )\n        .pipe(map((changeObj: any): any => {\n            if (changeObj.type === McTreeDataSourceChangeTypes.Filter) {\n                if (changeObj.value && changeObj.value.length > 0) {\n                    return this.filterHandler();\n                } else {\n                    return this.expansionHandler();\n                }\n            }\n\n            return this.expansionHandler();\n        }));\n    }\n\n    filterHandler(): F[] {\n        this.filteredData.next(this.treeControl.filterModel.selected);\n\n        return this.filteredData.value;\n    }\n\n    expansionHandler(): F[] {\n        const expandedNodes = this.treeFlattener.expandFlattenedNodes(this.flattenedData.value, this.treeControl);\n        this.expandedData.next(expandedNodes);\n\n        return this.expandedData.value;\n    }\n\n    disconnect() {\n        // no op\n    }\n}\n\n","import { CollectionViewer, DataSource } from '@angular/cdk/collections';\nimport { BehaviorSubject, merge, Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n\n/**\n * Data source for nested tree.\n *\n * The data source for nested tree doesn't have to consider node flattener, or the way to expand\n * or collapse. The expansion/collapsion will be handled by TreeControl and each non-leaf node.\n */\nexport class McTreeNestedDataSource<T> extends DataSource<T> {\n\n    get data() {\n        return this._data.value;\n    }\n\n    set data(value: T[]) {\n        this._data.next(value);\n    }\n\n    /* tslint:disable-next-line:naming-convention */\n    private _data = new BehaviorSubject<T[]>([]);\n\n    connect(collectionViewer: CollectionViewer): Observable<T[]> {\n        return merge(...[collectionViewer.viewChange, this._data])\n            .pipe(map(() => this.data));\n    }\n\n    disconnect() {\n        // no op\n    }\n}\n\n"]}